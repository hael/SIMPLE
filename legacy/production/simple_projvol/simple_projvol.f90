!==Program simple_projvol
!
! <projvol/begin> is a program for projecting a volume using interpolation in Fourier space. Input is a SPIDER or
! MRC volume. Output is a stack of projection images of the same format as the inputted volume. <comment/begin> Projections
! are generated by extraction of central sections from the Fourier volume and back transformation of the 2D FTs.
! \texttt{nspace} controls the number of projection images generated with quasi-even projection directions.The
! \texttt{oritab} parameter allows you to input the orientations that you wish to have your volume projected in. If
! \texttt{rnd=yes}, random rather than quasi-even projections are generated, \texttt{trs} then controls the halfwidth of
! the random origin shift. Less commonly used parameters are \texttt{pgrp}, which controls the point-group symmetry
! \texttt{c} (rotational), \texttt{d} (dihedral), \texttt{t} (tetrahedral), \texttt{o} (octahedral) or \texttt{i} 
! (icosahedral). The point-group symmetry is used to restrict the set of projections to within the asymmetric unit. 
! \texttt{ctf=yes} allows you to apply CTF to the images, using constant defocus and no astigmatism. If you want to do 
! this you need to define the parameters \texttt{kv}, \texttt{fraca}, \texttt{cs}, \texttt{defocus} and \texttt{bfac}. 
! \texttt{neg} inverts the contrast of the projections. \texttt{mirr=yes} mirrors the projection by modifying the Euler 
! angles. If \texttt{mirr=x} or \texttt{mirr=y} the projection is physically mirrored after it has been generated.
! <comment/end> <projvol/end>
!
! The code is distributed with the hope that it will be useful, but _WITHOUT_ _ANY_ _WARRANTY_.
! Redistribution and modification is regulated by the GNU General Public License.
! *Author:* Hans Elmlund 2012
!
program simple_projvol
use simple_cmdline, only: cmdline
use simple_build,   only: build
use simple_params,  only: params
use simple_image,   only: image
use simple_jiffys,  only: simple_end, nlines, del_binfile, file_exists
implicit none
type(params)             :: p
type(build)              :: b
type(cmdline)            :: cline
type(image), allocatable :: imgs(:)
integer                  :: i, loop_end
real                     :: x, y, dfx, dfy, angast
logical                  :: debug=.false.
if( command_argument_count() < 3 )then
    write(*,'(a)',advance='no') 'SIMPLE_PROJVOL vol1=<invol.ext> smpd=<sampling distance(in A)>'
    write(*,'(a)',advance='no') ' [nspace=<nr of projs{1000}>] [outstk=<ouput stack>] [oritab=<SIMPLE alignment doc>]'
    write(*,'(a)') ' [nthr=<nr of openMP threads{1}>] [rnd=<yes|no{no}>] [trs=<origin shift(in pixels){0}>]'
    write(*,'(a)') '**less commonly used**'
    write(*,'(a)',advance='no') ' [pgrp=<cn|dn|t|o|i{c1}>] [ctf=<yes|no|flip|mul{no}>] [kv=<acceleration'
    write(*,'(a)',advance='no') ' voltage(in kV){300.}>] [fraca=<frac amp contrast{0.07}>] [cs=<spherical aberration'
    write(*,'(a)',advance='no') ' constant(in mm){2.7}>] [defocus=<underfocus(in microns){3.}>] [bfac=<bfactor(in A**2)'
    write(*,'(a)',advance='no') '{200.}>] [neg=<yes|no{no}>] [mirr=<yes|x|y|no{no}>] [top=<stop at this index>]'
    write(*,'(a)') ' [xfel=<yes|no{no}>]'
    stop
endif
call cline%parse
call cline%checkvar('vol1', 1)
call cline%checkvar('smpd', 2)
if( .not. cline%defined('wfun') )  call cline%set('wfun', 'kb')
if( .not. cline%defined('winsz') ) call cline%set('winsz', 1.5)
if( .not. cline%defined('alpha') ) call cline%set('alpha', 2.)
if( .not. cline%defined('oritab') )then
    if( .not. cline%defined('nspace') ) stop 'need nspace (for number of projections)!'
endif
call cline%check
call cline%set('prg', 'projvol')
p = params(cline) ! parameters generated
if( cline%defined('oritab') )then
    p%nptcls = nlines(p%oritab)
    call b%build_general_tbox(p, cline)
    call b%a%read(p%oritab)
    p%nspace = b%a%get_noris()
else if( p%rnd .eq. 'yes' )then
    p%nptcls = p%nspace
    call b%build_general_tbox(p, cline)
    call b%a%rnd_oris(p%trs)
else
    p%nptcls = p%nspace
    call b%build_general_tbox(p, cline)
    call b%a%spiral(p%nsym, p%eullims)
    if( cline%defined('trs') ) call b%a%rnd_inpls(p%trs)
endif
! FIX VOLUMES AND STACKS
if( p%xfel .eq. 'yes' )then
    call b%vol%read(p%vols(1), isxfel=.true.)
else
    call b%vol%read(p%vols(1))
endif
if( debug ) print *, 'read volume'
! GENERATE PROJECTIONS
if( p%swap .eq. 'yes' ) call b%a%swape1e3
if( p%mirr .eq. 'yes' ) call b%a%mirror2d
if( cline%defined('top') )then
    imgs = b%proj%projvol(b%vol, b%a, p, p%top)
    loop_end = p%top
else
    imgs = b%proj%projvol(b%vol, b%a, p)
    loop_end = p%nspace
endif
if( file_exists(p%outstk) ) call del_binfile(p%outstk)
do i=1,loop_end
    if( cline%defined('oritab') .or. (p%rnd .eq. 'yes' .or. cline%defined('trs')) )then
        x = b%a%get(i, 'x')
        y = b%a%get(i, 'y')
        call imgs(i)%shift(x, y)
    endif
    if( p%ctf .ne. 'no' )then
        if( cline%defined('oritab') )then
            dfx    = b%a%get(i, 'dfx')
            if( b%a%isthere('dfy') )then
                dfy    = b%a%get(i, 'dfy')
                angast = b%a%get(i, 'angast')
            else
                dfy = dfx
                angast = 0.
            endif
        else
            dfx    = p%defocus
            dfy    = p%defocus
            angast = 0.
            call b%a%set(i, 'dfx', dfx)
        endif
        if( cline%defined('bfac') )then
            if( p%neg .eq. 'yes' )then
                call b%tfun%apply(imgs(i), dfx, 'neg', dfy, angast, bfac=p%bfac)
            else
                call b%tfun%apply(imgs(i), dfx, 'ctf', dfy, angast, bfac=p%bfac)
            endif
        else
            if( p%neg .eq. 'yes' )then
                call b%tfun%apply(imgs(i), dfx, 'neg', dfy, angast)
            else
                call b%tfun%apply(imgs(i), dfx, 'ctf', dfy, angast)
            endif
        endif
    else if( p%neg .eq. 'yes' )then
        call imgs(i)%neg
    endif
    if( p%mirr .ne. 'no' )then
        if( p%mirr .ne. 'yes' ) call imgs(i)%mirror(p%mirr)
    endif
    call imgs(i)%write(p%outstk,i)
end do
call b%a%write('projvol_oris.txt')
call simple_end('**** SIMPLE_PROJVOL NORMAL STOP ****')
end program simple_projvol
