function handle=WriteMRCHeader(map,pixA,filename,sizes,org,mode,isVol,handle)% function handle=WriteMRCHeader(map,pixA,filename,sizes,org,mode,isVol, handle)% Write out the header of an MRC map file, and leave the file open,% returning the file handle, so that data can be written sequentially into% the file and then the file closed.  Data are written in little-endian style,% with the datatype specified by mode.  By default mode=2, which means% float32 values.  Other options are 0: uint8; 1: int16; 6: uint16;% 32: our own packed uint4.% If handle is given, it is used instead of opening a new file.% If you want to write more slices than are contained in map, give the% total number of slices (or 2d images) in the optional sizes argument.% Alternatively you can give the total size of the map to be written as% sizes=[nx ny nz nvols]. The optional argument org is the starting point of the% volume, an integer in units of voxels.  The default value is [c c c]% where c=-floor(n/2). The flag isVol (default 0) says that a 3D array map is interpreted as% a volume; a 4D map is always a stack of volumes.% We compute max, min and mean statistices, and std when map has <=2^24% elements.%% Example: write out 10,000 random images.%     images=randn(64,64,1000);%     f=WriteMRCHeader(images,2.8,'test.mrc',10000);%     fwrite(f,images,'float32');%     for i=2:10%         images=randn(64,64,1000);%         fwrite(f,images,'float32');%     end;%     fclose(f);% % Changed Jul2011 to support the origin argument.  fs% Changed Dec2011 to support the mode argument.% Changed Sep2013 to support 3-element sizes argument.% Files are always written in little-ended format.% Changed May2015 to support stacks of volumes and stats according to MRC2015%  Create the header as 32-bit integershdr=int32(zeros(256,1));% Figure out if we have a little-ended machine.[~,~,endian]=computer;machineLE=(endian=='L');% Set the versionnVersion=20140;  % MRC2014 version specified by Cheng et al. JSB 2015% sizes can be%  - absent or 0, same as size(map)%  - a scalar, in which case it's equal to number of planes nz%  - a vector, where it gives the size of the map, nx ny nzif nargin<4    sizes=size(map);    % default: simply the size of mapelseif numel(sizes)==1  % 0 or the number of planes    if sizes==0        sizes=size(map);    else        sizes=[size(map,1) size(map,2) sizes];    end;end;sizes(end+1:4)=1;nVals=[sizes(1:2) prod(sizes(3:4))];  % nx ny nzmVals=sizes(1:3);  % 'unit cell'if nargin<5 || numel(org)<2    org=-floor(mVals/2);  % Default origin is centerelse    org=org(:);end;if nargin<6    mode=2;end;if nargin<7    isVol=0;  % by default, we are a stack of images.end;if nargin<8    handle=0;end;%     % Get statistics.if mode==32    corr=1/16;  % approximate correction for packed dataelse    corr=1;end;map=map(:);  % convert it into a 1D vectortheMean=mean(single(map))*corr;if numel(map)<=2^24    theSD=std(single(map))*corr;else    theSD=-1;  % skip for very large arrays.end;theMax=single(max(map))*corr;theMin=single(min(map))*corr;% Number of voxels in the map or submaphdr(1:3)=nVals; % number of columns, rows, sectionshdr(4)=mode;  % mode: real, float valueshdr(5:7)=0;  % first col, row, slice% Number of voxels in the full unit cellhdr(8:10)=mVals;  % number of intervals along x,y,z% Unit cell sizes and angleshdr(11:13)=typecast(single(single(hdr(8:10))*pixA),'int32');  % Cell dimensionshdr(14:16)=typecast(single([90 90 90]),'int32');   % Angleshdr(17:19)=(1:3)';  % Axis assignmentshdr(20:22)=typecast(single([theMin theMax theMean]'),'int32');hdr(23)=isVol+400*(size(map,4)>1);  % 0 = 2D; 1 = 3D; 401 = stack of 3Dhdr(28)=nVersion;hdr(20:22)=typecast(single([theMin theMax theMean]'),'int32');hdr(50:52)=typecast(single(org),'int32');  % floating point originif machineLE    hdr(53)=typecast(uint8('MAP '),'int32');    hdr(54)=typecast(uint8([68 65 0 0]),'int32');  % LE machine stamp.else    hdr(53)=typecast(uint8(' PAM'),'int32');  % LE machine stamp, for writing with BE machine.    hdr(54)=typecast(uint8([0 0 65 68]),'int32');endhdr(55)=typecast(single(theSD),'int32');if handle==0  % no file handle given    handle=fopen(filename,'w','ieee-le');  % Here we force little-ended order.    if handle<0        error(['File could not be opened for writing: ' filename]);    end;end;count1=fwrite(handle,hdr,'int32');