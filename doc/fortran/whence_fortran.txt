The SIMPLE philosophy in three quotes

"Keep It SIMPLE, Stupid!"(Kelly Johnson, lead engineer at the Lockheed Skunk Works, coined the famous KISS principle 
stating that systems work best if they are kept simple rather than made complex, therefore 
simplicity should be a key goal in design and unnecessary complexity should be avoided.)"Everything should be made as SIMPLE as possible, but no simpler"(Albert Einstein)"Complex theories do not work, SIMPLE algorithms do"
(Vladimir Vapnik, author of â€œThe Nature of Statistical Learning Theory)

Selecting the programming language is important, why FORTRAN?

Because Real Programmers use FORTRAN ;-) This is an extract from a letter to the editor 
of Datamation, volume 29 number 7, July 1983:

"The easiest way to tell a Real Programmer from the crowd is by the programming language 
he (or she) uses. Real Programmers use FORTRAN. The only parameter passing mechanism 
endorsed by Real Programmers is call-by-value-return, as implemented in the IBM/370 
FORTRAN G and H compilers. Real Programmers don't need all these abstract concepts to 
get their jobs done--they are perfectly happy with a keypunch, a FORTRAN IV compiler, 
and a beer."

Whence Modern FORTRAN? Not F77 or F90 or even F2003, but F2008!

(1) Produces the fastest compiled code for large numerical applications.
    This is thanks to very clever compiler designers.
    
(2) Is object-oriented (~ the same level as C++)
    Yes, you heard right! The class exists in FORTRAN from release F2003, so does 
    operator overloading, inheritance, type-bound procedures (or instance methods), 
    generic programming, abstract classes, abstract interfaces, procedure pointers,
    functional programming, and so on

(3) Object-Oriented + very easy to learn => removes the need for scripting
    (I hate scripting)

(4) Mathematically sound syntax, not as C or C++ with their nasty bitwise operators
    $var++, ++$var, >>$var<<
    
(5) Powerful array operations with a syntax that is almost identical to
    Matlab. I'm telling you, it's neat!
    
(6) Co-Arrays: a new paradigm for parallel computation,
    moving the parallel directives into the FORTRAN language itself. What does this mean?
    No longer do we have to worry about the parallellization model: OpenMP, MPI,
    CUDA, etc. Compilers are being designed for all of these flavors and we will 
    get unified access to them from within FORTRAN.
    
(7) Despite the common belief of thew obsoletedness of FORTRAN, it is a programming 
    language that is being continuously revised and improved (thanks to the 
    high-performance computing community)
    
(8) And it really does not matter if you are in love with C or C++. F2003
    is fully compatible with C or C++. You need to write a few wrappers, but C or C++ and
    F2003 compile gracefully together.

Ok, stripping off the technical jargon, what is it all about?

* We want our technical developments to be accessible, understandable, and re-usable in 
an economical fashion. 

* We want to be able to run-time modify algorithms, perhaps selected a different goal
function, a different interpolation scheme, a different weighting scheme, a different 
optimizer, etc.

* We want to create our own language of operations that is more sophisticated 
and expressive than, for example, Spider (REF). And we (or I) do not want to blend 
in Python or Ruby for this purpose (becaue it is not needed and it only complicates
things).

* We want our implementations to be testable. Test-driven development and extensive unit 
testing is all part of the industrial standards but shouldn't it dictate the rules also for 
academic software development? How do you feel about writing the unit tests before the
code? Code to an interface, not to an implementation!

Argument against: Ah, it takes time to learn all these new concepts. Yes, indeed it does, but it
 is economical in the long run. Look at the software industry: their interest is to make money 
and they have taken the time to implement all these concepts, precisely because it is economical.

It will take you 20 minutes to implement a direct Fourier inversion algorithm in SIMPLE using
the winfuns class to select the kernel, using the recvol class to do the gridding, and selecting
one among the few available density compensation methods.

Structured programming reduces the barrier to learning and enable us to discuss 
software in intelligble terms. Altough stringent formalism and sholary publicaions are important,
your code is an equally important document of your technical developments. With properly
structured code and good comments surrounding a robust algorithm, your peers are more likely
to steal a snippet and (perhaps) give you a reference. Your work will have
a larger impact!

Structured programming is a requirement for collaborative software development. Why doesn't everybody 
that are interested in single-particle image processing do like the X-ray folks and define common 
libraries that we maintain together. There are certainly room for many libraries in electron 
microscopy, but how much of the code out there is structured according to modern standards? 
Collaborative software development reduces the number of serious bugs and the time it 
takes to identify them.

This kind of captures the idea behind SIMPLE from a developers perspective. From the user
point of view I wanted to create a system that was less of a black-box than EMAN, easier
to use than Frealign or Spider and that enabled robust ab initio reconstruction, free of charge
and open source.













 