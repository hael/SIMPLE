<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><!-- InstanceBegin template="/Templates/template.dwt" codeOutsideHTMLIsLocked="false" -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- InstanceBeginEditable name="doctitle" -->
<title>manuals for single-particle cryo-electron microscopy reconstruction with SIMPLE</title>
<!-- InstanceEndEditable -->
<style type="text/css">
body,td,th {
	color: #FFFFFF;
}
body {
	background-image: url(images/fractal.jpg);
	background-attachment: fixed;
	margin-top: 0px;
	margin-right: 0px;
	margin-bottom: 0px;
	margin-left: 0px;
	background-color: rgb(0,0,0);
	background-repeat: repeat;
}
</style>
<link href="common_styles.css" rel="stylesheet" type="text/css">
<script src="SpryAssets/SpryMenuBar.js" type="text/javascript"></script>
<link href="SpryAssets/SpryMenuBarHorizontal.css" rel="stylesheet" type="text/css">
<!-- InstanceBeginEditable name="head" -->
<style type="text/css">
</style>
<script src="SpryAssets/SpryAccordion.js" type="text/javascript"></script>
<link href="SpryAssets/SpryAccordion.css" rel="stylesheet" type="text/css">
<!-- InstanceEndEditable -->
<script type="text/xml">
<!--
<oa:widgets>
  <oa:widget wid="2149022" binding="#OAWidget" />
</oa:widgets>
-->
</script>
<style type="text/css">
a:link {
	color: rgb(153,0,51);
}
a:visited {
	color: rgb(187,0,62);
}
a:hover {
	color: rgb(187,0,62);
}
a:active {
	color: rgb(187,0,62);
}
h1,h2,h3,h4,h5,h6 {
	font-family: Verdana, Geneva, sans-serif;
}
h1 {
	color: rgb(0,0,0);
}
h2 {
	font-size: 18px;
	color: rgb(153,0,0);
}
</style>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-31924791-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
<link rel="shortcut icon" href="http://simplecryoem.com/favicon.ico" >
</head>

<body bgcolor="#000000">
<a name="top"></a>
<div class="logo_div"><img src="images/SIMPLE_banner.png" alt="SIMPLE banner" width="830" height="110" align="absmiddle"></div>
<div class="nav_div">
  <ul id="MenuBar1" class="MenuBarHorizontal">
    <li><a href="index.html">About</a>    </li>
    <li><a href="download_form.html">Download</a></li>
    <li><a href="workflow.html">Workflow</a></li>
    <li><a href="manuals.html">Manuals</a></li>
    <li><a href="structures.html">Structures</a></li>
    <li><a href="references.html">References</a></li>
    <li><a href="contact.html">Contact </a></li>
  </ul>
</div>
<!-- InstanceBeginEditable name="EditRegion1" -->
<div class="content_div">
  <h1>How to do single-particle reconstruction with SIMPLE 2.0</h1>
  <h2 class="h2_manual" align="center"><a href="http://simplecryoem.com/2.0/documents/simple_manual_release2.pdf" target="_new">simple_manual_release2.pdf</a></h2>
  <h2 class="h2_manual" align="left"> &nbsp; &nbsp;About SIMPLE 2.0</h2>
  <p class="text"> &nbsp;  Single-particle IMage Processing Linux Engine (SIMPLE) does ab initio 3D reconstruction, heterogeneity analysis, and refinement. The SIMPLE back-end consists of an object-oriented numerical library with a single external dependency &#45; the Fastest Fourier Transform in the West (FFTW) (Frigo and Johnson, 2005). The SIMPLE front-end consists of a few standalone, interoperable components developed according to the Unix toolkit philosophy.
SIMPLE is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the license, or (at your option) any later version. </p>
  <p class="text">SIMPLE is distributed with the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see <a href="http://www.gnu.org/licenses/" target="_new">http://www.gnu.org/licenses/</a>.<br>
   &nbsp; &nbsp; The SIMPLE codes prioritize computational efficiency, robustness, parameter-free, and empiric design over mathematical elegance. One of the SIMPLE development goals is to move cryo-EM image processing from the distributed computing environments to multicore desktop computers. SIMPLE is written in modern Fortran, which combines the high performance of compiled code with the ease of development via object oriented design paradigms. The modular design of the SIMPLE suite invites advanced users to develop new alignment and 3D reconstruction algorithms. Most of the SIMPLE algorithms are parallelized for shared-memory architectures using the OpenMP protocol. The most intensive parts of the calculations are parallelized for distributed systems according to a SMPD (Single Program Multiple Data) model. </p>
   <h2 class="h2_manual" align="left"> &nbsp; &nbsp;What's new in release 2.0?</h2>
  <p class="text"> &nbsp; Compiler support for object-oriented Fortran development was limited when we released SIMPLE 1.0. Now the open-source compiler gfortran <a href="http://gcc.gnu.org/wiki/GFortran" target="_new">http://gcc.gnu.org/wiki/GFortran</a>  provides full support for Fortran 2003. SIMPLE 1.0 was compiled using the Intel Fortran compiler, but all the code has been refactored to conform to the new standard and compiles using <strong>gfortran 4.7.1 or newer.</strong> It should be a walk in the park to <strong>compile SIMPLE 2.0 on a mac or linux</strong> machine and we also provide pre-compiled distributions (as described below). SIMPLE 2.0 was developed using test-driven development and comes with a set of automatic unit tests. We  use <strong>Spider stacks and Spider volumes</strong> exclusively (<a href="http://www.wadsworth.org/spider_doc/spider/docs/formats.html" target="_new">http://www.wadsworth.org/spider_doc/spider/docs/formats.html</a>). All major electron microscopy image-processing packages can convert to Spider files. We have replaced the common lines-based routines with a new probabilistic cryo-EM image alignment method (<strong>simple_prime</strong> described below).</p>
  <p class="text">&nbsp;</p>



  <div id="Accordion1" class="Accordion" >
  
    <div class="AccordionPanel">
    <div class="AccordionPanelTab">Installation of SIMPLE 2.0</div>
    <div class="AccordionPanelContent">
      <p>&gt;&gt;&gt; mv Downloads/simple2.tar.gz /myfolder</p>
      <p>&gt;&gt;&gt; gunzip simple2.tar.gz</p>
      <p>&gt;&gt;&gt; tar -xvf simple2.tar</p>
      <p>&gt;&gt;&gt; cd simple2</p>
      <p>&gt;&gt;&gt; ./simple_config.pl</p>
      <p>Installation on local/biox3/delphi?</p>
      <p>The precompiled programs in /myfolder/simple2/bin have been compiled on a 64-bit Linux AMD machine. If you want executable binaries for mac or other Linux/Unix architectures you&rsquo;d have to compile the suite yourself (see <strong>Compilation of SIMPLE</strong>, below). Biox3 is the cluster that we use for distributed SIMPLE execution and delphi is the cluster used by the Grigorieff lab. Biox3 and delphi are both equipped with the portable batch system (PBS) for job scheduling. However, there are many different versions of the PBS and if you want a distributed SIMPLE version you will have to take a look at the distr_simple.pl and distr_simple_prime.pl scripts in the apps folder (see <strong>Distributed Execution </strong>below for details). Biox3 and delphi should be considered as templates to modify according to your cluster. We are happy to help anyone that is not comfortable with simple perl scripting, just use the contact form on the simple website to get in touch with us. </p>
      <p>&gt;&gt;&gt; local</p>
      <p>The produced files source_tcsh and source_bash containing the lines you need to add to your .cshrc or .bashrc file, respectively, in order to have prompt access to the SIMPLE programs. If you are compiling SIMPLE from source, the compiler options used by the compile script simple_compile.pl are valid for the gfortran compiler, assumed to be executed from the prompt with the command gfortran. No other compilers are currently supported. </p>
    </div>
  </div>
  
  
    <div class="AccordionPanel">
      <div class="AccordionPanelTab">Compilation of SIMPLE 2.0</div>
      <div class="AccordionPanelContent">
        <p>We provide pre-compiled binaries for linux but not for mac, so if you want mac binaries you will have to compile the suite yourself.<br>
The simple_compile.pl script takes care of compiling individual simple programs as well as the entire suite. It is assumed that gfortran 4.7.1 or newer is installed on your system <a href="http://gcc.gnu.org/wiki/GFortran">http://gcc.gnu.org/wiki/GFortran</a>. We have only tested compilation with up to gfortran version 4.8 and we can therefore not ensure that compilation will work with newer versions. If you get compiler bugs with newer versions of gfortran, please let us know. The environment variable FFTWLIB needs to point to the location where the FFTW (Fastest Fourier Transform in the West, <a href="http://fftw.org" target="new" >http://fftw.org</a>) library is installed. The typical mac bash directives look like</p>
        <p>export FFTWLIB=/sw/lib</p>
        <p>or</p>
        <p>export FFTWLIB=/sw2/lib</p>
        <p>If you use fink as a package manager on the mac, you install FFTW with the command</p>
        <p>sudo fink install fftw3 fftw3-shlibs</p>
        <p>Note that SIMPLE uses the single-precision FFTW library. We also provide the FFTW library for Linux together with SIMPLE, located in &lt;whatever path&gt;/simple/fftw-3.3.2. For compilation of the suite on a linux machine, cd to the SIMPLE directory and execute</p>
        <p>&gt;&gt;&gt; mkdir fftw</p>
        <p>&gt;&gt;&gt; cd fftw-3.3.2</p>
        <p>&gt;&gt;&gt; make clean</p>
        <p>&gt;&gt;&gt; ./configure prefix=&lt;whatever path&gt;/simple/fftw &#45;&#45;enable&#45;float &#45;&#45;enable&#45;threads</p>
        <p>&gt;&gt;&gt; make</p>
        <p>&gt;&gt;&gt; make install</p>
        <p>Once you have FFTW installed and the environment variable set you can compile the entire suite with the command</p>
        <p>&gt;&gt;&gt; ./simple_compile.pl prg=all_fast mac=no</p>
        <p>on a Linux machine, or the command</p>
        <p>&gt;&gt;&gt; ./simple_compile.pl prg=all_fast</p>
        <p>on a mac. This will compile a library of all core functionality and link this to the individual program units. The executable binaries end up in the folder &lt;whatever path&gt;/simple2/bin . We have experienced problems creating the library on some machines. If you experience problems, use the slower option of compiling without making a library</p>
        <p>&gt;&gt;&gt; ./simple_compile.pl prg=all</p>
        <p>If you want to compile only a single program, then give that program as input</p>
        <p>&gt;&gt;&gt; ./simple_compile.pl prg=simple_prime</p>
        <p>If you want to clean up all intermediate files produced during compilation, execute</p>
        <p>&gt;&gt;&gt; ./simple_compile.pl prg=clean</p>
        <p>You can turn off the compiler optimizations and turn on the debugging info by</p>
&gt;&gt;&gt; ./simple_compile.pl prg=simple_prime optimize=no </div>
    </div>
    
    <div class="AccordionPanel">
      <div class="AccordionPanelTab">Parallelization of SIMPLE 2.0</div>
      <div class="AccordionPanelContent">
        <p>There are two modes of parallelization used in SIMPLE. All programs are parallelized with OpenMP, using a shared-memory model (not for cluster environments). <strong>simple_prime</strong> is additionally parallelized using a single program multiple data (SMPD) model (suitable for both cluster and workstation environments). The OpenMP model is applied by setting command line variable nthr=X, where X is the number of threads. OpenMP is used by default but you can turn it off in compilation by</p>
        <p>&gt;&gt;&gt; ./simple_compile.pl prg=simple_prime para=no</p>
        <p>The SMPD model is executed by perl scripts distr_simple.pl and distr_simple_prime.pl. See <strong>Distributed SIMPLE execution, </strong>below for details on how to use SIMPLE in distributed computing environments. There are significant performance gains to be made by using the SPMD model for <strong>simple_prime</strong> execution in a workstation environment.</p>
      </div>
    </div>
    
    <div class="AccordionPanel">
      <div class="AccordionPanelTab">Instructions</div>
      <div class="AccordionPanelContent">
        <p>SIMPLE is not a standalone suite for single-particle reconstruction, but complements available developments. It is assumed that the windowed single-particle images represent 2D projections, and therefore, that the projection slice theorem applies (Bracewell, 1956). This requires correction of the micrographs due to the contrast transfer function (CTF) of the electron microscope and particle windowing using other software. &ldquo;CTF-corrected images&rdquo; refers to images corrected using the simple heuristic of binary phase flipping, adopted in numerous image-processing packages (Ludtke et al., 1999, Tang et al., 2007, van Heel et al., 1996). CTF-correction by phase flipping only corrects the resolution-dependent CTF phase inversions, disregarding the damping of Fourier amplitudes with increasing resolution. Phase-flipped images are noisier than images corrected with more accurate approaches, such as the reciprocal space adaptive Wiener filter (Penczek, 2010). So far, we have been primarily concerned with the problem of reconstructing accurate low-resolution maps <em>ab initio </em>from very noisy images. More sophisticated approaches for dealing with the CTF will be implemented in future SIMPLE releases. In EMAN, for example, the envelope component of the CTF, describing the falloff of the signal with resolution, is parameterized and then used in the class averaging procedure in the refinement. Some implementations only phase-corrects the micrographs, ignoring the envelope function initially. Instead, the final refined maps are B-factor sharpened. SIMPLE has so far been used in combination with the latter approach, assuming the same resolution falloff for all micrographs. The windowed projections should be roughly centered in the box. Many program suites are available for dealing with these and other matters (Frank et al., 1996, Hohn et al., 2007, Ludtke et al., 1999, Sorzano et al., 2004). The SIMPLE workflow is divided into four phases:</p>
        <ol>
          <li>CTF correction and particle windowing.</li>
          <li><em>Ab initio</em> reconstruction.</li>
          <li>Heterogeneity analysis.</li>
          <li>Refinement.</li>
        </ol>
        <p>For detailed instructions and a brief tutorial, see <a href="workflow.html" target="_new">workflow</a>.<br>
          The SIMPLE program instructions are listed in the order the programs are normally executed during the reconstruction process. Each paragraph begins with an overview description of the algorithms used by the program, followed by a paragraph describing how to execute the program, and ending with a paragraph of comments describing alternative execution routes. We have tried to keep parameter tweaking to a minimum by design but there are some strategies for tuning that may be useful (as described below). All SIMPLE programs are executed using the command line. Input and output consists of Spider image stacks, Spider volumes, Spider document files, .txt text files. The output is written directly to the working directory, giving you freedom to organize a directory structure that suits your needs. Remember that another round of execution in the same directory overwrites your old files. The notation &lt;what&gt; denotes input input parameter &ldquo;what&rdquo;. &lt;this|that&gt; denotes alternative input parameters &ldquo;this&rdquo; and &ldquo;that&rdquo;, [&lt;noway&gt;] denotes the optional parameter &ldquo;noway&rdquo;, and {val} denotes the suggested or default value &ldquo;val&rdquo;. Command line arguments are passed as <em>key=</em>&lt;value&gt;, where &ldquo;<em>key&rdquo; </em>is the key in the hash used to store the parameters. For example, the following instruction:</p>
        <p>&gt;&gt;&gt; <strong>program </strong><em>param</em>=&lt;what{20-40}&gt;<em> either</em>=&lt;this|that&gt; [<em>itisanumber</em>=&lt;noway{0}&gt;]</p>
        <p>can be executed like this:</p>
        <p>&gt;&gt;&gt; <strong>program </strong><em>param</em>=30<em> either</em>=this</p>
        <p>or like this:</p>
        <p>&gt;&gt;&gt; <strong>program </strong><em>param</em>=35<em> either</em>=that <em>itisanumber</em>=500</p>
        <p>The command line interface is similar to the interface used by the <em>proc2d</em> and <em>proc3d</em> programs in EMAN, so you should feel right at home if you are familiar with EMAN. You are encouraged to contact the author of this manual and bark at him if the instructions contain errors (e-mail: hael@stanford.edu). Each program prints a short version of the description presented here when executed without command line arguments.</p>
      </div>
    </div>
    <div class="AccordionPanel">
      <div class="AccordionPanelTab">Command line dictionary</div>
      <div class="AccordionPanelContent">
        <p>All command line variables with a short description can be found here:</p>
        <p><a href="documents/command_line_dictionary_simple2.pdf" target="_new">command_line_dictionary_simple2.pdf</a></p>
        <p><a href="documents/command_line_dictionary_simple2.docx" target="_new">command_line_dictionary_simple2.docx</a></p>
      </div>
    </div>
  </div> 
 
 
 
 <h2 class="h2_manual" align="left"> &nbsp; &nbsp;SIMPLE Utilities and Applications</h2>
 <p class=text >&nbsp; We divide the SIMPLE programs into two groups: utilities and applications. Utility software focuses on <em>how </em>the system infrastructure operates, providing functionality required for running the applications. Utility software is often rather technical and targeted at users with advanced knowledge about the system. This contrasts application software, which allows users to execute the higher-level functionalities that motivated the design of the system. To make most effective use of a system, it is often necessary to master both the utility and the application software. </p>
 <p class=text >&nbsp;</p>
 <p class="text"><span class="h2_manual">UTILITY PROGRAMS</span></p>


  <div id="Accordion2" class="Accordion" >
    
    <div class="AccordionPanel">
      <div class="AccordionPanelTab">simple_make_cavgs</div>
      <div class="AccordionPanelContent">
        <p><strong>&nbsp;</strong><strong>simple_make_cavgs </strong>is a program for making class averages given a stack of images and their alignment. Some people like to make class averages and compare them with projections of their volume in corresponding orientations. This program makes the class averages and the volume can be projected in the outputted orientations <em>cavgoris.txt </em>using <strong>simple_projvol</strong>, described below.</p>
<p><span class="h2_manual">Usage:<br>
</span> &gt;&gt;&gt; <strong>simple_make_cavgs</strong><em>stk</em>=stack.spi <em>box</em>=&lt;image size(in pixels)&gt; <em>smpd</em>=&lt;sampling distance(in A)&gt; <em>oritab</em>=&lt;alignment doc&gt; <em>nspace</em>=&lt;nr of class averages&gt; [<em>pgrp</em>=&lt;cn|dn&gt;]</p>
      </div>
    </div>
<div class="AccordionPanel">
      <div class="AccordionPanelTab"> simple_mkrndoris</div>
      <div class="AccordionPanelContent">
        <p>&nbsp;<strong>simple_mkrndoris</strong> is a program for making random alignments in various flavors.</p>
<p><span class="h2_manual">Usage:<br>
</span> &gt;&gt;&gt;<strong>simple_mkrndoris</strong><em> nptcls</em>=&lt;number of oris&gt;<em> outfile</em>=&lt;output alignment doc&gt;[<em>trs</em>=&lt;origin shift(in pixels){0}&gt;][<em>nstates</em>=&lt;nr of states{1}&gt;][<em>pgrp</em>=&lt;cn|dn&gt;][<em>even</em>=&lt;yes|no{no}&gt;][<em>zero</em>=&lt;yes|no{no}&gt;][<em>ndiscrete</em>=&lt;nr of discrete orientations&gt;]</p>
<p><span class="h2_manual">Comments:<br>
</span><em>nptcls </em>is the number of desired orientations, <em>outfile, </em>is the output file, <em>trs </em>is the one-sided size of the origin shift interval (2 means from -2 to +2), <em>nstates </em>is the number of states, <em>pgrp </em>is the point-group, if set to &lsquo;yes&rsquo; <em>even</em> will given you even projection directions and random in-plane parameters, with <em>ndiscrete </em>set the program will sample projection directions randomly from a  set of <em>ndiscrete </em>even ones and give you random in-plane parameters.</p>
</div>
    </div>
<div class="AccordionPanel">
      <div class="AccordionPanelTab">simple_npeaks</div>
      <div class="AccordionPanelContent">
        <p>&nbsp;<strong>simple_</strong><strong>_npeaks</strong> is a program for calculating the size of the feasible subset of orientations, used in <strong>simple_prime</strong>, described below. The number of feasible orientations per particle image (or the number of nonzero orientation weights) is determined based on the selected resolution limit, the molecular radius, and the resolution of the discrete 3D orientation search space. This program checks how many copies of the same image are added (with weights) to the reconstruction for a given set of input parameters.</p>
<p align="left"><span class="h2_manual">Usage:<br>
</span> &gt;&gt;&gt; <strong>simple_npeaks</strong> <em>box</em>=&lt;image size(in pixels)&gt; <em>smpd</em>=&lt;sampling distance(in A)&gt; [<em>nspace</em>=&lt;nr of projection directions&gt;] [<em>lp</em>=&lt;low-pass limit(A){20}&gt;] [<em>moldiam</em>= &lt;molecular diameter(A)&gt;] [<em>pgrp</em>=&lt;cn|dn{c1}&gt;]</p>
</div>
    </div>
<div class="AccordionPanel">
  <div class="AccordionPanelTab"> simple_nspace</div>
  <div class="AccordionPanelContent">
    <p>&nbsp;<strong>simple_nspace</strong> is a program for checking how many projection directions (reference images) that you need to get to a certain resolution with projection matching, given the molecular diameter as input. The number is slightly overestimated, because the in-plane rotations are sampled finer than the projection directions, so the finer in-plane sampling can compensate for limited angular resolution of the distribution of projection directions.</p>
    <p><span class="h2_manual">Usage:<br>
    </span>  &gt;&gt;&gt;<strong>simple_nspace </strong><em>moldiam</em>=&lt;molecular diameter (in A)&gt;</p>
  </div>
</div>
<div class="AccordionPanel">
  <div class="AccordionPanelTab">simple_projvol</div>
  <div class="AccordionPanelContent">
    <p><strong>simple_projvol</strong> is a program for projecting a 3D volume. Output is a spider stack of projection images.</p>
    <p align="left"><span class="h2_manual">Usage:<br>
    </span>  &gt;&gt;&gt;<strong>simple_projvol </strong><em>vol1</em>=invol.spi <em>box</em>=&lt;image size(in pixels)&gt; <em>smpd</em>=&lt;sampling distance(in A)&gt; [<em>nspace</em>=&lt;nr of projs&gt;] <em>outstk</em>=&lt;ouput spider stack&gt; [<em>oritab</em>=&lt;SIMPLE alignment doc&gt;]<br>
      <strong>** less commonly used**</strong> [<em>pgrp</em>=&lt;point group symmetry{c1}&gt;] [<em>gw</em>=&lt;window function halfwidth{0.5}&gt;] [<em>winsz</em>=&lt;hard window halfwidth{1}&gt;] [<em>wfun</em>=&lt;window function, gau|gau2|sinc|lin|{gau}&gt;] [<em>rnd</em>=&lt;yes|no{no}&gt;] [<em>space</em>=&lt;real|fourier{fourier}&gt;] [<em>msk</em>=&lt;mask radius (in pixels)&gt;]</p>
<p><span class="h2_manual">Comments:<br>
</span>The <em>oritab </em>parameter allows you to input the orientations that you wish to have your volume projected in, <em>gw </em>controls the half-width of the Gaussian (or other kernel) used for interpolation, <em>winsz, </em>is the hard window half-width, <em>wfun </em>controls the window function used (two Gaussian variants: gau, gau2, sinc function, or linear interpolation), <em>rnd </em>set to &lsquo;yes&rsquo; projects the volume in <em>nspace </em>random orientations, <em>space </em>controls the space used for interpolation (<em>real</em>: real-space projection or <em>fourier</em>: which extracts a central section from the Fourier volume and back transforms the 2D FT, which is MUCH faster), and finally, <em>msk </em>is used to control the radius within which the volume is projected if the <em>real </em>option is used.</p>
</div>
</div>
<div class="AccordionPanel">
  <div class="AccordionPanelTab">simple_recvol</div>
  <div class="AccordionPanelContent">
    <p><strong>simple_recvol </strong>is a program for reconstructing volumes from spider stacks (*.spi), given input orientations and state assignments (obtained by program <strong>simple_prime</strong>). The algorithm is based on direct Fourier inversion with a truncated Gaussian interpolation kernel. This window function reduces the real-space ripple artifacts associated with direct moving window sinc interpolation. The feature sought when implementing this algorithm was to enable quick, reliable reconstruction from aligned individual particle images.</p>
<p align="left"><span class="h2_manual">Usage:<br>
    </span>  &gt;&gt;&gt; <strong>simple_recvol </strong><em>stk</em>=projs.spi <em>box=&lt;</em>box size(in pixels)&gt; <em>smpd</em>=&lt;sampling distance(in A)&gt; <em>oritab</em>=algndoc.txt [<em>frac</em>=&lt;fraction of ptcls to include{1.}&gt;] [<em>eo</em>=&lt;yes|no&gt;] [<em>nthr</em>=&lt;nr of openMP threads{1}&gt;] <br>
    <strong>**less commonly used**</strong> [<em>mul</em>=&lt;shift multiplication factor{1}&gt;] [<em>pgrp</em>=&lt;cn|dn{c1}&gt;] [<em>part</em>=&lt;partition number&gt;] [<em>fromp</em>=&lt;start ptcl{1}&gt;] [<em>top</em>=&lt;stop ptcl{nptcls}&gt;] [<em>state</em>=&lt;state to reconstruct{all}&gt;]</p>
<p><span class="h2_manual">Comments:<br>
</span>      The optional parameter <em>eo </em>is used for generating even-odd reconstructions subjected to FSC analysis.</p>
  </div>
</div>
<div class="AccordionPanel">
  <div class="AccordionPanelTab">simple_volassemble</div>
  <div class="AccordionPanelContent">
    <p><strong>simple_volassemble </strong>is a program that assembles a volume when the reconstruction program (<strong>simple_recvol</strong>) has been executed in distributed mode.</p>
<p align="left"><span class="h2_manual">Usage:<br>
  </span>  &gt;&gt;&gt;<strong>simple_volassemble</strong> <em>npart</em>=&lt;number of partitions to assemble&gt; <em>nstates</em>=&lt;nr of states&gt; <em>box</em>=&lt;image size(in pixels)&gt; <em>smpd</em>=&lt;sampling distance(in A)&gt; [<em>nthr</em>=&lt;nr of openMP threads{1}&gt;] [<em>eo</em>=&lt;yes|no&gt;] [<em>lp</em>=&lt;low-pass limit{20}&gt;] [matched=&lt;yes|no{no}&gt;]</p>
    <p><span class="h2_manual">Comments:<br>
    </span><em>eo</em>=yes is used when even-odd pairs has been reconstructed with distributed <strong>simple_recvol</strong>, with <em>lp </em>set the assembled volume is low-pass filtered to the given resolution (used by <strong>distr_simple_prime.pl</strong>, described below)</p>
</div>
</div>
<div class="AccordionPanel">
  <div class="AccordionPanelTab"><a name="rndrec"></a>simple_rndrec</div>
  <div class="AccordionPanelContent">
    <p><strong>simple_rndrec</strong> is a program for generating random initial models. We use this program to provide starting models when executing <strong>simple_prime </strong>in distributed parallelization mode.</p>
    <p align="left"><span class="h2_manual">Usage:<br>
    </span>  &gt;&gt;&gt;<strong>simple_rndrec </strong>[<em>stk</em>=stack.spi] <em>box</em>=&lt;image size(in pixels)&gt; <em>smpd</em>=&lt;sampling distance(in A)&gt; [<em>nspace</em>=&lt;nr of reference sections{1000}&gt;] [<em>lp</em>=&lt;low-pass limit{20}&gt;] [<em>nstates</em>=&lt;nr of states{1}&gt;] [<em>nran</em>=&lt;size of random sample&gt;] [<em>nthr</em>=&lt;nr of OpenMP threads{1}&gt;]<br>
    <strong>**less commonly used**</strong> [<em>pgrp</em>=&lt;cn|dn&gt;] [<em>npeaks</em>=&lt;number of nonzero orientation weights{1}&gt;] [<em>noise</em>=&lt;yes|no&gt;]
    </p>
    <p><span class="h2_manual">Comments:<br>
    </span>Setting the <em>nstates </em>parameter &gt; 1 partitions the data randomly into discrete state groups and calculates one blob per group. If the data set is large (&gt;5000 images), generating a random model can be quite slow. To speedup, set <em>nran </em>to some smaller number, resulting in <em>nran </em>images selected randomly for reconstruction. If you want to override the automatically determined feasible region size (the number of nonzero orientation weights per image) you can set <em>npeaks </em>to any number that you wish. If you set <em>noise </em>equal to yes, the program will produce a pure noise volume (which works equally well for initialization of <strong>simple_prime</strong>).</p>
</div>
</div>

<div class="AccordionPanel">
  <div class="AccordionPanelTab">simple_automask</div>
  <div class="AccordionPanelContent">
    <p><strong>simple_automask</strong> is a program for solvent flattening of a spider volume. The algorithm for background removal is based on low-pass filtering and binarization. First, the volume is low-pass filtered to <em>amsklp</em>. A binary volume is then generated by assigning foreground pixels (=1) based on the volume calculated from the molecular weight, assuming a protein density of 1.43 g/mL. A real-space low-pass filter softens the edge of the resulting binary volume before multiplying it with the &lsquo;raw&rsquo; input volume to generate the flattened map.</p>
<p><span class="h2_manual">Usage:<br>
  </span>  &gt;&gt;&gt;<strong>simple_automask</strong><em>vol1</em>=invol1.spi [<em>vol2</em>=invol2.spi etc.] <em>box=&lt;</em>box size(in pixels)&gt; <em>smpd=</em>&lt;sampling distance(in Å)&gt; <em>mw</em>=&lt;molecular weight(in kD)&gt; [<em>amsklp=</em>&lt;low-pass limit(in Å){40}&gt;]<br>
  <strong>**less commonly used**</strong> [<em>edge</em>=&lt;edge size for softening of the molecular envelope(in pixels)&gt;]</p>
</div>
</div>
<div class="AccordionPanel">
  <div class="AccordionPanelTab">simple_stackops</div>
  <div class="AccordionPanelContent">
    <p><strong><a name="stkops"></a>simple_stackops</strong> is a program that provides standard single-particle image processing routines that are applied to spider stacks.</p>
    <p align="left"><span class="h2_manual">Usage:<br>
    </span>  &gt;&gt;&gt;<strong>simple_stackops </strong></p>
    <p>[<em>stk</em>=stack.spi] [<em>stk2</em>=stack2.spi] <em>box</em>=&lt;image size(in pixels)&gt; <em>smpd</em>=&lt;sampling distance(in A)&gt; <em>outstk</em>=&lt;output_imgs.spi&gt; [<em>nthr</em>=&lt;nr of openMP threads{1}&gt;] [<em>oritab</em>=&lt;SIMPLE alignment doc&gt;] [<em>hp</em>=&lt;high-pass limit(in A)&gt;] [<em>lp</em>=&lt;low-pass limit(in A)&gt;] [<em>shalgn</em>=&lt;yes|no{no}&gt;] [<em>mul</em>=&lt;shift multiplication factor{1}&gt;] [<em>trs</em>=&lt;origin shift(in pixels)&gt;] [<em>roalgn</em>=&lt;yes|no{no}&gt;] [<em>ring1</em>=&lt;inner mask radius(in pixels){1}&gt;] [<em>ring2</em>=&lt;outer mask radius(in pixels){<em>box</em>/2}&gt;] [<em>state</em>=&lt;state to extract&gt;] [<em>frac</em>=&lt;fraction of ptcls to extract{1}&gt;] [<em>snr</em>=&lt;signal2noise ratio&gt;] [<em>msk</em>=&lt;mask radius(in pixels){box/2}&gt;] [<em>bin</em>=&lt;binarize{no}&gt;] [<em>acf</em>=&lt;yes|no{no}&gt;] [<em>phrand</em>=&lt;yes|no{no}&gt;] [<em>fromp</em>=&lt;start ptcl&gt;] [<em>top</em>=&lt;stop ptcl&gt;] [<em>nran</em>=&lt;number of random images to select&gt;] [<em>newbox</em>=&lt;scaled box&gt;] [<em>norm</em>=&lt;yes|no{no}&gt;] [<em>tres</em>=&lt;binary treshold{0}&gt;] [<em>rnd</em>=&lt;yes|no{no}&gt;]</p>
<p><span class="h2_manual">Comments:<br>
</span>You can do many things with <strong>simple_stackops</strong>. Filtering is controlled by the <em>hp </em>and <em>lp </em>arguments. Two kinds of alignments are available: shift alignment and rotational alignment. If you input an alignment document (<em>oritab</em>) <em>shalgn</em>=yeswill produce a shift aligned stack based on the inputted orientations, whereas if you do not input an alignment document the alignment will be done in a reference-free manner (remember to set <em>trs </em>to some nonzero value). <em>roalgn</em>=yes behaves in the same way, but note that if an alignment document is provided <em>roalgn</em>=yes will both shift and rotate the stack. The <em>ring </em>parameters control the inner and outer mask radius for the polar image representation used for rotational alignment. If you want to extract a particular state, give an alignment document (<em>oritab</em>) and set <em>state </em>to the state that you want to extract. If you want to select the fraction of best particles (according to the goal function), input an alignment doc (<em>oritab</em>) and set <em>frac </em>[0,1]. You can combine the <em>state </em>and <em>frac </em>options. If you want to apply noise to images, give the desired signal-to-noise ratio via <em>snr. </em>If you want to mask your images with a spherical mask with a soft falloff, set <em>msk </em>to the radius in pixels. If you want to binarize your images, set <em>bin</em>=yes. If you want to calculate the autocorrelation function of your images set <em>acf</em>=yes. If you want to randomize the phases of the Fourier transforms of your images, set <em>phrand</em>=yes and <em>lp </em>to the desired low-pass limit. If you want to extract a contiguous subset of particle images from the stack, set <em>fromp </em>and <em>top. </em>If you want to fish out a number of particle images from your stack at random, set <em>nran </em>to some nonzero number &lt; <em>nptcls</em>. If you want to resize you images, set the desired box <em>newbox </em>&lt; <em>box. </em>If you want to normalize your images, set <em>norm</em>=yes. If you want to use the threshold option for binarization (instead of k-means clustering), set <em>tres </em>[0,1]. If you want to generate 100 random images, set <em>rnd</em>=yes and <em>nptcls</em>=100.</p>
</div>
</div>
<div class="AccordionPanel">
  <div class="AccordionPanelTab">simple_volops</div>
  <div class="AccordionPanelContent">
    <p><strong>simple_volops</strong> is a program that provides standard single-particle image processing routines that are applied to spider volumes.</p>
    <p align="left"><span class="h2_manual">Usage:<br>
    </span>  &gt;&gt;&gt;<strong>simple_volops</strong><em> vol1</em>=invol.spi [<em>vol2</em>=invol2.spi] <em>box</em>=&lt;image size(in pixels)&gt; <em>smpd</em>=&lt;sampling distance(in A)&gt; [<em>outvol</em>=&lt;outvol.spi&gt;] [<em>winsz</em>=&lt;convolutional window size&gt;] [<em>stepsz</em>=&lt;convolutional stepsize{1}&gt;] [<em>nthr</em>=&lt;nr of openMP threads{1}&gt;] [<em>phrand</em>=&lt;yes|no{no}&gt;] [<em>msk</em>=&lt;mask radius(in pixels)&gt;] [<em>lp</em>=&lt;low-pass limit{20}&gt;] [<em>snr</em>=&lt;signal-to-noise ratio&gt;] [<em>oritab</em>=&lt;previous rounds alignment doc&gt;] [<em>center</em>=&lt;yes|no{no}&gt;]</p>
    <p><span class="h2_manual">Comments:<br>
    </span>      <em>center</em>=yes centers the inputted volume (<em>vol1</em>) (remember to give an output volume filename <em>outvol</em>) by lowpass filtering <em>vol1 </em>to <em>lp, </em>using k-means to separate foreground pixels from background pixels, determining the center of mass, and shifting the inputted volume accordingly. <em>phrand</em>=yes randomizes the phases of the FT of <em>vol1 </em>from resolution <em>lp. </em>If two volumes are inputted, the <em>FSC </em>is calculated and the resolution at both <em>FSC</em>=0.5 and <em>FSC</em>=0.143 is printed to STDOUT. If you give a signal-to-noise ratio via <em>snr, </em>noise is applied to the input volume accordingly. If defined, <em>winsz </em>will result in denoising of <em>vol1 </em>by convolutional principal component analysis. <em>lp </em>is for low-pass filtering. The <em>msk </em>parameter (radius of the mask) is used by both the centering routine and the <em>snr </em>option.</p>
  </div>
</div>
<div class="AccordionPanel">
  <div class="AccordionPanelTab">simple_unit_tests</div>
  <div class="AccordionPanelContent">
    <p><strong>simple_unit_tests</strong> is a program that executes all the module unit tests in the library. Since we are using test-driven development we have unit tests associated with many of the classes. This program tests:</p>
    <p>simple_defs<br>
      enfors_ftiter<br>
      simple_ori<br>
      enfors_image<br>
      simple_oris<br>
      enfors_spider<br>
      simple_polarimg<br>
      simple_roalgn<br>
      simple_shalgn<br>
      simple_hac<br>
      simple_kmeans<br>
      simple_sa_opt<br>
      simple_align_pair<br>
      simple_convol_imgs<br>
      simple_args</p>
    <p><span class="h2_manual">Usage:<br>
    </span>  &gt;&gt;&gt;<strong>simple_unit_tests</strong></p>
  </div>
</div>
  </div>


<p class="text">&nbsp;</p>
<p class="text"><span class="h2_manual">APPLICATION PROGRAMS</span></p>



<div id="Accordion3" class="Accordion" >
  <div class="AccordionPanel">
    <div class="AccordionPanelTab">simple_cluster</div>
    <div class="AccordionPanelContent">
      <p><strong>simple_cluster</strong> is a program for image clustering based on reference-free in-plane alignment (Penczek et al., 1992) and probabilistic principal component analysis (PCA) for generation of feature vectors (Tipping and Bishop, 1999). Agglomerative hierarchical clustering (HAC) is used for grouping of feature vectors (Murtagh, 1983). Refinement of the clustering solution is done with the center-based k-means clustering.<strong> simple_cluster </strong>in-plane<strong> </strong>aligns the input image stack. Bicubic interpolation is used for shifting and rotating the stack before extraction of the pixels within the circular mask defined by mask radius <em>msk</em>. Next, the probabilistic PCA method generates feature vectors from the vectors of extracted pixels. The minimum cluster population (<em>minp</em>) prevents clusters below population <em>minp </em>to be represented by an output average.</p>
      <p align="left"><span class="h2_manual">Usage:<br>
      </span>  &gt;&gt;&gt;<strong>simple_cluster</strong> <em>stk</em>=stack.spi <em>box=&lt;</em>box size(in pixels)&gt; <em>smpd=</em>&lt;sampling distance(in &#8491;)&gt; [<em>msk</em>=&lt;mask radius(in pixels){box/2}&gt;] [<em>ncls</em>=&lt;nr clusters{500}&gt;] [<em>minp</em>=&lt;minimum nr ptcls cluster{10}&gt;] [<em>nran</em>=&lt;size of random sample{nptcls}&gt;] [<em>oritab</em>=&lt;SIMPLE alignment doc&gt;] [<em>nthr</em>=&lt;nr openMP threads{1}&gt;]<br>
        <strong>**less commonly used**</strong> [<em>nvars</em>=&lt;nr eigenvectors{30/60}&gt;] [<em>clsdoc</em>=&lt;Spider clustering doc&gt;] [<em>kmeans</em>=&lt;yes|no{yes}&gt;] [<em>dopca</em>=&lt;yes|no] [<em>doalign</em>=&lt;yes|no{no}&gt;] [<em>rnd</em>=&lt;yes|no{no}&gt;] [utst=&lt;unit test nr(1-4){0}&gt;]</p>
<p><span class="h2_manual">Comments:<br>
</span>The setup allows for quick testing of the number of clusters. One pass produces the file &lsquo;pdfile.bin&rsquo; containing the matrix of all pair-wise feature vector distances. Using the optional parameter <em>dopca</em> set to &lsquo;no&rsquo; in a second round of execution from the same directory will make the program read the previously generated distances and re-do the clustering using whatever settings inputted for parameters <em>ncls </em>&amp; <em>minp</em>. The optional parameter <em>oritab </em>is used to provide in-plane parameters for the clustering (provided by program <strong>simple_prime</strong>, described below). This option is used for generating class averages that are going to be subjected to heterogeneity. The default setting uses 30 eigenvectors if you are not inputting in-plane parameters via optional parameter <em>oritab, </em>and 60 eigenvectors if you do input in-plane parameters. Note that the distance matrix is kept in RAM, so for large data sets you need LOTS of internal memory. This quirk can be addressed by using a random sample of the data for initial clustering by HAC. This is done by setting <em>nran</em> to some number &lt; <em>nptcls</em>. In this setting, the HAC centers generated from the random sample are used to extend the clustering to the entire data set with k-means. This overcomes the well-known initialization problem of k-means and enables clustering of many hundreds of thousands of particle images. SIMPLE has been used to cluster 300,000 images with a box size of 100 using a random subset of 60,000 images on a machine with 96 GB RAM.</p>
</div>
  </div>
  <div class="AccordionPanel">
    <div class="AccordionPanelTab"><a name="prime"></a>simple_prime</div>
    <div class="AccordionPanelContent">
      <p><strong>&nbsp;</strong><strong>simple_prime</strong> is an <em>ab inito </em>reconstruction/low-resolution refinement program based on probabilistic projection matching. <strong>PRIME</strong> stands for <strong>PR</strong>obabilistic <strong>I</strong>nitial 3D <strong>M</strong>odel Generation for Single-Particle Cryo-<strong>E</strong>lectron Microscopy. There should be no impediment to using <strong>PRIME</strong> also for high-resolution refinement and reconstruction of discrete state groups. We are currently playing around a lot with the <strong>PRIME</strong> algorithm to understand it better and to find the right combination of goal function and weighting scheme for the different problems that we want to apply it to. In the end of this year (2013) we plan to release a new SIMPLE version that will implement heterogeneity analysis with <strong>PRIME</strong>. The code can, as it stands, be used for <em>ab initio </em>3D reconstruction by initialization with a random starting model (generated automatically if no volume is inputted or by program <strong>simple_rndrec</strong>, described above). There are many ways of using (and probably also abusing) <strong>simple_prime</strong>. We will walk you through a few examples (see <strong>Using simple_prime, </strong>below). For data sets of realistic size you would not execute <strong>simple_prime </strong>in the shared-memory parallelization setting described here, but use <strong>distr_simple_prime.pl</strong>, described below.</p>
      <p>For a brief tutorial go to <a href="workflow.html" target="_new">workflow</a>.</p>
      <p align="left"><span class="h2_manual">Usage:<br>
      </span>  &gt;&gt;&gt;<strong>simple_prime </strong><em>stk</em>=stack.spi [<em>vol1</em>=invol.spi] [<em>vol2</em>=&lt;refvol_2.spi&gt; etc.] <em>box</em>=&lt;image size(in pixels)&gt; <em>smpd</em>=&lt;sampling distance(in A)&gt; [<em>ring2</em>=&lt;outer mask radius(in pixels){box/2}&gt;] [<em>trs</em>=&lt;origin shift(in pixels){0}&gt;] [<em>trsstep</em>=&lt;origin shift stepsize{1}&gt;] [<em>lp</em>=&lt;low-pass limit{20}&gt;] [<em>dynlp</em>=&lt;yes|no{no}&gt;] [<em>nstates</em>=nstates to reconstruct&gt;] [<em>frac</em>=&lt;fraction of ptcls to include{1}&gt;] [<em>mw</em>=&lt;molecular weight (in kD)&gt;] [<em>oritab</em>=&lt;previous rounds alignment doc&gt;] [<em>nthr</em>=&lt;nr of OpenMP threads{1}&gt;]<br>
         <strong>**less commonly used**</strong> [<em>nspace</em>=&lt;nr of reference sections{1000}&gt;] [<em>amsklp</em>=&lt;automask low-pass limit(in A){40}&gt;] [<em>maxits</em>=&lt;nr of iterations{50}&gt;] [<em>pgrp</em>=&lt;cn|dn{c1}&gt;] [<em>ring1</em>=&lt;inner mask radius(in pixels){1}&gt;] [<em>edge</em>=&lt;edge size for softening molecular envelope(in pixels){3}&gt;] [<em>tau</em>=&lt;for sharpening the weight distribution(0.05-1){1}&gt;] [<em>find</em>=&lt;Fourier index&gt;] [<em>fstep</em>=&lt;Fourier step size&gt;] [<em>local</em>=&lt;yes|no{no}&gt;] [<em>deterministic</em>=&lt;yes|no{no}&gt;] [<em>noise</em>=&lt;yes|no&gt;] [<em>time_per_image</em>=&lt;{60}&gt;] [<em>lphigh</em>=&lt;stay at this low-pass limit(in A)&gt;]</p>
<p><span class="h2_manual">Comments:<br>
  </span>        You could in principle get away with a command like </p>
      <p>&gt;&gt;&gt;<strong>simple_prime</strong> <em>stk</em>=stack.spi <em>box</em>=100 <em>smpd</em>=2.33</p>
      <p>Note that the first round of prime should always be run with dynamic resolution stepping (<em>dynlp</em>=yes) whereas later runs can be executed with (<em>lp</em>=x) for low-pass limit in &#8491; or without any lp-argument, in which case a Wiener filter will be used (the Wiener filter is presently buggy, we are working on it). Since the search is probabilistic, we figured that an elegant convergence criterion could be formulated based on the variance of the distribution of orientations assigned to each image. This works well for asymmetrical reconstructions, but for symmetrical reconstructions the variance increases towards the end of the run when the shape most consistent with the point group is being established. Note that we do not assume any point-group symmetry in the initial runs. However, the <strong>simple_symsrch </strong>program (described below) can be used to align the reconstruction to its symmetry axis so that the search can be restricted to the asymmetric unit in refinement. We have not characterized the algorithm for super high-resolution reconstruction; our primary focus has been <em>ab initio </em>reconstruction. The code is being benchmarked on data sets known to refine to high resolution. Less commonly used and less obvious input parameters are <em>nspace</em>, which controls the number of reference projections, <em>amsklp, </em>which controls the low-pass limit used in the automask routine, <em>maxits, </em>which controls the maximum number of iterations executed, <em>pgrp, </em>which controls the point-group symmetry, assuming that the starting volume is aligned to its principal symmetry axis, <em>ring1, </em>which controls the inner mask radius in the polar image representation, <em>edge, </em>which controls the size of the softening edge in the automask routine. <em>local</em>=yes indicates that the search should be local around the previous best orientation, intended for higher-resolution refinement using a larger number of reference projections, say 10,000 (experimental), <em>deterministic, </em>which removes the stochastic component of the search and evaluates the entire neighborhood in every round (experimental), <em>noise, </em>which produces a random noise starting volume instead of a random blob if no input volume is given.</p>
</div>
  </div>
  
  <div class="AccordionPanel">
      <div class="AccordionPanelTab">simple_make_cavgs</div>
      <div class="AccordionPanelContent">
        <p><strong>&nbsp;</strong><strong>simple_make_cavgs</strong> is a program for making class averages given a stack of images and their alignment. Some people like to make class averages and compare them with projections of their volume in corresponding orientations. This program makes the class averages and the volume can be projected in the outputted orientations <em>cavgoris.txt </em>using <strong>simple_projvol</strong>, described below.</p>
<p><span class="h2_manual">Usage:<br>
</span> &gt;&gt;&gt; <strong>simple_make_cavgs</strong><em>stk</em>=stack.spi <em>box</em>=&lt;image size(in pixels)&gt; <em>smpd</em>=&lt;sampling distance(in A)&gt; <em>oritab</em>=&lt;alignment doc&gt; <em>nspace</em>=&lt;nr of class averages&gt; [<em>pgrp</em>=&lt;cn|dn&gt;]</p>
      </div>
    </div>
<div class="AccordionPanel">
      <div class="AccordionPanelTab"> simple_symsrch</div>
      <div class="AccordionPanelContent">
        <p>&nbsp;<strong>simple_</strong><strong>symsrch</strong> is a program for searching for the principal symmetry axis of a volume reconstructed without assuming any point-group symmetry. Our philosophy is to start off without assuming any symmetry and analyze the reconstructed volume to identify the correct point-group symmetry. <strong>Simple_symsrch </strong>can be used for this purpose. The program takes as input the asymmetrical reconstruction (obtained with <strong>simple_prime</strong>, described above), the alignment document for all the particle images that have gone into the reconstruction, and the desired point-group symmetry. It then projects the reconstruction in 20 quasi-even directions, applies common lines-based optimization to identify the principal symmetry axis, and applies the rotational transformation to the inputted orientations, and produces a new alignment document. Input this document to <strong>simple_recvol </strong>together with the images and the point-group symmetry to generate a symmetrized map. If you are unsure about the point-group, you can of course test many different point-groups and formulate a statistical test that compares the asymmetric map with the symmetrized maps for different point-groups.</p>
<p><span class="h2_manual">Usage:<br>
</span> &gt;&gt;&gt;<strong>simple_symsrch</strong> <em>vol1</em>=invol.spi <em>box</em>=&lt;image size(in pixels)&gt; <em>smpd</em>=&lt;sampling distance(in A)&gt; <em>oritab</em>=&lt;previous rounds alignment doc&gt; <em>pgrp</em>=&lt;cn|dn{c1}&gt; <em>outfile</em>=&lt;output alignment doc&gt; [<em>lp</em>=&lt;low-pass limit{20}&gt;] [<em>nthr</em>=&lt;nr of OpenMP threads{1}&gt;]<br>
<strong>**less commonly used**</strong> [<em>state</em>=&lt;state 2 rotate&gt;</div>
    </div>
  
</div>

<h2 class="h2_manual" align="left"> &nbsp; &nbsp;Distributed SIMPLE 2.0 distribution</h2>


<div id="Accordion4" class="Accordion" >

  <div class="AccordionPanel">
    <div class="AccordionPanelTab">distr_simple_prime.pl</div>
    <div class="AccordionPanelContent">
      <p><strong>distr_simple_prime.pl</strong> distributes <strong>simple_prime </strong>on multicore workstations or clusters. The program requires two environment variables to be set: SIMPLEBIN and SIMPLESYS. You should have set these variables when installing simple (see Installation of SIMPLE, above). We use SIMPLESYS=BIOX3 for our cluster executions. BIOX3 is a cluster that uses the portable batch system (PBS) for job scheduling. If you are using PBS, there is a chance that the distributed execution will work painlessly, but there is no insurance (because there are many different versions of the PBS). The code that takes care of the job distribution is, however, extremely simple and you need only to modify the exec_prime_para subroutine in the &lt;whatever folder&gt;/simple/apps/distr_simple_prime.pl script. <strong>Distr_simple_prime.pl </strong>accepts the same arguments as <strong>simple_prime </strong>with the exception that <em>nthr </em>(the number of OpenMP threads) have been replaced with <em>npart </em>(number of partitions). Checkout the workflow on the SIMPLE website for links to tutorials that describe the exact execution routes. The distributed prime version is executed as nohup distr_simple_prime.pl &lt;command line args&gt; &gt; PRIME_OUT &amp; and progress is monitored by tail -50f PRIME_OUT</p>
</div>
  </div>
  
  <div class="AccordionPanel">
    <div class="AccordionPanelTab">distr_simple.pl</div>
     <div class="AccordionPanelContent">
        <p><strong>Distr_simple.pl</strong> distributes any SIMPLE program that accepts the command line arguments <em>fromp, top, </em>and <em>part. </em>We are using it exclusively for volume reconstruction when the data sets are large. A strategy that we have found useful is to do deterministic reconstruction from the most likely converged orientations obtained by <strong>simple_prime. </strong>This is done, for example, by</p>
<p><span class="h2_manual">Usage:<br>
  </span> &gt;&gt;&gt;<strong>distr_simple.pl</strong> <em>prg</em>=simple_recvol <em>stk</em>=ptcls.spi <em>box</em>=100 <em>smpd</em>=2.33 <em>oritab</em>=merged.txt <em>npart</em>=100
<p>which splits the reconstruction job into 100 partitions, generating 200 output files containing Fourier and interpolation kernel matrices. The <em>merged.txt </em>file is the merged orientation file from distributed <strong>simple_prime </strong>exection. The reconstruction is assembled by
&gt;&gt;&gt; <strong>simple_volassemble</strong> <em>npart</em>=100 <em>nstates</em>=1 <em>box</em>=100 <em>smpd</em>=2.33 <em>nthr</em>=4 </div>
    </div> 
</div>




<h2 class="h2_manual" align="left"> &nbsp; &nbsp;Heterogeneity analysis</h2>

<p class="text"> &nbsp;   coming soon </p>
  


<h2 class="h2_manual" align="left"> &nbsp; &nbsp;Distributed SIMPLE 2.0 distribution</h2>

<p class="text"> &nbsp;   coming soon </p>
  


  <h2 class="h2_manual" align="center"><a href="#top">top</a></h2>
  <p class="text">
 </p>
</div>


<script type="text/javascript">
var Accordion1 = new Spry.Widget.Accordion("Accordion1", { useFixedPanelHeights: false, defaultPanel: -1 });
</script>
<script type="text/javascript">
var Accordion2 = new Spry.Widget.Accordion("Accordion2", { useFixedPanelHeights: false, defaultPanel: -1 });
</script>
<script type="text/javascript">
var Accordion3 = new Spry.Widget.Accordion("Accordion3", { useFixedPanelHeights: false, defaultPanel: -1 });
</script>
<script type="text/javascript">
var Accordion4 = new Spry.Widget.Accordion("Accordion4", { useFixedPanelHeights: false, defaultPanel: -1 });
</script>

<!-- InstanceEndEditable -->
<h1>&nbsp;</h1>
<script type="text/javascript">
var MenuBar1 = new Spry.Widget.MenuBar("MenuBar1", {imgDown:"SpryAssets/SpryMenuBarDownHover.gif", imgRight:"SpryAssets/SpryMenuBarRightHover.gif"});
</script>
</body>
<!-- InstanceEnd --></html>
