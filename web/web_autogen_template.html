************SIMPLE_AUTOMASK************

<div class="AccordionPanel">
  <div class="AccordionPanelTab">simple_automask</div>
  <div class="AccordionPanelContent">
    <p><strong>simple_automask</strong> is a program for solvent flattening of a volume (MRC or SPIDER). The algorithm for background removal is based on low-pass filtering and binarization. First, the volume is low-pass filtered to <em>amsklp</em>. A binary volume is then generated by assigning foreground pixels (=1) based on the volume calculated from the molecular weight, assuming a protein density of 1.43 g/mL. A real-space low-pass filter softens the edge of the resulting binary volume before multiplying it with the unmasked input volume to generate the flattened map.</p>
    <p align="left"><span class="h2_manual">Usage:<br>
 </span> &gt;&gt;&gt;<strong>simple_automask </strong><em>vol1</em>=&lt;invol.ext&gt; [<em>vol2</em>=&lt;invol2.ext&gt; etc.] <em>smpd</em>=&lt;sampling distance(in A)&gt; [<em>mw</em>=&lt;molecular weight(in kD)&gt;] [<em>amsklp</em>=&lt;low-pass limit(in A){20}&gt;] [<em>nthr</em>=&lt;nr of OpenMP threads{1}&gt;]<br>

    <strong>** less commonly used**</strong> [<em>edge</em>=&lt;edge size for softening molecular envelope(in pixels){3}&gt;]</p>
</div>
</div>


************SIMPLE_CONVERTER************

<div class="AccordionPanel">
  <div class="AccordionPanelTab">simple_converter</div>
  <div class="AccordionPanelContent">
    <p><strong>simple_converter</strong> is a program for converting between SPIDER and MRC formats.</p>
    <p align="left"><span class="h2_manual">Usage:<br>
 </span> &gt;&gt;&gt;<strong>simple_converter </strong>[<em>stk</em>=&lt;input particle stack&gt;] [<em>vol1</em>=&lt;invol.ext&gt;] [<em>outstk</em>=&lt;output particle stack&gt;] [<em>outvol</em>=&lt;outvol.ext&gt;]<br></p>
</div>
</div>


************SIMPLE_DOC2CAVGS************

<div class="AccordionPanel">
  <div class="AccordionPanelTab">simple_doc2cavgs</div>
  <div class="AccordionPanelContent">
    <p><strong>simple_doc2cavgs</strong> is a program for generating class averages. We use it to to re-generate class averages when <em>simple_prime2D</em> has been run on downscaled images. If the images processed with PRIME2D were downscaled from 200x200 to 100x00, set <em>mul=2</em>.</p>
    <p align="left"><span class="h2_manual">Usage:<br>
 </span> &gt;&gt;&gt;<strong>simple_doc2cavgs </strong><em>stk</em>=&lt;stack.ext&gt; <em>smpd</em>=&lt;sampling distance(in A)&gt; <em>msk</em>=&lt;mask radius(in pixels)&gt; <em>ncls</em>=&lt;nr of clusters&gt; <em>oritab</em>=&lt;previous clustering doc&gt; <em>which_iter</em>=&lt;iteration nr&gt; [<em>mul</em>=&lt;shift multiplication factor{1}&gt;] [<em>nthr</em>=&lt;nr of OpenMP threads{1}&gt;]<br></p>
<p><span class="h2_manual">Comments:<br>
</span> The program assumes that the images have been phase-flipped, as no CTF correction by Wiener restoration is implemented yet.</p>
</div>
</div>


************SIMPLE_EO_RECVOL************

<div class="AccordionPanel">
  <div class="AccordionPanelTab">simple_eo_recvol</div>
  <div class="AccordionPanelContent">
    <p><strong>simple_eo_recvol</strong> is a program for reconstructing volumes from MRC or SPIDER stacks, given input orientations and state assignments (obtained by program <em>simple_prime3D</em>). The algorithm is based on direct Fourier inversion with a Kaiser-Bessel (KB) interpolation kernel. This window function reduces the real-space ripple artefacts associated with direct moving windowed-sinc interpolation. The feature sought when implementing this algorithm was to enable quick, reliable reconstruction from aligned individual particle images. The even and odd pairs are automatically reconstructed, the FSC calculated, and the Wiener filter formalism used for image restoration (CTF correction). Use <em>distr_simple.pl</em> for distributed execution.</p>
    <p align="left"><span class="h2_manual">Usage:<br>
 </span> &gt;&gt;&gt;<strong>simple_eo_recvol </strong><em>stk</em>=&lt;ptcls.ext&gt; <em>msk</em>=&lt;mask radius(in pixels)&gt; <em>smpd</em>=&lt;sampling distance(in A)&gt; <em>oritab</em>=&lt;algndoc.txt&gt; [<em>frac</em>=&lt;fraction ptcls to include{1.}&gt;] [<em>nthr</em>=&lt;nr openMP threads{1}&gt;] [<em>pgrp</em>=&lt;cn|dn|t|o|i{c1}&gt;]<br>

    <strong>** less commonly used**</strong> [<em>mul</em>=&lt;shift multiplication factor{1}&gt;] [<em>ctf</em>=&lt;yes|no|flip|mul{no}&gt;] [<em>kv</em>=&lt;acceleration voltage(in kV){300.}&gt;] [<em>fraca</em>=&lt;frac amp contrast{0.07}&gt;] [<em>cs</em>=&lt;spherical aberration constant(in mm){2.7}&gt;] [<em>deftab</em>=&lt;text file defocus values&gt;] [<em>state</em>=&lt;state to reconstruct{all}&gt;] [<em>mw</em>=&lt;molecular weight(in kD)&gt;] [<em>amsklp</em>=&lt;low-pass limit(in A){20}&gt;] [<em>edge</em>=&lt;edge size softening molecular envelope(in pixels){3}&gt;] [<em>inner</em>=&lt;inner mask radius(in pixels)&gt;] [<em>width</em>=&lt;pixels falloff inner mask{10}&gt;]</p>
<p><span class="h2_manual">Comments:<br>
</span> <em>mul</em> is used to scale the origin shifts if down-sampled images were used for alignment and the original images are used for reconstruction. <em>ctf</em>, <em>kv</em>, <em>fraca</em>, <em>cs</em> and <em>deftab</em> are used to communicate CTF information to the program. <em>ctf=yes</em>, <em>ctf=flip</em> or <em>ctf=mul</em> turns on the Wiener restoration. If you input CTF info to the program, please ensure that the correct kV, Cs and fraca (fraction of amplitude contrast) parameters are inputted as well. If the images were pre-multiplied with the CTF, set <em>ctf=mul</em> or if the images were phase-flipped set <em>ctf=flip</em>. <em>amsklp</em> and <em>mw</em> parameters control the solvent mask: the low-pass limit used to generate the envelope; the molecular weight of the molecule (protein assumed but it works reasonably well also for RNA; slight modification of <em>mw</em> might be needed). The <em>inner</em> parameter controls the radius of the soft-edged mask used to remove the unordered DNA/RNA core of spherical icosahedral viruses.</p>
</div>
</div>


************SIMPLE_IMINFO************

<div class="AccordionPanel">
  <div class="AccordionPanelTab">simple_iminfo</div>
  <div class="AccordionPanelContent">
    <p><strong>simple_iminfo</strong> is a program for printing header information in MRC and SPIDER stacks and volumes</p>
    <p align="left"><span class="h2_manual">Usage:<br>
 </span> &gt;&gt;&gt;<strong>simple_iminfo </strong>[<em>fname</em>=&lt;filename.ext&gt;] [<em>box</em>=&lt;box size(pixels)&gt;] [<em>smpd</em>=&lt;sampling distance(in A)&gt;] [<em>stats</em>=&lt;yes|no|print{no}&gt;]<br></p>
</div>
</div>


************SIMPLE_MAP2PTCLS************

<div class="AccordionPanel">
  <div class="AccordionPanelTab">simple_map2ptcls</div>
  <div class="AccordionPanelContent">
    <p><strong>simple_map2ptcls</strong> is a program for mapping parameters that have been obtained using class averages to the individual particle images. There are many functionalities present that will become critical in future releases. Right now we recommend using this program exclusively to exclude the particles corresponding to deselected class averages. See the workflows section of the manual for further info.</p>
    <p align="left"><span class="h2_manual">Usage:<br>
 </span> &gt;&gt;&gt;<strong>simple_map2ptcls </strong><em>stk</em>=&lt;particles.ext&gt; <em>stk2</em>=&lt;selected_cavgs.ext&gt; <em>stk3</em>=&lt;orig_cavgs.ext&gt; <em>oritab</em>=&lt;PRIME 2D doc&gt; [<em>oritab2</em>=&lt;prime3D shc doc&gt;] [<em>comlindoc</em>=&lt;shc_clustering_nclsX.txt&gt;] [<em>doclist</em>=&lt;list of oritabs for the different states&gt;] [<em>deftab</em>=&lt;text file defocus values&gt;] [<em>outfile</em>=&lt;output parameter file{mapped_ptcls_params.txt}&gt;] [<em>nthr</em>=&lt;nr of OpenMP threads{1}&gt;]<br></p>
</div>
</div>


************SIMPLE_PRIME2D************

<div class="AccordionPanel">
  <div class="AccordionPanelTab">simple_prime2d</div>
  <div class="AccordionPanelContent">
    <p><strong>simple_prime2d</strong> is a reference-free 2D alignment/clustering algorithm adopted from the prime3D probabilistic ab initio 3D reconstruction algorithm. It is assumed that the images are phase-flipped (phase flipping can be done with <em>simple_stackops</em>). Do not search the origin shifts initially, when the cluster centers are of low quality. If your images are far off centre, use <em>simple_stackops</em> with option <em>shalgn=yes</em> instead to shiftalign the images beforehand (the algorithm implemented is the same as EMAN's <em>cenalignint</em> program). Use <em>distr_simple.pl</em> for distributed PRIME2D execution.</p>
    <p align="left"><span class="h2_manual">Usage:<br>
 </span> &gt;&gt;&gt;<strong>simple_prime2d </strong><em>stk</em>=&lt;stack.ext&gt; <em>smpd</em>=&lt;sampling distance(in A)&gt; <em>msk</em>=&lt;mask radius(in pixels)&gt; <em>ncls</em>=&lt;nr of clusters&gt; <em>refs</em>=&lt;initial_references.ext&gt; <em>oritab</em>=&lt;previous clustering doc&gt; [<em>lp</em>=&lt;low-pass limit(in A){20}&gt;] [<em>trs</em>=&lt;origin shift(in pixels){0}&gt;] [<em>nthr</em>=&lt;nr of OpenMP threads{1}&gt;] [<em>startit</em>=&lt;start iteration&gt;] [<em>hp</em>=&lt;high-pass limit(in A)&gt;] [<em>srch_inpl</em>=&lt;yes|no{yes}&gt;]<br>

    <strong>** less commonly used**</strong>  [<em>maxits</em>=&lt;max iterations{500}&gt;] [<em>inner</em>=&lt;inner mask radius(in pixels)&gt;] [<em>width</em>=&lt;pixels falloff inner mask(in pixels){10}&gt;]</p>
</div>
</div>


************SIMPLE_PRIME2D_INIT************

<div class="AccordionPanel">
  <div class="AccordionPanelTab">simple_prime2d_init</div>
  <div class="AccordionPanelContent">
    <p><strong>simple_prime2d_init</strong> is a program for initialising prime2D. We use it to produce the initial random references when executing <em>simple_prime2D</em>.</p>
    <p align="left"><span class="h2_manual">Usage:<br>
 </span> &gt;&gt;&gt;<strong>simple_prime2d_init </strong><em>stk</em>=&lt;stack.ext&gt; <em>smpd</em>=&lt;sampling distance(in A)&gt; <em>msk</em>=&lt;mask radius(in pixels)&gt; <em>ncls</em>=&lt;nr of clusters&gt; [<em>nthr</em>=&lt;nr of OpenMP threads{1}&gt;] [<em>oritab</em>=&lt;input doc&gt;]<br></p>
<p><span class="h2_manual">Comments:<br>
</span> The program assumes that the images have been phase-flipped, as no CTF correction by Wiener restoration is implemented yet. The random clustering and in-plane alignment will be printed in the file <em>prime2D_startdoc.txt</em> produced by the program. This file is used together with the initial references (<em>startcavgsmsk.ext</em>) to execute <em>simple_prime2D</em>.</p>
</div>
</div>


************SIMPLE_PRIME3D************

<div class="AccordionPanel">
  <div class="AccordionPanelTab">simple_prime3d</div>
  <div class="AccordionPanelContent">
    <p><strong>simple_prime3d</strong> is an ab inito reconstruction/refinement program based on probabilistic projection matching. PRIME is shorthand for PRobabilistic Initial 3D Model Generation for Single-Particle Cryo-Electron Microscopy. You should use phase-flipped images for initial model production with PRIME3D (phase flipping can be done with <em>simple_stackops</em>). Do not search the origin shifts initially, when the model is of very low quality. If your images are far off centre, use <em>simple_stackops</em> with option <em>shalgn=yes</em> instead to shiftalign the images beforehand (the algorithm implemented is the same as EMAN's <em>cenalignint</em> program). We recommend running the first round of PRIME with the default dynamic resolution stepping <em>dynlp=yes</em>. The <em>dynlp</em> option implements a heuristic resolution weighting/update scheme. The initial low-pass limit is set so that each image receives ten nonzero orientation weights. When quasi-convergence has been reached, the limit is updated one Fourier index at the time until PRIME reaches the condition where six nonzero orientation weights are assigned to each image. FSC-based filtering is unfortunately not possible to do in the ab initio reconstruction step, because when the orientations are mostly random, the FSC overestimates the resolution. Once the initial model has converged, we recommend start searching the shifts (by setting <em>trs</em> to some nonzero value), applying the FSC for resolution-weighting (by setting <em>eo=yes</em>). You should NOT give <em>ctf=flip</em> on the command line unless the model has converged. Giving <em>ctf=flip</em> on the command lines signal to PRIME that tou have obtain a reconstruction of decent resolution and you want to take it further by applying Wiener restoration by resolution-weighting the reocnstructed volume more accurately. In order to be able to use Wiener restoration you also need to input CTF parameters, for example via <em>deftab=defocus_values.txt</em>. Remember that the defocus values should be given in microns and the astigmatism angle in degrees (one row of the file <em>defocus_values.txt</em> may look like: <em>dfx=3.5</em> <em>dfy=3.3</em> <em>angast=20.0</em>).</p>
    <p align="left"><span class="h2_manual">Usage:<br>
 </span> &gt;&gt;&gt;<strong>simple_prime3d </strong><em>stk</em>=&lt;stack.ext&gt; <em>vol1</em>=&lt;invol.ext&gt; [<em>vol2</em>=&lt;refvol_2.ext&gt; etc.] <em>smpd</em>=&lt;sampling distance(in A)&gt; <em>msk</em>=&lt;mask radius(in pixels)&gt; [<em>oritab</em>=&lt;previous alignment doc&gt;] [<em>trs</em>=&lt;origin shift(in pixels){0}&gt;] [<em>lp</em>=&lt;low-pass limit{20}&gt;] [<em>dynlp</em>=&lt;yes|no{yes}&gt;] [<em>nstates</em>=&lt;nstates to reconstruct&gt;] [<em>frac</em>=&lt;fraction of ptcls to include{1}&gt;] [<em>mw</em>=&lt;molecular weight(in kD)&gt;] [<em>nthr</em>=&lt;nr of OpenMP threads{1}&gt;] [<em>startit</em>=&lt;start iteration&gt;] [<em>refine</em>=&lt;no|shc|neigh|shcneigh{no}&gt;] [<em>lpstop</em>=&lt;stay at this low-pass limit (in A)&gt;] [<em>deftab</em>=&lt;text file defocus values&gt;] [<em>nspace</em>=&lt;nr reference sections{1000}&gt;] [<em>eo</em>=&lt;yes|no{no}&gt;] [<em>amsklp</em>=&lt;automask low-pass limit(in A)&gt;] [<em>pgrp</em>=&lt;cn|dn|t|o|i{c1}&gt;] [<em>ctf</em>=&lt;yes|no|flip|mul{no}&gt;] [<em>kv</em>=&lt;acceleration voltage(in kV){300.}&gt;] [<em>cs</em>=&lt;spherical aberration constant(in mm){2.7}&gt;] [<em>fraca</em>=&lt;frac amp contrast{0.07}&gt;] [<em>hp</em>=&lt;high-pass limit(in A)&gt;] [<em>diversify</em>=&lt;yes|no{yes}&gt;] [<em>xfel</em>=&lt;yes|no{no}&gt;]<br>

    <strong>** less commonly used**</strong>  [<em>maxits</em>=&lt;max iterations{100}&gt;] [<em>edge</em>=&lt;edge size for softening molecular envelope(in pixels){3}&gt;] [<em>noise</em>=&lt;yes|no{no}&gt;] [<em>npeaks</em>=&lt;number of nonzero orientation weights&gt;] [<em>dens</em>=&lt;density(e.g. 9.368 Da/A3 4 gold clusters){0.}&gt;] [<em>nvox</em>=&lt;nr of voxels in mask{0}&gt;] [<em>inner</em>=&lt;inner mask radius(in pixels)&gt;] [<em>width</em>=&lt;pixels falloff inner mask{10}&gt;]</p>
<p><span class="h2_manual">Comments:<br>
</span> Note that we do not assume any point-group symmetry in the initial runs. However, the <em>simple_symsrch</em> program can be used to align the reconstruction to its symmetry axis so that future searches can be restricted to the asymmetric unit in refinement. Less commonly used and less obvious input parameters are <em>nspace</em>, which  controls the number of reference projections, <em>amsklp</em>, which controls the low-pass limit used in the automask routine, <em>maxits</em>, which controls the maximum number of iterations executed, <em>pgrp</em>, which controls the point-group symmetry, assuming that the starting volume is aligned to its principal symmetry axis, <em>edge</em>, which controls the size of the softening edge in the automask routine.</p>
</div>
</div>


************SIMPLE_PRIME3D_INIT************

<div class="AccordionPanel">
  <div class="AccordionPanelTab">simple_prime3d_init</div>
  <div class="AccordionPanelContent">
    <p><strong>simple_prime3d_init</strong> is a program for generating a random initial model for initialisation of PRIME3D when executed in distributed mode. It is assumed that the images have been phase flipped. If the data set is large (&gt;5000 images), generating a random model can be quite slow. To speedup, set <em>nran</em> to some smaller number, resulting in <em>nran</em> images selected randomly for reconstruction.</p>
    <p align="left"><span class="h2_manual">Usage:<br>
 </span> &gt;&gt;&gt;<strong>simple_prime3d_init </strong><em>stk</em>=&lt;stack.ext&gt; <em>smpd</em>=&lt;sampling distance(in A)&gt; <em>msk</em>=&lt;mask radius(in pixels)&gt; [<em>nspace</em>=&lt;nr reference sections{1000}&gt;] [<em>nran</em>=&lt;size of random sample&gt;] [<em>lp</em>=&lt;low-pass limit(in A)&gt;] [<em>nthr</em>=&lt;nr OpenMP threads{1}&gt;]<br>

    <strong>** less commonly used**</strong> [<em>pgrp</em>=&lt;cn|dn|t|o|i{c1}&gt;] [<em>npeaks</em>=&lt;nr nonzero orientation weights{1}&gt;] [<em>ctf</em>=&lt;yes|no|flip|mul{no}&gt;] [<em>kv</em>=&lt;acceleration voltage(in kV){300.}&gt;] [<em>fraca</em>=&lt;frac amp contrast{0.07}&gt;] [<em>cs</em>=&lt;spherical aberration constant(in mm){2.7}&gt;] [<em>deftab</em>=&lt;text file with defocus values&gt;] [<em>inner</em>=&lt;inner mask radius(in pixels)&gt;] [<em>width</em>=&lt;pixels falloff inner mask{10}&gt;] [<em>xfel</em>=&lt;yes|no{no}&gt;]</p>
</div>
</div>


************SIMPLE_PRINT_FSC************

<div class="AccordionPanel">
  <div class="AccordionPanelTab">simple_print_fsc</div>
  <div class="AccordionPanelContent">
    <p><strong>simple_print_fsc</strong> is a program for printing the binary FSC files produced by PRIME3D</p>
    <p align="left"><span class="h2_manual">Usage:<br>
 </span> &gt;&gt;&gt;<strong>simple_print_fsc </strong><em>smpd</em>=&lt;sampling distance(in A)&gt; <em>box</em>=&lt;image size(in pixels)&gt; <em>fsc</em>=&lt;fsc_state1.bin&gt;<br></p>
</div>
</div>


************SIMPLE_PROJVOL************

<div class="AccordionPanel">
  <div class="AccordionPanelTab">simple_projvol</div>
  <div class="AccordionPanelContent">
    <p><strong>simple_projvol</strong> is a program for projecting a volume using interpolation in Fourier space. Input is a SPIDER or MRC volume. Output is a stack of projection images of the same format as the inputted volume.</p>
    <p align="left"><span class="h2_manual">Usage:<br>
 </span> &gt;&gt;&gt;<strong>simple_projvol </strong><em>vol1</em>=&lt;invol.ext&gt; <em>smpd</em>=&lt;sampling distance(in A)&gt; [<em>nspace</em>=&lt;nr of projs{1000}&gt;] [<em>outstk</em>=&lt;ouput stack&gt;] [<em>oritab</em>=&lt;SIMPLE alignment doc&gt;] [<em>nthr</em>=&lt;nr of openMP threads{1}&gt;] [<em>rnd</em>=&lt;yes|no{no}&gt;] [<em>trs</em>=&lt;origin shift(in pixels){0}&gt;]<br>

    <strong>** less commonly used**</strong>  [<em>pgrp</em>=&lt;cn|dn|t|o|i{c1}&gt;] [<em>ctf</em>=&lt;yes|no|flip|mul{no}&gt;] [<em>kv</em>=&lt;acceleration voltage(in kV){300.}&gt;] [<em>fraca</em>=&lt;frac amp contrast{0.07}&gt;] [<em>cs</em>=&lt;spherical aberration constant(in mm){2.7}&gt;] [<em>defocus</em>=&lt;underfocus(in microns){3.}&gt;] [<em>bfac</em>=&lt;bfactor(in A**2){200.}&gt;] [<em>neg</em>=&lt;yes|no{no}&gt;] [<em>mirr</em>=&lt;yes|x|y|no{no}&gt;] [<em>top</em>=&lt;stop at this index&gt;] [<em>xfel</em>=&lt;yes|no{no}&gt;]</p>
<p><span class="h2_manual">Comments:<br>
</span> Projections are generated by extraction of central sections from the Fourier volume and back transformation of the 2D FTs. <em>nspace</em> controls the number of projection images generated with quasi-even projection directions.The <em>oritab</em> parameter allows you to input the orientations that you wish to have your volume projected in. If <em>rnd=yes</em>, random rather than quasi-even projections are generated, <em>trs</em> then controls the halfwidth of the random origin shift. Less commonly used parameters are <em>pgrp</em>, which controls the point-group symmetry <em>c</em> (rotational), <em>d</em> (dihedral), <em>t</em> (tetrahedral), <em>o</em> (octahedral) or <em>i</em> (icosahedral). The point-group symmetry is used to restrict the set of projections to within the asymmetric unit. <em>ctf=yes</em> allows you to apply CTF to the images, using constant defocus and no astigmatism. If you want to do this you need to define the parameters <em>kv</em>, <em>fraca</em>, <em>cs</em>, <em>defocus</em> and <em>bfac</em>. <em>neg</em> inverts the contrast of the projections. <em>mirr=yes</em> mirrors the projection by modifying the Euler angles. If <em>mirr=x</em> or <em>mirr=y</em> the projection is physically mirrored after it has been generated.</p>
</div>
</div>


************SIMPLE_RANK_CAVGS************

<div class="AccordionPanel">
  <div class="AccordionPanelTab">simple_rank_cavgs</div>
  <div class="AccordionPanelContent">
    <p><strong>simple_rank_cavgs</strong> is a program for ranking class averages by decreasing population, given the stack of class averages (<em>stk</em> argument) and the 2D orientations document (<em>oritab</em>) generated by <em>simple_prime2D</em>.</p>
    <p align="left"><span class="h2_manual">Usage:<br>
 </span> &gt;&gt;&gt;<strong>simple_rank_cavgs </strong><em>stk</em>=&lt;cavgs.ext&gt; <em>oritab</em>=&lt;2D clustering doc&gt; [<em>outstk</em>=&lt;ranked cavgs stack&gt;]<br></p>
</div>
</div>


************SIMPLE_RECVOL************

<div class="AccordionPanel">
  <div class="AccordionPanelTab">simple_recvol</div>
  <div class="AccordionPanelContent">
    <p><strong>simple_recvol</strong> is a program for reconstructing volumes from MRC and SPIDER stacks, given input orientations and state assignments (obtained by program <em>simple_prime3D</em>). The algorithm is based on direct Fourier inversion with a Kaiser-Bessel (KB) interpolation kernel. This window function reduces the real-space ripple artifacts associated with direct moving windowed-sinc interpolation. The feature sought when implementing this algorithm was to enable quick, reliable reconstruction from aligned individual particle images.</p>
    <p align="left"><span class="h2_manual">Usage:<br>
 </span> &gt;&gt;&gt;<strong>simple_recvol </strong><em>stk</em>=&lt;ptcls.ext&gt; <em>smpd</em>=&lt;sampling distance(in A)&gt; <em>oritab</em>=&lt;algndoc.txt&gt; <em>msk</em>=&lt;mask radius(in pixels)&gt; [<em>lp</em>=&lt;low-pass limit{20}&gt;] [<em>frac</em>=&lt;fraction of ptcls to include{1.}&gt;] [<em>nthr</em>=&lt;nr of openMP threads{1}&gt;] [<em>pgrp</em>=&lt;cn|dn|t|o|i{c1}&gt;]<br>

    <strong>** less commonly used**</strong> [<em>mw</em>=&lt;molecular weight(in kD)&gt;] [<em>amsklp</em>=&lt;low-pass limit(in A){20}&gt;] [<em>mul</em>=&lt;shift multiplication factor{1}&gt;] [<em>ctf</em>=&lt;yes|no|flip|mul{no}&gt;] [<em>kv</em>=&lt;acceleration voltage(in kV){300.}&gt;] [<em>fraca</em>=&lt;frac amp contrast{0.07}&gt;] [<em>cs</em>=&lt;spherical aberration constant(in mm){2.7}&gt;] [<em>deftab</em>=&lt;text file defocus values&gt;] [<em>state</em>=&lt;state to reconstruct{all}&gt;] [<em>edge</em>=&lt;edge size for softening molecular envelope(in pixels){3}&gt;] [<em>dens</em>=&lt;density(e.g.9.368 Da/A3 4 gold clusters){0.}&gt;] [<em>inner</em>=&lt;inner mask radius(in pixels)&gt;] [<em>width</em>=&lt;pixels falloff inner mask{10}&gt;] [<em>mirr</em>=&lt;yes|no{no}&gt;] [<em>even</em>=&lt;yes|no{no}&gt;] [<em>odd</em>=&lt;yes|no{no}&gt;]</p>
<p><span class="h2_manual">Comments:<br>
</span> <em>mul</em> is used to scale the origin shifts if down-sampled were used for alignment and the original images are used for reconstruction. This program can be run in distributed mode using <em>distr_simple.pl</em>. <em>ctf</em>, <em>kv</em>, <em>fraca</em>, <em>cs</em> and <em>deftab</em> are used to communicate CTF information to the program. <em>ctf=yes</em>, <em>ctf=flip</em> or <em>ctf=mul</em> turns on the Wiener restoration. If the images were pre-multiplied with CTF set <em>ctf=mul</em> or if the images were phase-flipped set <em>ctf=flip</em>. <em>amsklp</em>, <em>mw</em>, and <em>edge</em> are parameters that control the solvent mask: the low-pass limit used to generate the envelope; the molecular weight of the molecule (protein assumed but it works reasonably well also for RNA; slight modification of <em>mw</em> might be needed). The <em>inner</em> parameter controls the radius of the soft-edged mask used to remove the unordered DNA/RNA core of spherical icosahedral viruses. The <em>even</em> and <em>odd</em> parameters allow you to reconstruct either the even or the odd pair.</p>
</div>
</div>


************SIMPLE_RES************

<div class="AccordionPanel">
  <div class="AccordionPanelTab">simple_res</div>
  <div class="AccordionPanelContent">
    <p><strong>simple_res</strong> is a program for checking the low-pass resolution limit for a given Fourier index.</p>
    <p align="left"><span class="h2_manual">Usage:<br>
 </span> &gt;&gt;&gt;<strong>simple_res </strong><em>smpd</em>=&lt;sampling distance(in A)&gt; <em>find</em>=&lt;Fourier index&gt; <em>box</em>=&lt;box size (in pixels)&gt;<br></p>
</div>
</div>


************SIMPLE_RESRANGE************

<div class="AccordionPanel">
  <div class="AccordionPanelTab">simple_resrange</div>
  <div class="AccordionPanelContent">
    <p><strong>simple_resrange</strong> is a program for estimating the resolution range used in the heuristic resolution-stepping scheme in the PRIME3D initial model production procedure. The initial low-pass limit is set so that each image receives ten nonzero orientation weights. When quasi-convergence has been reached, the limit is updated one Fourier index at the time, until PRIME reaches the condition where six nonzero orientation weights are assigned to each image. FSC-based filtering is unfortunately not possible to do in the ab initio reconstruction step, because when the orientations are mostly random, the FSC overestimates the resolution. This program is used internally by <em>distr_simple.pl</em> when executing PRIME in distributed mode. We advise you to check the starting and stopping low-pass limits before executing PRIME3D using this program.</p>
    <p align="left"><span class="h2_manual">Usage:<br>
 </span> &gt;&gt;&gt;<strong>simple_resrange </strong><em>smpd</em>=&lt;sampling distance(in A)&gt; [<em>nspace</em>=&lt;nr of reference sections{1000}&gt;] [<em>pgrp</em>=&lt;cn|dn|t|o|i{c1}&gt;] [<em>box</em>=&lt;image size(in pixels)&gt;] [<em>moldiam</em>=&lt;molecular diameter(in A))&gt;]<br></p>
<p><span class="h2_manual">Comments:<br>
</span> The resolution range estimate depends on the molecular diameter, which is estimated based on the box size. If you want to override this estimate, set <em>moldiam</em> to the desired value (in A). This may be necessary if your images have a lot of background "padding". However, for starting model generation it is probably better to clip the images snugly around the particle, because smaller images equal less computation.</p>
</div>
</div>


************SIMPLE_SIMIMGS************

<div class="AccordionPanel">
  <div class="AccordionPanelTab">simple_simimgs</div>
  <div class="AccordionPanelContent">
    <p><strong>simple_simimgs</strong> is a program for simulating cryo-EM images. It is not a very sophisticated simulator, but it is nevertheless useful for testing purposes. It does not do any multi-slice simulation and it cannot be used for simulating molecules containing heavy atoms. It does not even accept a PDB file as an input. Input is a cryo-EM map, which we usually generate from a PDB file using EMAN's program <em>pdb2mrc</em>. <em>simple_simimgs</em> then projects the volume using Fourier interpolation, applies 20% of the total noise to the images (pink noise), Fourier transforms them, and multiplies them with astigmatic CTF and B-factor. The images are inverse FTed before the remaining 80% of the noise (white noise) is added.</p>
    <p align="left"><span class="h2_manual">Usage:<br>
 </span> &gt;&gt;&gt;<strong>simple_simimgs </strong><em>vol1</em>=&lt;invol.ext&gt; <em>smpd</em>=&lt;sampling distance(in A)&gt; <em>msk</em>=&lt;mask radius(in pixels)&gt; <em>nptcls</em>=&lt;number of particles&gt; <em>snr</em>=&lt;signal2noise ratio&gt; [<em>sherr</em>=&lt;shift error(in pixels){2}&gt;] [<em>ctf</em>=&lt;yes|no|flip|mul{yes}&gt;] [<em>kv</em>=&lt;acceleration voltage(in kV){300.}&gt;] [<em>fraca</em>=&lt;frac amp contrast{0.07}&gt;] [<em>cs</em>=&lt;spherical aberration constant(in mm){2.7}&gt;] [<em>defocus</em>=&lt;defocus(in microns){3.0}&gt;] [<em>deferr</em>=&lt;defocus error(in microns){1.0}&gt;] [<em>astigerr</em>=&lt;astigmatism error(in microns){0.1}&gt;] [<em>bfac</em>=&lt;bfactor(in A**2){0}&gt;] [<em>bfacerr</em>=&lt;bfactor error(in A**2){0}&gt;] [<em>oritab</em>=&lt;input alignment doc&gt;] [<em>outfile</em>=&lt;output alignment doc{simoris.txt}&gt;] [<em>outstk</em>=&lt;ouput stack{simimgs.ext}&gt;] [<em>nthr</em>=&lt;nr of OpenMP threads{1}&gt;]<br></p>
</div>
</div>


************SIMPLE_STACKOPS************

<div class="AccordionPanel">
  <div class="AccordionPanelTab">simple_stackops</div>
  <div class="AccordionPanelContent">
    <p><strong>simple_stackops</strong> is a program that provides standard single-particle image processing routines that are applied to MRC or SPIDER stacks.</p>
    <p align="left"><span class="h2_manual">Usage:<br>
 </span> &gt;&gt;&gt;<strong>simple_stackops </strong>[<em>stk</em>=&lt;stack.ext&gt;] [<em>stk2</em>=&lt;stack2.ext&gt;] [<em>nptcls</em>=&lt;nr of imgs&gt;] [<em>smpd</em>=&lt;sampling distance(in A)&gt;] [<em>outstk</em>=&lt;outstk.ext&gt;] [<em>split</em>=&lt;nr of partitions to split the stack into&gt;] [<em>oritab</em>=&lt;SIMPLE alignment doc&gt;] [<em>hp</em>=&lt;high-pass limit(in A)&gt;](in A)&gt;] [<em>shalgn</em>=&lt;yes|no{no}&gt;] [<em>mul</em>=&lt;shift multiplication factor{1}&gt;] [<em>trs</em>=&lt;origin shift halfwidth(in pixels){0}] [<em>lp</em>=&lt;low-pass limit(in A){20}&gt;] [<em>state</em>=&lt;state to extract&gt;] [<em>frac</em>=&lt;fraction of ptcls to extract{1}&gt;] [<em>class</em>=&lt;cluster2extract&gt;] [<em>snr</em>=&lt;signal2noise ratio&gt;] [<em>msk</em>=&lt;mask radius(in pixels){box/2}&gt;] [<em>vis</em>=&lt;yes|no&gt;] [<em>bin</em>=&lt;binarize{no}&gt;] [<em>acf</em>=&lt;yes|no{no}&gt;] [<em>phrand</em>=&lt;yes|no{no}&gt;] [<em>fromp</em>=&lt;start ptcl&gt;] [<em>top</em>=&lt;stop ptcl&gt;] [<em>nran</em>=&lt;number of random images to select&gt;] [<em>newbox</em>=&lt;scaled box&gt;] [<em>scale</em>=&lt;scale factor{1}&gt;] [<em>hfun</em>=&lt;sigm|tanh|lin{sigm}&gt;] [<em>norm</em>=&lt;yes|no{no}&gt;] [<em>noise_norm</em>=&lt;yes|no&gt;] [<em>nthr</em>=&lt;nr of openMP threads{1}&gt;] [<em>avg</em>=&lt;yes|no&gt;] [<em>filetab</em>=&lt;filenames.txt&gt;] [<em>stats</em>=&lt;yes|no{yes}&gt;] [<em>ctf</em>=&lt;yes|no|flip|mul|abs{no}&gt;] [<em>kv</em>=&lt;acceleration voltage(in kV){300.}&gt;] [<em>fraca</em>=&lt;frac amp contrast{0.07}&gt;] [<em>cs</em>=&lt;spherical aberration constant(in mm){2.7}&gt;] [<em>deftab</em>=&lt;text file with defocus values&gt;] [<em>ft2img</em>=&lt;yes|no{no}&gt;] [<em>frameavg</em>=&lt;nr of frames to average{0}&gt;] [<em>clip</em>=&lt;clipped box size{box}&gt;] [<em>compare</em>=&lt;yes|no{no}&gt;] [<em>mirr</em>=&lt;no|x|y{no}&gt;] [<em>neg</em>=&lt;yes|no{no}&gt;] [<em>box</em>=&lt;image size(in pixels)&gt;] [<em>outfile</em>=&lt;output_params.txt&gt;] [<em>ctfsq</em>=&lt;yes|no{no}&gt;] [<em>masscen</em>=&lt;yes|no{no}&gt;] [<em>thres</em>=&lt;threshold4bin[0,1]{0.6}&gt;] [<em>inner</em>=&lt;inner mask radius(in pixels)&gt;] [<em>width</em>=&lt;pixels falloff inner mask{10}&gt;] [<em>append</em>=&lt;yes|no{no}&gt;]<br></p>
<p><span class="h2_manual">Comments:<br>
</span> You can do many things with <em>simple_stackops</em>. Inputting two stacks of the same size results in the calculation of the joint Fourier Ring  Correlation (FRC) between the images. Inputting no stacks, but setting <em>nptcls</em>, results in production of <em>nptcls</em> pure noise images, unless <em>ctf=yes</em>, then CTF images are produced. Filtering is controlled by the <em>hp</em> and <em>lp</em> arguments. If you input an alignment document (via <em>oritab</em>) <em>shalgn=yes</em> will produce a shift-aligned stack based on the inputted orientations, whereas if you do not input an alignment document, the alignment will be done in a reference-free manner (remember to set <em>trs</em> to some nonzero value). If you want to centre the images based on their centre of mass, set <em>masscen=yes</em>. If you want to extract a particular state, give an alignment document (<em>oritab</em>) and set <em>state</em> to the state that you want to extract. If you want to select the fraction of best particles (according to the goal function), input an alignment doc (<em>oritab</em>) and set <em>frac</em>. You can combine the <em>state</em> and <em>frac</em> options. If you want to apply noise to images, give the desired signal-to-noise ratio via <em>snr</em>. If you want to mask your images with a spherical mask with a soft falloff, set <em>msk</em> to the radius in pixels. If you want to binarize your images, set <em>bin=yes</em>. If <em>thres</em> is defined, the images are sigmoid normalised to  and threshold binarized. If <em>thres</em> is not defined the foreground/background pixels are assigned by sort-means (a variant of the continuous k-means algorithm where the initial centres are obtained by sorting the real values). If you want to calculate the autocorrelation function of your images set <em>acf=yes</em>. If you want to randomise the phases of the Fourier transforms of your images, set <em>phrand=yes</em> and <em>lp</em> to the desired low-pass limit. If you want to extract a contiguous subset of particle images from the stack, set <em>fromp</em> and <em>top</em>. If you want to fish out a number of particle images from your stack at random, set <em>nran</em> to some nonzero integer number less than <em>nptcls</em>. If you want to resize you images, set the desired box to <em>newbox</em> or use the <em>scale</em> option. It is often convenient to use <em>scale</em> in combination with <em>clip</em> to resize images.  If you want to normalise your images, set <em>norm=yes</em>. <em>hfun</em> controls the normalisation function. With <em>avg=yes</em> the global average of the inputted stack is calculated. With <em>ctf=flip</em> the contrast inversions due to the CTF are corrected by the infamous (but effective) phase-flipping heuristic. This requires additional input of CTF-related parameters (<em>kv</em>, <em>fraca</em> and <em>cs</em>) in addition to the defocus and astigmatism angle values, communicated either via <em>oritab</em> or via <em>deftab</em>. Even if you do initially phase-flip the images, which you should do for initial model production with PRIME, you can turn on the Wiener restoration later anyway, to accomplish correct weighting of information around the CTF zeroes and maximal noise reduction. <em>ft2img=yes</em> produces images of the square power spectrum of the images in <em>stk</em>. If you define <em>frameavg</em> to some integer number larger than one averages with chunk sizes of <em>frameavg</em> are produced, which may be useful for analysis of dose-fractionated image series. <em>clip</em> can be used to re-window or pad the images to a different box size. When <em>compare=yes</em>, the two inputted stacks are Fourier ring correlated. <em>neg</em> inverts the contrast of the images. <em>ctfsq</em> applies the squared CTF to the inputted images. <em>inner</em> is for applying an inner mask with fall-off width <em>width</em>. Finally, <em>append</em> is for appending stack <em>stk2</em> with stack <em>stk</em>, so that the <em>stk2</em> images occur last in the series and the stk name is preserved.</p>
</div>
</div>


************SIMPLE_SYMSRCH************

<div class="AccordionPanel">
  <div class="AccordionPanelTab">simple_symsrch</div>
  <div class="AccordionPanelContent">
    <p><strong>simple_symsrch</strong> is a program for searching for the principal symmetry axis of a volume reconstructed without assuming any point-group symmetry. Our philosophy is to start off without assuming any symmetry, and then analyzse the reconstructed volume to identify the correct point-group symmetry. <em>simple_symsrch</em> can be used for this purpose. The program takes as input the asymmetrical reconstruction (obtained with <em>simple_prime3D</em>), the alignment document for all the particle images that have gone into the reconstruction, and the desired point-group symmetry. It then projects the reconstruction in 20 (default option) even directions, uses common lines-based optimisation to identify the principal symmetry axis, applies the rotational transformation to the inputted orientations, and produces a new alignment document. Input this document to <em>simple_recvol</em> or <em>simple_eo_recvol</em> together with the images and the point-group symmetry to generate a symmetrised map. If you are unsure about the point-group, you should of course test many different point-groups and compare the asymmetric map with the symmetrised maps. SIMPLE now implements most point-groups: c- and d-groups, as well as tetrahedral, octahedral, and icosahedral groups.</p>
    <p align="left"><span class="h2_manual">Usage:<br>
 </span> &gt;&gt;&gt;<strong>simple_symsrch </strong><em>vol1</em>=&lt;vol.ext&gt; <em>smpd</em>=&lt;sampling distance(in A)&gt; <em>oritab</em>=&lt;input alignment doc&gt; <em>pgrp</em>=&lt;cn|dn|t|o|i{c1}&gt; <em>outfile</em>=&lt;output alignment doc&gt; <em>lp</em>=&lt;low-pass limit(in A)&gt; [<em>amsklp</em>=&lt;low-pass limit for centering mask(in A){50}&gt;] [<em>hp</em>=&lt;high-pass limit(in A)&gt;] [<em>nthr</em>=&lt;nr openMP threads{1}&gt;] [<em>nspace</em>=&lt;nr of projs{20}&gt;]<br></p>
<p><span class="h2_manual">Comments:<br>
</span> The <em>state</em> parameter allows you to apply symmetry for the given state.</p>
</div>
</div>


************SIMPLE_VOLOPS************

<div class="AccordionPanel">
  <div class="AccordionPanelTab">simple_volops</div>
  <div class="AccordionPanelContent">
    <p><strong>simple_volops</strong> provides standard single-particle image processing routines that are applied to MRC or SPIDER volumes.</p>
    <p align="left"><span class="h2_manual">Usage:<br>
 </span> &gt;&gt;&gt;<strong>simple_volops </strong>[<em>vol1</em>=&lt;invol.ext&gt;] [<em>vol2</em>=&lt;invol2.ext&gt;] [<em>smpd</em>=&lt;sampling distance(in A)&gt;] [<em>outvol</em>=&lt;outvol.ext&gt;] [<em>nthr</em>=&lt;nr of openMP threads{1}&gt;] [<em>phrand</em>=&lt;yes|no{no}&gt;] [<em>msk</em>=&lt;mask radius(in pixels)&gt;] [<em>lp</em>=&lt;low-pass limit{20}&gt;] [<em>hp</em>=&lt;high-pass limit{100}&gt;] [<em>snr</em>=&lt;signal-to-noise ratio&gt;] [<em>center</em>=&lt;yes|no{no}&gt;] [<em>soften</em>=&lt;yes|no{no}&gt;] [<em>guinier</em>=&lt;yes|no{no}&gt;] [<em>bfac</em>=&lt;bfactor(in A**2){200.}&gt;] [<em>edge</em>=&lt;edge size for softening molecular envelope(in pixels){3}&gt;] [<em>mskfile</em>=&lt;mask.ext&gt;] [<em>countvox</em>=&lt;yes|no{no}&gt;] [<em>newbox</em>=&lt;scaled box&gt;] [<em>scale</em>=&lt;scale factor{1}&gt;] [<em>msktype</em>=&lt;hard|soft{soft}&gt;] [<em>inner</em>=&lt;inner mask radius(in pixels)&gt;] [<em>width</em>=&lt;pixels falloff inner mask{10}&gt;] [<em>cube</em>=&lt;side (in pixels){0}&gt;] [<em>e1</em>=&lt;1st Euler{0}&gt;] [<em>e2</em>=&lt;2nd Euler{0}&gt;] [<em>e3</em>=&lt;3d Euler{0}&gt;] [<em>corner</em>=&lt;corner size{0}&gt;] [<em>neg</em>=&lt;yes|no{no}&gt;] [<em>voltab</em>=&lt;file table&gt;] [<em>voltab2</em>=&lt;file table&gt;] [<em>bin</em>=&lt;yes|no{no}&gt;] [<em>nvox</em>=&lt;nr of voxels{0}&gt;] [<em>xsh</em>=&lt;x shift(pixels){0}&gt;] [<em>ysh</em>=&lt;y shift(pixels){0}&gt;] [<em>zsh</em>=&lt;z shift(pixels){0}&gt;]<br></p>
<p><span class="h2_manual">Comments:<br>
</span> If you input two volumes and the sampling distance, the FSC is calculated between the volumes. The FSC plot is written to STDOUT together with resolution estimates at  in Fourier space. <em>voltab</em> and <em>voltab2</em> are used to give text files with the names of volume files that are correlated and the nearest neighbour structure of the comparison is written to STDOUT.</p>
</div>
</div>


