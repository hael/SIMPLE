% Document layout
\documentclass[a4paper,11pt]{article}
\usepackage[a4paper, inner=2.5cm , outer=2.5cm, top=2cm, bottom=2cm]{geometry}
\usepackage[usenames,dvipsnames]{color}
% Referencing & fonts
\usepackage[sort&compress]{natbib}
\setlength{\bibsep}{0.0pt}
\usepackage[font=small,labelfont=bf]{caption}
\usepackage[OT2,T1]{fontenc}
% Set formats for each heading level
\usepackage{sectsty}
\allsectionsfont{\usefont{OT1}{phv}{bc}{n}\selectfont}
\sectionfont{\color{MidnightBlue}} % sets colour of sections
\subsectionfont{\color{MidnightBlue}}  % sets colour of subsections
\subsubsectionfont{\color{MidnightBlue}}  % sets colour of subsections
% Other shit
\usepackage{algorithm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{bbm}
\usepackage{booktabs}
\usepackage{epsfig}
\usepackage{float}
\usepackage[font=normalsize]{caption}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{lineno}
\usepackage{mathtools}
\usepackage{sidecap}
\usepackage{sectsty}
\usepackage{verbatim}
\usepackage{wrapfig}
\usepackage{xcolor}
% Declarations
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
\DeclareSymbolFont{cyrletters}{OT2}{wncyr}{m}{n}
\DeclareMathSymbol{\Sha}{\mathalpha}{cyrletters}{"58}
\DeclareMathSymbol{\sha}{\mathalpha}{cyrletters}{"57}
% Defined commands
 \newcommand{\prgname}[1]{\textcolor{NavyBlue}{\texttt{#1}}}
 \newcommand{\linkfont}[1]{\textcolor{BurntOrange}{\textbf{#1}}}
\newcommand{\shellcmd}[1]{\\\indent\indent\texttt{\$ #1}}
\newcommand{\shellctd}[1]{\\\indent\indent\texttt{#1}}
\newcommand{\ra}[1]{\renewcommand{\arraystretch}{#1}}
\begin{document}
\begin{figure}
\centering
\includegraphics[keepaspectratio=true,scale=0.6]{./SIMPLE_logo/rawlogo}
%\caption{}
\end{figure}

\title{\prgname{The SIMPLE 2.1 Manual}}
\date{May 15, 2016}
\maketitle

\vspace{1em}
\begin{minipage}[ht]{0.48\textwidth}
www.simplecryoem.com\\
hans.elmlund@monash.edu\\
dominika.elmlund@monash.edu\\
Dept. Biochemistry and Molecular Biology\\
School of Biomedical Sciences\\
Monash University, Bldg. 77\\
Clayton, VIC, Australia, 3800\\
\end{minipage}
\vspace{20pt}

\begin{quote}
\textbf{"Keep it SIMPLE stupid"}\\(\textit{Kelly Johnson}; lead engineer at the Lockheed Skunk Works, coined the famous KISS principle stating that systems work best if they are kept simple rather than made complex. Therefore, simplicity should be a key goal in design and unnecessary complexity should be avoided.)
\end{quote}

\begin{quote}
\textbf{"Everything should be made as SIMPLE as possible, but no SIMPLEr"}\\(\textit{Albert Einstein})
\end{quote}

\begin{quote}
\textbf{"Complex theories do not work, SIMPLE algorithms do"}\\(\textit{Vladimir N. Vapnik}; author of \textit{The Nature of Statistical Learning Theory})
\end{quote}
\clearpage

\tableofcontents{}
\clearpage

\section{About SIMPLE}

\textbf{S}ingle-particle \textbf{IM}age \textbf{P}rocessing \textbf{L}inux \textbf{E}ngine (\href{www.simplecryoem.com}{\textbf{\textcolor{BurntOrange}{SIMPLE}}}) is a program package for cryo-EM image processing, focusing on \textit{ab initio} 3D reconstruction of low-symmetry single-particles. The SIMPLE back-end consists of an object-oriented numerical library written in modern Fortran. The SIMPLE front-end consists of a few standalone, interoperable components developed according to the "Unix toolkit philosophy".

SIMPLE is free software: you can redistribute it and/or modify it under the terms of the \href{http://www.gnu.org/copyleft/gpl.html}{\textbf{\textcolor{BurntOrange}{GNU General Public License}}} as published by the Free Software Foundation, either version 3 of the license, or (at your option) any later version. SIMPLE is distributed with the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \href{http://www.gnu.org/copyleft/gpl.html}{\textbf{\textcolor{BurntOrange}{GNU General Public License}}} for more details.

\subsection{What is new in SIMPLE release 2.1?}

Our \textbf{PRIME} (for \textbf{PR}obabilistic \textbf{I}nitial \textbf{M}odel generation for single-particle cryo-\textbf{E}lectron microscopy) code has undergone major revisions. First, we re-cast the original PRIME algorithm into an approach for solving  the problem of Simultaneous 2D Alignment and Clustering (SAC) \citep{reboul2016stochastic}. The PRIME SAC solver, implemented in the program \prgname{simple\_prime2D}
\begin{itemize}
    \item[--] generates improved 2D class averages from large single-particle cryo-EM datasets
    \item[--] can be used in conjunction with \prgname{simple\_prime3D} to obtain a reliable 3D starting model in a rapid and unbiased fashion
    \item[--] overcomes inherent limitations in widely used clustering approaches, such as initialisation bias and local optimality
    \item[--] is many times faster than other widely used approaches
\end{itemize}
Secondly, the program \prgname{simple\_prime3D} implements a revised version of our \textit{ab initio} 3D reconstruction code that is about 150 times faster than the previously released version. This speedup was accomplished using new theory for fast rotational matching of polar Fourier transforms based on Hadamard products calculated using a re-organised and highly parallelizable data structure. The paper describing this is not yet published, but we have release the code since we anticipate that the massive speedup will have major impacts for our users. For example, less than 10,0000 particles downscaled to about 100x100 pixels can feasibly be processed on a modern laptop equipped with an Intel i5 or i7 processor. We executed an \textit{ab initio} 3D reconstruction run using PRIME3D on half a million images downscaled to 64x64 pixels in less than 5 hours on a cluster with 224 CPU cores (Intel(R) Xeon(R) CPU E5-2670 0 @ 2.60GHz).

\section{File Formats}

SIMPLE2.1 supports both SPIDER (\texttt{*.spi}) and MRC (\texttt{*.mrc}) formats for image stacks and volumes. The MRC file handling classes are shared with the the Frealix program for helical reconstruction \citep{rohou2014frealix}. Relion \citep{Scheres:2012aa} uses the convention that MRC stacks have the suffix \texttt{*.mrcs} and volumes the suffix \texttt{*.mrc}. This is to overcome the annoyance that it is not possible to tell from an MRC file header whether a MRC file is a volume or a stack. With SIMPLE you can select to use either the \texttt{*.mrcs} or \texttt{*.mrc} suffix for stacks. The way that we keep track of whether a file is a volume or stack is via the command line key value. The key-value pairs \texttt{vol1=rec.mrc} and \texttt{vol2=rec2.mrc} refer to volumes whereas the key-value pairs \texttt{stk=ptcls.mrc} and \texttt{stk2=ptcls2.mrc} refer to stacks. Another notable change is the text file format used to write per-particle information to disk. The SIMPLE text-files used for parameter input/output now use a \texttt{key=value} syntax of the form
\begin{verbatim}
    e1=80. e2=100. e3=5.5 x=1.23 y=4.25 dfx=2.56 dfy=2.54 angast=30.5 state=1
\end{verbatim}
to represent per-particle information. Internally, the orientation information is stored in a dynamic hash data structure, which gives the file format high flexibility. Therefore, writing conversion scripts to allow interchange of parameters between SIMPLE and other packages is trivial. SIMPLE uses the same conventions as Frealign \citep{Grigorieff:2007aa} to represent orientations and CTF parameters. The CTF parameterization obtained by CTFFIND \citep{Mindell:2003aa} can be directly plugged into SIMPLE, for example by creating a file \texttt{deftab.txt}, looking like:
\begin{verbatim}
    dfx=2.56 dfy=2.76 angast=30.5
    dfx=3.50 dfy=3.33 angast=60.0
    dfx=1.98 dfy=2.02 angast=120.5
    ...
\end{verbatim}
and adding \texttt{deftab=deftab.txt} and \texttt{ctf=yes} to the PRIME command line (if the images are phase-flipped, this should be indicated by \texttt{ctf=flip}). The \texttt{SIMPLE/scripts} folder contains a perl-script (\texttt{convert\_frealign2simple.pl}) to convert a Frealing parameter file to a SIMPLE parameter file. This is easy, since both software internally use the \href{http://spider.wadsworth.org/spider_doc/spider/docs/euler.html}{\textbf{\textcolor{BurntOrange}{Spider Euler angle convention}}}. Other packages may use other conventions.

\section{Installation}
\label{install}

\subsection{System requirements}
\label{sysreq}

\subsubsection{Hardware}
\label{hardware}

\begin{itemize}
	\item [CPU]
	\begin{itemize}
		\item[--] Linux (fully supported Debian-based distributions: Mint-17.1, Ubuntu (14.10, 15.04, 15.10, 16.04 LTS)), SUSE-13.2 (earlier SUSE versions are also supported but not tested)
		\item[--] MacOSX (Yosemite and El Capitan, i.e. 10.10 and above)
	\end{itemize}
\end{itemize}

\subsubsection{Software}
\label{soft}

\begin{itemize}
	\item [CPU]
	\begin{itemize}
		\item[--] GNU tool chain 4.9 and above.
		\item[--] The linear algebra packages: Lapack and BLAS
		\item[--] FFTW-3 (The Fastest Fourier Transform in the West library)
	\end{itemize}
\end{itemize}


\subsection{Compiling from source on a Linux PC}
\label{compilepc}

Here we will compile SIMPLE2.1 from source on a Linux PC. The manual states that  SIMPLE2.1 requires the GNU toolchain version 4.9.1 or later (see above). Although SIMPLE supports all newer versions of the GNU toolchain, it is safest to use version 4.9.X because later versions are currently incompatible with the CUDA7 compiler. GPU accelerated code is planned for SIMPLE v3 and it may not be supported unless 4.9.X is used. To check the compiler versions, we execute
\begin{verbatim}
    $ gfortran --version
    GNU Fortran (GCC) 4.9.1
    Copyright (C) 2014 Free Software Foundation, Inc.
\end{verbatim}
To confirm that the gcc and g++ compilers are of the same version, we execute
\begin{verbatim}
    $ gcc --version
    gcc (GCC) 4.9.1
    Copyright (C) 2014 Free Software Foundation, Inc.
    This is free software; see the source for copying conditions.  There is NO
    warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
\end{verbatim}
\begin{verbatim}
    $ g++ --version
    g++ (GCC) 4.9.1
    Copyright (C) 2014 Free Software Foundation, Inc.
    This is free software; see the source for copying conditions.  There is NO
    warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
\end{verbatim}
To check whether lapack is installed, we open the package manager installed on our system (in our case \texttt{Synaptic} but other systems may have others, such as \texttt{YaST}, \texttt{apt} etc.) and search for \texttt{lapack} and see that \texttt{liblapack3} is installed on the system. We also search for \texttt{fftw} and see that the \texttt{libfftw3-single-3} is installed on the system. We cd to the directory  where we have our software installed (\texttt{<my software location>}) and copy the tar ball there
\begin{verbatim}
    $ cd <my software location>
    $ cp ~/Downloads/simple2.1.tar.gz .
\end{verbatim}
Next, we unpack the tar ball and cd to the simple directory
\begin{verbatim}
    $ gunzip simple2.1.tar.gz
    $ tar -xvf simple2.1.tar
    $ cd simple2.1/
\end{verbatim}
To check which Linux distribution we are running, we execute
\begin{verbatim}
    $ lsb_release -a
    No LSB modules are available.
    Distributor ID: Ubuntu
    Description:    Ubuntu 15.10
    Release:    15.10
    Codename:   wily
\end{verbatim}
Now we try to identify the configuration template file most suitable for our system by executing
\begin{verbatim}
    $ ls -1 scripts/Template_*
    scripts/Template_FEDORA_21x64_CPU_simple_user_input.pm
    scripts/Template_MacOSX_10.9.5x64_CPU_simple_user_input.pm
    scripts/Template_MacOSXFINK_10.11.4x64_CPU_simple_user_input.pm
    scripts/Template_MASSIVE_CPU_simple_user_input.pm
    scripts/Template_Mint_17.1x64_CPU_simple_user_input.pm
    scripts/Template_OXFORD_CPU_simple_user_input.pm
    scripts/Template_SUSE_13.2x64_CPU_simple_user_input.pm
    scripts/Template_Ubuntu_14.10x64_CPU_simple_user_input.pm
    scripts/Template_Ubuntu_15.10x64_CPU_simple_user_input.pm
    scripts/Template_Ubuntu_16.XXx64_CPU_simple_user_input.pm
\end{verbatim}

For this system, it looks like the \texttt{Template\_Ubuntu\_15.10x64\_CPU\_simple\_user\_input.pm} is the best fit, so we copy it to the root of the SIMPLE directory and rename it by executing
\begin{verbatim}
    $ cp ./scripts/Template_Ubuntu_15.10x64_CPU_simple_user_input.pm
    simple_user_input.pm
\end{verbatim}

We open the \texttt{simple\_user\_input.pm} file in our favourite text editor (vim) and replace on line 30 \texttt{our\$SIMPLE\_PATH$=$"/mysimplepath/"} with \texttt{our\$SIMPLE\_PATH$=$"<my software location>/simple2.1/"}. This is the path in which the software will be installed. We close vim and execute
\begin{verbatim}
    $ ./Makefile_genAll.pl
    SIMPLE library has finished compilation in dir:
    <my software location>/simple2.1
    *********************************************************
    * Compilation and linkage is complete for Simple-v2.1   *
    * You may run all simple checks  --- List check options *
    * > make check                   --- > make check_help  *
    *                                --- > make check_cpu   *
    * Cleaners: --- > make {clean,cleanall,clean_check_cpu} *
    * New Rel.: --- > make checknews                        *
    * Lne Cntr: --- > make wc                               *
    *********************************************************
\end{verbatim}

Compilation was succesful and we see that a new directory \texttt{/bin} has been created in the simple directory in addition to two text files \texttt{add2.bashrc} and \texttt{add2.tcshrc}
\begin{verbatim}
    $ cat add2.bashrc
    export SIMPLEPATH=<my software location>/simple2.1/
    export PATH=${SIMPLEPATH}/scripts:${SIMPLEPATH}/$PATH
    $ cat add2.tcshrc
    setenv SIMPLEPATH <my software location>/simple2.1/
    set path=(${SIMPLEPATH}/scripts ${SIMPLEPATH}/bin $path)
\end{verbatim}

On this machine we use the bash shell, so we add the lines in \texttt{add2.bashrc} to the \texttt{.bashrc} file and when a new terminal window is opened we have access to all the \texttt{simple\_*} programs.

\subsection{Compiling from source on MacOSX}
\label{compilemac}

This procedure is virtually identical to the one described for Linux above but we need to select the correct configuration file. If the \texttt{fink} package manager was used to install the GNU toolchain and the FFTW library, try the configuration file:
\begin{verbatim}
    scripts/Template_MacOSXFINK_10.11.4x64_CPU_simple_user_input.pm
\end{verbatim}
 Otherwise, try the file:
\begin{verbatim}
    scripts/Template_MacOSX_10.9.5x64_CPU_simple_user_input.pm
\end{verbatim}

\subsection{Compilation troubleshooting}
\label{compiletrouble}

\subsubsection{FFTW, Lapack and BLAS}

If not already installed, the FFTW-3 library needs to be installed. Most Linux package managers \texttt{YaST}, \texttt{Synaptic}, \texttt{apt-get} etc. provide the FFTW-3 library. On a Mac system the \texttt{Fink} and \texttt{Macports} package managers provide the FFTW-3 library or it can be obtained from: \url{http://www.fftw.org/install/mac.html}. SIMPLE relies on the single-precision FFTW library. Typically we will need to
\begin{verbatim}
    $ ./configure --enable-floats
    $ make
    $ sudo make install
\end{verbatim}

The \texttt{--enable floats} directive is critical as the installer will otherwise only install the double-precision version of the library. We check that we have in the lib folder (typically: \texttt{/usr/local/lib/}):

\begin{verbatim}
    libfftw3.a libfftw3.la
    libfftw3f.a libfftw3f.la
\end{verbatim}

Similarly the \texttt{lapack3} and \texttt{BLAS} will need to be installed on the system. On MacOSX Lapack and BLAS are usually installed by default. Installation of the dependencies on a PC with a Debian operating system, such as Ubuntu or Mint, is done using the \texttt{apt-get install} command as a super user
\begin{verbatim}
    #the compilers
    $ sudo apt-get install gfortran gfortran-4.9 gcc-4.9 g++-4.9
    #libraries (Lapack and BLAS)
    $ sudo apt-get install scalapack-doc scalapack-mpi-test
    scalapack-pvm-test scalapack-test-common  libscalapack-pvm1
    libscalapack-pvm-dev libscalapack-openmpi1 libopenblas-base
    libopenblas-dev libmlpack-dev libblas-dev libblas3 liblapack-dev
    liblapack-doc liblapack-doc-man liblapack3 libopenmpi-dev
    libmeep-mpich2-dev
    #FFTW-3
    $ sudo apt-get install libfftw3-bin libfftw3-dbg libfftw3-dev
    libfftw3-doc libfftw3-double3 libfftw3-long3 libfftw3-quad3
    libfftw3-single3 cl-fftw3 fftw-dev fftw-docs libfftw3-3
    libfftw3-mpi-dev libfftw3-mpi3 
\end{verbatim}

\subsubsection{Compilers}

One possible cause of failing compilation may be that the compiler paths are not correctly set in the \texttt{simple\_user\_input.pm} file. A typical compiler configuration on Ubuntu looks like
\begin{verbatim}
    our$CC_COMPILER = "gcc-4.9";
    our$GCC_COMPILER = "g++-4.9";
    our$MPI_F_COMPILER = "/usr/bin/mpif90";
    our$FCOMPILER = "gfortran-4.9";
\end{verbatim}
A configuration on MacOSX could look like
\begin{verbatim}
    our$CC_COMPILER = "/usr/local/bin/gcc";
    our$GCC_COMPILER = "/usr/local/bin/g++";
    our$MPI_F_COMPILER = "/usr/local/bin/mpif90";
    our$FCOMPILER = "/usr/local/bin/gfortran";
\end{verbatim}

If we used the \texttt{Fink} package manager to install the GNU toolchain on MacOSX, the configuration will typically look like:

\begin{verbatim}
    our$CC_COMPILER = "/sw/bin/gcc-fsf-5";
    our$GCC_COMPILER = "/sw/bin/g++-fsf-5";
    our$MPI_F_COMPILER = "/sw/bin/mpif90";
    our$FCOMPILER = "/sw/bin/gfortran";
\end{verbatim}

If we are on MacOSX and used the \texttt{MacPorts} package manager to install the GNU toolchain, the configuration will typically look like:

\begin{verbatim}
    our$CC_COMPILER = "/opt/local/bin/gcc";
    our$GCC_COMPILER = "/opt/local/bin/g++";
    our$MPI_F_COMPILER = "/opt/local/bin/mpif90";
    our$FCOMPILER = "/opt/local/bin/gfortran";
\end{verbatim}

On MacOSX it is required that the correct Command Line Tools for \texttt{Xcode} are installed. If we use the package managers \texttt{Fink} or \texttt{MacPorts} this is taken care of as part of the installation procedure. The \texttt{gfortran-5},  \texttt{gcc-5} and \texttt{g++-5} compilers can be installed via the \texttt{apt-get}, \texttt{Synaptic} or \texttt{YaST} package managers on Linux systems. Beware that Apple have their own gcc compiler (for objective-C) which is different than the GNU one and will generate errors upon compilation.

\begin{verbatim}
    $ gcc --version 
    Configured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr
    --with-gxx-include-dir=/usr/include/c++/4.2.1
    Apple LLVM version 6.0 (clang-600.0.54) (based on LLVM 3.5svn)
    Target: x86_64-apple-darwin13.4.0
    Thread model: posix
\end{verbatim}

The compilation needs to be using the GNU compiler and \textbf{\textit{not}} the Apple one. Otherwise the compilation will not work. Make sure that the paths in \texttt{simple\_user\_input.pm} are pointing to the correct location

\begin{verbatim}
    $SIMPLE_PATH= {path where simple will be installed}
    $CC_COMPILER = {path to the gcc compiler on MacOSX,
                     default: /usr/local/bin/gcc}
    $GCC_COMPILER = {path to the g++ compiler on MacOSX,
                     default: /usr/local/bin/g++}
    $MPI_F_COMPILER = {path to the mpif90 compiler on MacOSX, 
                       default:/usr/local/bin/mpif90}
    $FCOMPILER = {path to the gfortran or ifort compiler on MacOSX,
                   default: /usr/local/bin/gfortran}

    $MPI_DIR={path to the mpi directory, default:/usr}
    $MPI_DIR_INCLUDE="/usr/include/mpi";
    $FFTW_LIB={path for to the FFTW lib, default: /usr/local/lib}
    $FFTW_INC={path to the include for the FFTW, default:
    /usr/local/fftw/3.3.4-gcc/include/} cluster dependent

    $OBJDIR={path to the object compiled files, default: obj/GFORTgpu}
    $MODDIR={path to the .mod files, default: obj/GFORTgpu}
\end{verbatim}
All of the compilers must originate from the same version of the GNU toolchain.

\subsection{Installation on a Linux cluster}
\label{inst_clusters_linux}

Installation on a Linux cluster is essentially the same as on a Linux workstation with the exception that the appropriate modules need to be loaded before installation and execution. On a typical SLURM cluster

\begin{verbatim}
    $ module load fftw/3.3.4-gcc
    $ module load gcc/4.9.1
    $ module load lapack/3.4.2 
\end{verbatim}

The instructions for how to execute SIMPLE in distributed environments (clusters or workstations with more than one CPU socket) are described below \label{distr}.

\subsection{Pre-compiled binaries for MacOSX}
\label{inst_auto_binaries_macosx}

We also provide a script for automatic installation of pre-compiled binaries on MacOSX. Download the tar ball and untar it in the directory of your choice 
\begin{verbatim}
    $ tar -xvzf Install_Simple_MacOSX_binaries.tar.gz
\end{verbatim}
Change directory 
\begin{verbatim}
    $ cd <path to>/Install_Simple_MacOSX_binaries
\end{verbatim}
This installation requires administration rights, since the script will install GNU compilers version 4.9 and the FFTW library (v3.4.4) in \texttt{/usr/local/bin} and \texttt{/usr/local/lib} respectively. To proceed with the installation specify the absolute path of the target location for the installation.
\begin{verbatim}
    $ sudo csh install_MacOSX_binaries_prod.csh /Users/<username>/Simple
\end{verbatim}
Enter your admin user password and wait for the compilation to finish. This may take a while because the fftw-3.4.4 library needs to be compiled for the most commonly used precisions. The scripts installs and checks for the correctness of the installed compilers (i.e. gcc, g++ and gfortran) in the \texttt{/usr/local/bin} folder. It
should look like
\begin{verbatim}
     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     -                       Checking installation ...                       -
     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    -                                                                       -
    -                      fftw-3.3.4 library ...                           -
    -                                                                        -
    libfftw3.a	    libfftw3f.a	         libfftw3l.a	      libfftw3q.a
    libfftw3.la	    libfftw3f.la	 libfftw3l.la	      libfftw3q.la
    libfftw3_omp.a	    libfftw3f_omp.a	 libfftw3l_omp.a      libfftw3q_omp.a
    libfftw3_omp.la	    libfftw3f_omp.la     libfftw3l_omp.la     libfftw3q_omp.la
    libfftw3_threads.a  libfftw3f_threads.a  libfftw3l_threads.a  libfftw3q_threads.a
    libfftw3_threads.la libfftw3f_threads.la libfftw3l_threads.la libfftw3q_threads.la
    -                                                                       -
    -    GNU compilers /usr/local/bin/{gcc-4.9,g++-4.9, gfortran-4.9} ...   -
    -                                                                       -
    g++	gcc	gfortran {... plus other files ...}

    gcc (GCC) 4.9.2 20141029 (prerelease)
    Copyright (C) 2014 Free Software Foundation, Inc.
    This is free software; see the source for copying conditions.  There is NO
    warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    g++ (GCC) 4.9.2 20141029 (prerelease)
    Copyright (C) 2014 Free Software Foundation, Inc.
    This is free software; see the source for copying conditions.  There is NO  
    warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    GNU Fortran (GCC) 4.9.2 20141029 (prerelease)
    Copyright (C) 2014 Free Software Foundation, Inc.

    GNU Fortran comes with NO WARRANTY, to the extent permitted by law.
    You may redistribute copies of GNU Fortran
    under the terms of the GNU General Public License.
    For more information about these matters, see the file named COPYING
\end{verbatim}
A successful completion of script provides the final steps for
successful installation and should show:
\begin{verbatim}
    ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! !
    !                                                                       !
    !            You now need to add the environment variable in            !
    !                your ~/.bashrc or shell rc:                            !
    !                                                                       !
                                 in bash                                     
                                     
    export SIMPLE_HOME=/Users/<username>/Simple/MacOSX_binaries                                              
    export PATH=${SIMPLEPATH}/scripts:${SIMPLEPATH}/bin:$PATH                
                                                                             
                         in shell or cshell or tshell                        

    setenv SIMPLEPATH /Users/<username>/Simple/MacOSX_binaries                                               
    set path=(${SIMPLEPATH}/scripts ${SIMPLEPATH}/bin $path)                 
                                                                             
                        source ~/.basrc or source ~/.cshrc                   
    !                                                                       !
        Check ownership of installation path: ls -al /Users/<username>/Simple           
    !        if it has root and not {username} then change it by:           !
    !                                                                       !
                    sudo chown -R {username} /Users/<username>/Simple                    
    !                                                                       !
    !          You may now start using SIMPLE from command line             !
          and go to: cd /Users/<username>/Simple/MacOSX_binaries                         
    !                       to launch the checks                             
    !                                                                       !
                            csh launch_checks.csh                            
    !                                                                       !
    ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! !
\end{verbatim}
To check the ownership of the target location
\begin{verbatim}
    $ ls -al /Users/<username>/Simple
    total 0
    drwxr-xr-x   3 root       staff  102 20 May 12:48 .
    drwxr-xr-x+ 26 <username> staff  884 20 May 13:36 ..
    drwxr-xr-x   7 root       staff  238 20 May 14:03 MacOSX_binaries
\end{verbatim}
We recommend changing ownership to \texttt{<username>} via   
\begin{verbatim}
    $ sudo chown -R <username> /Users/<username>/Simple
\end{verbatim}
and to confirm that the rights were changed, execute
\begin{verbatim}
    $ ls -al /Users/<username>/Simple
    total 0
    drwxr-xr-x   3 <username> staff  102 20 May 12:48 .
    drwxr-xr-x+ 26 <username> staff  884 20 May 13:36 ..
    drwxr-xr-x   7 <username> staff  238 20 May 14:03 MacOSX_binaries
\end{verbatim}
Lastly, we need to add a few paths to our shell environment. This enables running simple commands from the prompt anywhere in the user directory structure and. If you are using the bash shell, add to your \texttt{.bashrc}
\begin{verbatim}
    export SIMPLEPATH=/Users/<username>/Simple/MacOSX_binaries
    export PATH=${SIMPLEPATH}/scripts:${SIMPLEPATH}/bin:$PATH
\end{verbatim}
and if you are using the c-shell or the tc-shell, add to your \texttt{.cshrc} or \texttt{.tcshrc}
\begin{verbatim}
    setenv SIMPLEPATH /Users/<username>/Simple/MacOSX_binaries
    set path=(${SIMPLEPATH}/scripts ${SIMPLEPATH}/bin $path)
\end{verbatim}
Do not forget to source the environment by typing
\begin{verbatim}
    #for bash
    $ source ~/.bashrc
    #for cshell
    $ source ~/.cshrc
\end{verbatim}
Once this is done, launch the checks in
$\sim$/Simple/MacOSX\_binaries: 
\begin{verbatim}
    $ cd /Users/<username>/Simple/MacOSX_binaries                                         
    $ csh launch_checks.csh
\end{verbatim}
If the checks passes the installation is complete.

\section{Workflows}

\subsection{Parallel execution on laptops, workstations and clusters}
\label{paraexec}
On any machine with a single socket (laptop or workstation) it is seldom worth the effort to go beyond the shared-memory parallelisation that we provide using the OpenMP protocol. The shared-memory parallelisation is controlled by the \texttt{nthr} key (for number of threads). If your machine has six physical cores and no hyper-threading set \texttt{nthr=6} to use all the resources and \texttt{nthr=3} to use half the resources. If your machine is hyper-threaded, you may gain performance by increasing the number of threads, depending on the hardware architecture and current workload on the machine. If you have more than one CPU socket on the machine substantial performance enhancements will be gained by executing SIMPLE in distributed mode using the program \prgname{distr\_simple.pl} in the \texttt{SIMPLE/scripts} folder. This program fetches machine-specific information that the system administrator (that may be you) is responsible for providing in the \texttt{simple\_user\_input.pm} file. This is how the configuration file looks for a workstation or cluster with any number of sockets, six CPUs per socket and 16GB RAM
\begin{verbatim}
    #####################################################################
    # USER-DEFINED VARIABLES THAT CONTROL WHICH CLUSTER ENVIRONMENT TO  #
    # USE AND HOW TO USE THE RESOURCES                                  #
    #####################################################################
    our$SIMPLESYS      = 'LOCAL';          # Name of system
    our%DISTR_ENV      = %LOCAL_DISTR_ENV; # Defines the environment     
    our$EMAIL          = 'myname@uni.edu'; # e-mail for failure report
    our$NTHR           = 6;                # number of threads (CPUs per core)
    our$MEMSTR         = '8000';           # string descriptor for memory
    our$TIME_PER_IMAGE = 150;              # time per image (in seconds)
\end{verbatim}
If we had eight CPUs per socket and 32GB RAM we would have changed the number of threads to \texttt{\$NTHR=8} and the requested memory to \texttt{\$MEMSTR=16000}. We will describe what the \texttt{\$SIMPLESYS} and \texttt{\%DISTR\_ENV} variables control after we have discussed how to optimise distributed execution of SIMPLE on any heterogeneous computer cluster (Figure 1, below). 
\begin{SCfigure}[][h]
\includegraphics[keepaspectratio=true,scale=0.6]{./CPU_topo/cputopo}
\caption{\textbf{Configuration of the parallel PRIME-2D/3D execution on a heterogeneous cluster.} We here represent the nodes in  a heterogeneous cluster by two sockets with six CPUs each and 32Gb RAM/node. The best performance of PRIME--2D/3D is going to be obtained by partitioning  the jobs into \texttt{npart=2N} partitions, where \texttt{N} is the number of nodes. Each partition will then execute six threads \texttt{nthr=6} and these six threads will get access to half the RAM on the node (\texttt{memstr=16000}) because we have two sockets per node that need to share the RAM between them}
\end{SCfigure}
\\Every cluster is equipped with a job scheduler/workload manager that needs to be configured. The two most common job schedulers are SLURM (Simple Linux Utility for Resource Management) and PBS (Portable Batch System). We prefer SLURM, since it is a more modern and versatile job scheduler than PBS. All the instructions that need to be provided to the job scheduler have been separated out and put in the perl configuration module \texttt{scripts/simple\_clusterSpecs.pm}. A typical SLURM configuration is defined as
\begin{verbatim}
    ####################################################################
    # DEFINES DISTRIBUTED EXECUTION ON MYCLUSTER                       #
    ####################################################################
    our%MYCLUSTER_DISTR_ENV;
    $MYCLUSTER_DISTR_ENV{'SUBMITCMD'}='sbatch';
    $MYCLUSTER_DISTR_ENV{'SCRIPT'}="#!/bin/bash
    #SBATCH --mail-user=<<<<EMAIL>>>>
    #SBATCH --mail-type=FAIL
    #SBATCH --job-name=$NAME_DISTR
    #SBATCH --ntasks=1
    #SBATCH --ntasks-per-socket=1
    #SBATCH --cpus-per-task=<<<NTHR>>>
    #SBATCH --mem=<<<MEMSTR>>>
    #SBATCH --time=0-<<<HOURS>>>:<<<MINUTES>>>:0
    #SBATCH --output=outfile.%j
    #SBATCH --error=errfile.%j
    cd <<<EXECDIR>>> 
    <<<CMDSTRING>>> fromp=<<<START>>> top=<<<STOP>>> part=<<<PART>>>&
    &nthr=<<<NTHR>>> outfile=$ALGNDOC_FBODY<<<PART>>>.txt > OUT<<<PART>>>\nexit\n";
    $MYCLUSTER_DISTR_ENV{'SHMEMSCRIPT'}="#!/bin/bash
    #SBATCH --mail-user=<<<<EMAIL>>>>
    #SBATCH --mail-type=FAIL
    #SBATCH --job-name=$NAME_SHMEM_DISTR
    #SBATCH --ntasks=1
    #SBATCH --ntasks-per-socket=1
    #SBATCH --cpus-per-task=<<<NTHR>>>
    #SBATCH --mem=<<<MEMSTR>>>
    #SBATCH --time=0-<<<HOURS>>>:<<<MINUTES>>>:0
    #SBATCH --output=shmemoutfile.%j
    #SBATCH --error=shmemerrfile.%j
    cd <<<EXECDIR>>> 
    <<<CMDSTRING>>> nthr=<<<NTHR>>> > SHMEMJOBOUT\nexit\n";
\end{verbatim}
The \texttt{\&} character denotes a line break and the substitution tags
\begin{verbatim}
    <<<MYVARIABLE>>>
\end{verbatim}
describe variables that will be automatically substituted into the scripts. The variables \texttt{\$NAME\_DISTR} and \texttt{\$NAME\_SHMEM\_DISTR} are local to the module and describe the hardcoded names of the distribution scripts. In order to make the newly defined distributed environment accessible to SIMPLE we need to export it by adding it to the export array in the header of the module, so that the line
\begin{verbatim}
    @EXPORT = qw($ALGNDOC_FBODY %LOCAL_DISTR_ENV %MASSIVE_DISTR_ENV&
    &%MASSIVE2_DISTR_ENV %MONARCH_DISTR_ENV %OXFORD_DISTR_ENV&
    &%OXFORD2_DISTR_ENV %OXFORD3_DISTR_ENV  $CVL_DISTR_ENV);
\end{verbatim}
is updated to
\begin{verbatim}
    @EXPORT = qw($ALGNDOC_FBODY %LOCAL_DISTR_ENV %MASSIVE_DISTR_ENV&
    &%MASSIVE2_DISTR_ENV %MONARCH_DISTR_ENV %OXFORD_DISTR_ENV&
    &%OXFORD2_DISTR_ENV %OXFORD3_DISTR_ENV  $CVL_DISTR_ENV)&
    &%MYCLUSTER_DISTR_ENV;
\end{verbatim}
There are different versions of SLURM and PBS and different clusters may use different conventions for how to construct the script headers. For example on our \texttt{MASSIVE2} cluster we need to add to the headers
\begin{verbatim}
    #SBATCH --partition=cryoem
    #SBATCH --qos=vip_m2
\end{verbatim}
to indicate that we will use our dedicated \texttt{cryoem} partition and our dedicated queue \texttt{vip\_m2}. In \texttt{simple\_clusterSpecs.pm} there is also a template available for PBS
\begin{verbatim}
    ####################################################################
    # DEFINES DISTRIBUTED EXECUTION ON THE MASSIVE 1 CLUSTER           #
    ####################################################################
    our%MASSIVE_DISTR_ENV;
    $MASSIVE_DISTR_ENV{'SUBMITCMD'}='qsub';
    $MASSIVE_DISTR_ENV{'SCRIPT'}="#!/bin/bash
    #PBS -N $NAME_DISTR
    #PBS -l nodes=1:ppn=<<<NTHR>>>,mem=<<<MEMSTR>>>
    #PBS -l walltime=<<<HOURS>>>:<<<MINUTES>>>:0
    #PBS -o outfile.\$PBS_JOBID
    #PBS -e errfile.\$PBS_JOBID
    cd <<<EXECDIR>>> 
    <<<CMDSTRING>>> fromp=<<<START>>> top=<<<STOP>>> part=<<<PART>>>&
    &nthr=<<<NTHR>>> outfile=$ALGNDOC_FBODY<<<PART>>>.txt > OUT<<<PART>>>\nexit\n";
    $MASSIVE_DISTR_ENV{'SHMEMSCRIPT'}="#!/bin/bash
    #PBS -N $NAME_SHMEM_DISTR
    #PBS -l nodes=1:ppn=<<<NTHR>>>,mem=<<<MEMSTR>>>
    #PBS -l walltime=<<<HOURS>>>:<<<MINUTES>>>:0
    #PBS -o outfile.\$PBS_JOBID
    #PBS -e errfile.\$PBS_JOBID
    cd <<<EXECDIR>>> 
    <<<CMDSTRING>>> nthr=<<<NTHR>>> > SHMEMJOBOUT\nexit\n";
\end{verbatim}
but PBS does not provide any means to bind a set of threads to a particular socket. However, by utilising the \texttt{mpirun} command we can enforce this desired behaviour as exemplified below
\begin{verbatim}
    ####################################################################
    # DEFINES DISTRIBUTED EXECUTION ON SUSANS CLUSTER IN OXFORD        #
    ####################################################################
    our%OXFORD_DISTR_ENV;
    $OXFORD_DISTR_ENV{'SUBMITCMD'}='qsub';
    $OXFORD_DISTR_ENV{'SCRIPT'}="#!/bin/bash
    #PBS -N $NAME_DISTR
    #PBS -l nodes=1:ppn=<<<NTHR>>>,mem=<<<MEMSTR>>>
    #PBS -l walltime=<<<HOURS>>>:<<<MINUTES>>>:0
    #PBS -o outfile.\$PBS_JOBID
    #PBS -e errfile.\$PBS_JOBID
    #PBS -V
    #PBS -l naccesspolicy=UNIQUEUSER
    cd <<<EXECDIR>>> 
    mpirun -np 1 --bind-to-socket --cpus-per-proc <<<NTHR>>> <<<CMDSTRING>>>&
    &fromp=<<<START>>> top=<<<STOP>>> part=<<<PART>>> nthr=<<<NTHR>>>&
    &outfile=$ALGNDOC_FBODY<<<PART>>>.txt > OUT<<<PART>>>\nexit\n";
    $OXFORD_DISTR_ENV{'SHMEMSCRIPT'}="#!/bin/bash
    #PBS -N $NAME_SHMEM_DISTR
    #PBS -l nodes=1:ppn=<<<NTHR>>>,mem=<<<MEMSTR>>>
    #PBS -l walltime=<<<HOURS>>>:<<<MINUTES>>>:0
    #PBS -o outfile.\$PBS_JOBID
    #PBS -e errfile.\$PBS_JOBID
    #PBS -V
    #PBS -l naccesspolicy=UNIQUEUSER
    cd <<<EXECDIR>>> 
    mpirun -np 1 --bind-to-socket --cpus-per-proc <<<NTHR>>> <<<CMDSTRING>>>&
    &nthr=<<<NTHR>>> > SHMEMJOBOUT\nexit\n";
\end{verbatim}
Once our environment for distributed execution is established we use the {Program: \prgname{distr\_simple.pl}}, which supports distributed execution of the programs:
\begin{verbatim}
    simple_prime2D
    simple_prime3D
    simple_eo_recvol
    simple_recvol
    simple_simemimgs
\end{verbatim}
We normally let \prgname{distr\_simple.pl} run in the background on the login node of our cluster. We will discuss the execution routes in more detail in the \texttt{Workflows} section but an example of how to distribute \prgname{simple\_prime2D} using ten nodes is provided below. In order to reduce I/O latency we split the CTF phase-flipped image stack into as many partitions (\texttt{npart}) as we plan to execute
\begin{verbatim}
     $ simple_stackops stk=my_phaseflipped_ptcls.mrc split=npart
\end{verbatim}
Then, we are ready to execute in distributed mode
\begin{verbatim}
     $ nohup distr_simple.pl prg=prime2D npart=10 stk=ptcls.mrc smpd=1.77 msk=100
     ncls=600 refs=startcavgsmsk.mrc oritab=prime2D_startdoc.txt >> PRIME2DOUT &
\end{verbatim}
Another option available on clusters that use the SLURM scheduler is to use the \texttt{srun} command for \prgname{distr\_simple.pl} via
\begin{verbatim}
    $ srun --ntasks=1 --ntasks-per-socket=1 --cpus-per-task=1 --mem=200 --time=2-0:0:0
    --output=PRIME2DOUT.%j --error=PRIME2DERR.%j distr_simple.pl prg=prime2D 
    npart=10 stk=ptcls.mrc smpd=1.77 msk=100 ncls=600 refs=startcavgsmsk.mrc 
    oritab=prime2D_startdoc.txt &
\end{verbatim}
However, beta testers have reported that srun job sometimes dies with no warning, possibly because of the low tolerance for network errors. A more robust route may be to use \texttt{sbatch} as follows
\begin{verbatim}
    $ sbatch -p MYCLUSTER --wrap="distr_simple.pl prg=prime2D npart=10 stk=ptcls.mrc
    smpd=1.77 msk=100 ncls=600 refs=startcavgsmsk.mrc oritab=prime2D_startdoc.txt 
    >> PRIME2DOUT"
\end{verbatim}
where the \texttt{--wrap} flag automatically generates a bash script for the given command.

\subsection{CTF phase flipping}
\label{ctfflip}
SIMPLE uses the same CTF convention as CTFFIND\citep{Mindell:2003aa} and Frealign\citep{Grigorieff:2007aa} with the exception that defocus values are inputted in microns rather than Angstroms. The astigmatism angles are in units of degree. If you have a particle stack of uncorrected windowed single-particle images and you wish to multiply them with the sign of the CTF (phase flipping), please create a text file looking like
\begin{verbatim}
    dfx=2.56 dfy=2.76 angast=30.5
    dfx=3.50 dfy=3.33 angast=60.0
    dfx=1.98 dfy=2.02 angast=120.5
    ...
\end{verbatim}
with the same number of lines as the number of images in the stack, so that there is a one-to-one correspondence between each line of CTF parameters in the text file and each particle image in the stack. Now, use the program \prgname{simple\_stackops} to phase flip the stack
\begin{verbatim}
    $ simple_stackops stk=ptcls.mrc smpd=2 deftab=ctfparams.txt 
    ctf=flip kv=300 cs=2.7 fraca=0.07 outstk=ptcls_phflip.mrc
\end{verbatim}
and use the corrected stack \texttt{ptcls\_phflip.mrc} as input for the remaining workflows. Save the \texttt{ctfparams.txt} file somewhere safe, you might need it for future Wiener restoration in the refinement.

\subsection{2D alignment/clustering with PRIME2D}
\label{prime2D}
\begin{wrapfigure}{l}{0.4\textwidth}
\includegraphics[keepaspectratio=true,scale=0.3]{./PRIME2D_wflows/wflows}
\caption{PRIME-2D workflows}
\end{wrapfigure}
We provide a solver for the problem of simultaneous alignment and clustering of cryo-EM images (SAC) implemented in the program \prgname{simple\_prime2D}. It is assumed that you have a SPIDER or MRC stack of phase flipped particle images (see section \ref{ctfflip} above). The flowcharts of the workflows involving \prgname{simple\_prime2D} are depicted in Figure 2. There are two modes of execution: plain "2D alignment/clustering", assuming that you have a clean and nice data set with not too much junk, such as ice contaminations or particle aggregations. You begin executing \prgname{simple\_prime2D\_init} to produce the files \texttt{startcavgsmsk.mrc} and \texttt{prime2D\_startdoc.txt} containing the random references and random clustering solution. These files are are next used as input to \prgname{simple\_prime2D}. However, if you are planning on executing SIMPLE on a multi-socket workstation or cluster using \prgname{distr\_simple.pl} you have to split the stack into as many partitions (nodes) you are planning to run your job on. This step is necessary for reducing I/O latency. On single-socket machines it is not necessary to split the stack. Next, the generated files are inputted to \prgname{simple\_prime2D} together with the particle stack and a few control parameters, such as sampling distance (\texttt{smpd}), mask radius in pixels (\texttt{msk}), number of desired clusters (\texttt{ncls}) and low-pass limit (\texttt{lp}). The default low-pass limit is set to \texttt{lp=20 \AA{}} which ought to be suitable for all particles with a molecular weight above 300 kDa. You may have to include higher frequency components to obtain a good clustering solution for smaller molecules but beware of the problem of overfitting. If too much high-frequency information is included in the search, the solution obtained may be dominated by noise.

We also provide a "cleanup" workflow for processing of more challenging data sets. Perhaps your particles were automatically boxed and the stack includes a lot of false positives, such as ice contaminations, particle aggregations, hole edges etc. The first part of the "cleanup" workflow is identical to the original workflow. Next, the final class averages obtained with the first pass of clustering are ranked according to decreasing population with \prgname{simple\_rank\_cavgs} and a GUI (we use EMAN\citep{Ludtke:1999aa,Tang:2007aa}) is used to remove unwanted class averages. The program \prgname{simple\_map2ptcls} is then applied to map your manual selection of class averages back to the particle images. The selection is communicated via a text document named \texttt{mapped\_ptcls\_params.txt} by default. Every particle image receives a state assignment of one by default (\texttt{state=1}) and the particles corresponding to deleted class averages are assigned a state label of zero (\texttt{state=0}) in the outputted document. This prevents them from being considered in future processing steps. In order to obtain a "clean" clustering solution, execute the original workflow again but now inputting the \texttt{mapped\_ptcls\_params.txt} document to the \prgname{simple\_prime2D\_init} initialiser in order to propagate the selection. 

\subsection{\textit{Ab initio} 3D reconstruction with PRIME3D}
\label{prime3D}
\begin{wrapfigure}{l}{0.4\textwidth}
\includegraphics[keepaspectratio=true,scale=0.4]{./PRIME3D_wflows/abinitio_wflow}
\caption{PRIME-3D \textit{ab initio} workflow}
\end{wrapfigure}
We provide an \textit{ab initio 3D} reconstruction algorithm that operates either on class averages or on individual particle images. For small data sets (<10,000) images it is usually a better idea to skip the 2D alignment/clustering step and go directly to PRIME3D. For larger data sets or data sets with a lot of contaminations, such as ice, particle aggregations etc. we advice running PRIME2D first in "cleanup" mode and calculating an \textit{ab initio} map from "clean" class averages. The 3D PRIME algorithm is implemented in the program \prgname{simple\_prime3D}. It is assumed that you have a SPIDER or MRC stack of class averages (see section \ref{prime2D}) or phase flipped particle images (see section \ref{ctfflip}). The flowchart for the PRIME3D \textit{ab initio} reconstruction workflow is depicted in Figure 3. You begin executing \prgname{simple\_prime3D\_init} to produce the files \texttt{startvol\_state1.mrc} and \texttt{prime3D\_startdoc.txt} containing the initial random reference and the orientations used to obtain it. These files are are next used as input to \prgname{simple\_prime3D}. However, if you are planning on executing SIMPLE on a multi-socket workstation or cluster using \prgname{distr\_simple.pl} you have to split the stack into as many partitions (nodes) you are planning to run your job on. This step is necessary for reducing I/O latency. On single-socket machines it is not necessary to split the stack. Next, the generated files are inputted to \prgname{simple\_prime3D} together with the particle stack and a few control parameters, such as sampling distance (\texttt{smpd}) and mask radius in pixels (\texttt{msk}). Details about how to run PRIME3D and how the initial low-pass limit is set and how it is updated throughout a PRIME3D run is described in the \prgname{simple\_prime3D} section, below. To check the automatically determined low-pass limit range, use the \prgname{simple\_resrange} program.

\subsection{Worked-out example on GroEL}

To further illustrate how to use the SIMPLE suite of programs, we provide the following comprehensive worked-out example, including all commands executed when reconstructing the D7 symmetric GroEL chaperonin. The same workflow was used to process a series of experimental datasets with high, low or no symmetry, described in our recent paper \citep{reboul2016stochastic}. The workflow consists of four major steps
\begin{enumerate}
\item 2D alignment and clustering of the images using \prgname{simple\_prime2D}
\item asymmetric 3D reconstruction from the class averages using \prgname{simple\_prime3D}
\item symmetrisation of the volume using \prgname{simple\_symsrch}
\item refinement of the symmetrised volume using \prgname{simple\_prime3D}
\end{enumerate}
The data set consisted of 10,000 phase flipped images with 140x140 pixels dimension, randomly selected from a larger publicly available data set \citep{Stagg:2008aa}. Throughout the different steps of the workflow we used a a circular mask radius of \texttt{msk=60} pixels and sampling distance of \texttt{smpd=1.62}.

\subsubsection{2D alignment and clustering of the images}
\label{2dclust}

Prior to 2D alignment and clustering, we begin by minimising the effect that off-centre particles could have on the subsequent steps. The method is not aimed at determining the rotational origin shifts exactly but only to roughly centre the particles in the box. This is done by bringing all particle images into broad register with respect to their 2D shifts only, regardless of their in-plane rotation. \prgname{simple\_stackops} with the argument \texttt{shalgn=yes} is used, providing our stack (\texttt{stk=particles.spi}), sampling distance (\texttt{smpd=1.62}) and mask radius in pixels (\texttt{msk=60} as input
\begin{verbatim}
    $ simple_stackops stk=particles.spi smpd=1.62 msk=60 
    shalgn=yes trs=3.5 lp=20 nthr=8 outstk=particles_sh.spi
\end{verbatim}
The shift alignment is done with a hard low-pass limit of 20 \AA{} (\texttt{lp=20}), as are most of the following steps. The iterative process will typically take a dozen iterations (a few minutes). The \texttt{trs} argument limits the shift search to the $[-trs,trs]$ range. We typically set the \texttt{trs} argument to 2.5\% of the image dimension (140). There are 8 CPUs on our machine so we set the number of threads \texttt{nthr=8}. A new centred stack (named according to the \texttt{outstk} argument) will be written to disk and we will use this one for the reminder of the workflow. A document named \texttt{shiftdoc.txt} by default that contains the calculated shifts is also created.

Next we generate random class averages to initiate the 2D clustering procedure. Given the modest size of our dataset (10,000 images) we choose \texttt{ncls=200} to obtain sufficiently populated classes. We recommended increasing this number to at least 500 for larger datasets (>30,000 images).
\begin{verbatim}
    $ simple_prime2D_init stk=particles_sh.spi smpd=1.62 msk=60 ncls=200 nthr=8
\end{verbatim}
\prgname{simple\_prime2D\_init} will rapidly generate evenly populated class averages with random in-plane rotations. The stacks of 200 class averages are named \texttt{startcavgsmsk.spi} and \texttt{startcavgs.spi} (with and without mask). Next, we execute the 2D alignment and clustering in distributed mode
\begin{verbatim}
    $ simple_stackops stk=particles_sh.spi split=1
    $ nohup distr_simple.pl prg=prime2D stk=particles_sh.spi
    oritab=prime2D_startdoc.txt refs=startcavgsmsk.spi ncls=200
    srch_inpl=yes smpd=1.62 msk=60 lp=20 npart=1 > PRIME2DOUT &
\end{verbatim}
The first instruction prepares the split stack for distributed execution. In our case we ran the clustering on a Linux workstation with 1 CPU chipset so we simply set \texttt{split=1}. If your machine has two chipsets, set split to 2 but keep in mind that the \texttt{npart} argument in the following instruction also needs to be set to 2. The second instruction starts the actual 2D clustering using the randomised classes as a starting point (\texttt{refs} argument). It will take approximately 15 iterations and little under 2 hours on a modern workstation with 8 CPUs. In the last lines of the log file \texttt{PRIME2DOUT} you should see something looking like
\begin{verbatim}
    >>> DISTRIBUTION OVERLAP:                 0.9589
    >>> PERCENTAGE OF SEARCH SPACE SCANNED:  99.6
    >>> CORRELATION:                          0.7521
    >>> CONVERGED: .YES.
\end{verbatim}
Our criterion for convergence is based the stability of the clusters obtained. In other words, when the cluster assignments are nearly identical from one iteration to the next (distribution overlap  >95\% on average) and the particles cannot find a better matching average (fraction of search space scanned >99\%) the alignment and clustering stops. In addition, each run is structured as follows. Until near convergence (search space scanned <90\%) only cluster assignment and in-plane rotations are searched. After this, shifts are also searched and their limit is automatically set to 2.5\% of the image dimension (see above). Every iteration produces a folder named \texttt{prime2D\_round\_XX} that contains all the information to continue a run: a document with the current in-plane parameters (\texttt{prime2Ddoc\_XX.txt}) and two stacks of the current 200 class averages (masked and unmasked).

A number of temporary files are also created but they are only used internally and will be automatically deleted at the end of the run. As computer and network failures are part of using workstations and supercomputers you will be able to continue an interrupted run using the files present in these self-contained folders. You can also automatically remove the temporary files by simply typing: \prgname{prime\_cleanup.pl}. Never do this while the application is running.  It is also necessary to keep the current folder organised to avoid data loss and confusion. We do not need the split stack anymore, so type
\begin{verbatim}
    $ rm stack_part*.spi
\end{verbatim}
Visual examination of the 200 class averages (\texttt{prime2D\_round\_15/cavgs\_iter15.spi}) shows numerous images with distinctive features of GroEL such as the double ring structure and the heptameric C-symmetric rings on a uniform grey background. One can also note blurrier images with less contrast. Typically, these correspond to lowly populated classes where the weaker SNR is likely to contribute little to the subsequent 3D reconstruction. Consequently, we rank the class averages by decreasing order of their population
\begin{verbatim}
    $ simple_rank_cavgs stk=prime2D_round_15/cavgs_iter15.spi 
    oritab=prime2D_round_15/prime2Ddoc_15.txt outstk=ranked_cavgs.spi
\end{verbatim}
After visual inspection of the ranked class averages (we use EMAN for this \citep{Ludtke:1999aa,Tang:2007aa}) we decide to discard the noisier/blurrier images by keeping the first 160 averages in the ranked stack. This discards clusters containing less than 30 images per class. We simply extract the top 160 averages using the command
\begin{verbatim}
    $ simple_stackops stk=ranked_cavgs.spi fromp=1 top=160 outstk=selected_cavgs.spi
\end{verbatim}
where \texttt{fromp} and \texttt{top} define the range of images to keep. With this reduced stack (\texttt{selected\_cavgs.spi}) we will generate an \textit{ab initio} 3D reconstruction of the molecule using \prgname{simple\_prime3D}

\subsubsection{\textit{Ab initio} 3D reconstruction}

We first need a random volume to initiate the search of the five in-plane and out-of-plane parameters of our selected class averages. As in the previous 2D analysis, we execute
\begin{verbatim}
    $ simple_prime3D_init stk=selected_cavgs.spi smpd=1.62 msk=60 nthr=8 lp=20
\end{verbatim}
Consistently with section \ref{2dclust}, we use a low-pass limit of 20 \AA{} (\texttt{lp=20}). This command will generate two files: a volume reconstructed from random orientation parameters (\texttt{startvol\_state1.spi}) and the document containing these parameters (\texttt{prime3D\_startdoc.txt}). We start the search with
\begin{verbatim}
    $ simple_stackops stk=selected_cavgs.spi split=1
    $ nohup distr_simple.pl prg=prime3D stk=selected_cavgs.spi 
    vol1=startvol_state1.spi smpd=1.62 msk=60 lp=20 
    oritab=prime3D_startdoc.txt npart=1 > PRIME3DOUT &
\end{verbatim}
Again, we first split the stack for distributed execution. Then, we run PRIME3D providing the randomised orientations (\texttt{oritab} argument) and volume (\texttt{vol1} argument) that we have just prepared. After approximately 16 iterations the run converges. At the end of PRIME3DOUT you will find
\begin{verbatim}
    >>> ANGLE OF FEASIBLE REGION:            14.1
    >>> AVERAGE ANGULAR DISTANCE BTW ORIS:    2.4 
    >>> PERCENTAGE OF SEARCH SPACE SCANNED: 100.0
    >>> CORRELATION:                          0.9178
    >>> ANGULAR SDEV OF MODEL:               40.81
    >>> UPDATE LOW-PASS LIMIT: .NO.
    >>> CONVERGED: .YES.
\end{verbatim}
The \texttt{recvol\_state1.spi} volume and the corresponding orientation parameters (\texttt{prime3Ddoc\_16.txt}) are produced in the \texttt{prime3D\_round\_16} folder. The volume is blobby but still captures the overall shape of GroEL. Keep in mind that we have so far made no assumption about symmetry and the volume has been reconstructed in the C1 symmetry group.

\subsubsection{Symmetrisation of the volume}

In order to symmetrise the volume, we need to identify the principal axis of symmetry given the known D7 point-group symmetry group of GroEL. This is done with \prgname{simple\_symsrch}, given the C1 volume and orientation parameters (\texttt{vol1} and \texttt{oritab}) and using the same low-pass limit as previously (\texttt{lp=20}). The symmetrised orientations are outputted in the text file \texttt{sym\_d7.txt} (\texttt{outfile} argument). We identify the principal symmetry axis of the volume by executing 
\begin{verbatim}
    $ simple_symsrch vol1=prime3D_round_16/recvol_state1.spi smpd=1.62 msk=60 
    oritab=prime3D_round_16/prime3Ddoc_16.txt pgrp=d7 outfile=sym_d7.txt nthr=8 
    lp=20 > SYMOUT
\end{verbatim}
The program prints the identified symmetry axis
\begin{verbatim}
    >>> FOUND SYMMETRY AXIS ORIENTATION:
    e1=276.596588 e2=80.9958649 e3=297.840454 x=0.00000000 y=0.00000000 
    mi=0.00000000 mi_hard=0.00000000 dist=180.000000 state=1.00000000 
    corr=0.787599325 w=1.00000000 class=1.00000000 mirr=0.00000000 frac=0.00000000
\end{verbatim}
and we use \prgname{simple\_eo\_recvol} to reconstruct a symmetrised volume
\begin{verbatim}
    $ simple_eo_recvol stk=selected_cavgs.spi 
    oritab=sym_d7.txt smpd=1.62 msk=60 nthr=8 pgrp=d7
\end{verbatim}
Output is the optimal principal axis of symmetry (\texttt{e1}, \texttt{e2} and \texttt{e3} are the phi,theta and psi angles) along with its correlation (\texttt{corr}). It is likely that you will obtain different values for the axis of symmetry upon different runs. This is because of the stochastic nature of the 2D/3D analyses, which cause the 3D reconstruction to be arbitrarily oriented with respect to the principal symmetry axis. Nonetheless, the final volume is reproducible and captures the structure of GroEL as judged by the numerous existing crystallographic and EM structures.

With the new symmetrised orientation parameters of the class averages we now want to map this information back to the individual particle images. To do this we first create a text file called \texttt{doclist.txt} that contains a single line
\begin{verbatim}
    $ ls -1 sym_d7.txt > doclist.txt
\end{verbatim}
and then map the orientation parameters of the class averages to the particles (\texttt{stk}) by providing the selected class averages (\texttt{stk2}), all the original class averages (\texttt{stk3}) and the in-plane parameters obtained in the first \prgname{simple\_prime2D} run (\texttt{oritab}) to the program \prgname{simple\_map2ptcls}
\begin{verbatim}
    $ simple_map2ptcls stk=particles_sh.spi stk2=selected_cavgs.spi 
    stk3=cavgs_iter16.spi oritab=prime2D_round_16/prime2Ddoc_16.txt 
    doclist=doclist.txt nthr=8
\end{verbatim}
Next we reconstruct a symmetrised volume from the particles using the mapped orientation parameters (called \texttt{mapped\_ptcls\_params.txt} by default) and specifying the symmetry group (\texttt{pgrp=d7})
\begin{verbatim}
    $ simple_eo_recvol stk=particles_sh.spi oritab=mapped_ptcls_params.txt 
    smpd=1.62 msk=60 nthr=8 pgrp=d7
\end{verbatim}
After several minutes we obtain a new volume (\texttt{recvol\_state1msk.spi}) and its resolution
\begin{verbatim}
    >>> RESOLUTION AT FSC=0.143 DETERMINED TO:  12.60
    >>> RESOLUTION AT FSC=0.500 DETERMINED TO:  17.45
\end{verbatim}
As \texttt{recvol\_state1msk.spi} is the default name used internally by \prgname{simple\_prime3D} it is best to rename it to avoid having it overwritten
\begin{verbatim}
    $ mv recvol_state1msk.spi sym_recvol_state1msk.spi
\end{verbatim}
\prgname{simple\_eo\_recvol} and \prgname{simple\_prime3D} also produce a file \texttt{fsc\_state1.bin} that contains the FSC plot. Make sure to backup this file as  \prgname{simple\_prime3D} will overwrite it if executed in the same folder. Here we just copy it because in the next step we will refine the volume and  \prgname{simple\_prime3D}  will require the information contained in \texttt{fsc\_state1.bin} to initiate the refinement
\begin{verbatim}
    $ cp fsc_state1.bin eo_fsc_state1.bin
\end{verbatim}

\subsubsection{Refinement of the symmetrised volume using \prgname{simple\_prime3D}}

Finally, we refine our initial model while applying D7 symmetry with  \prgname{simple\_prime3D}
\begin{verbatim}
    $ simple_stackops stk=particles_sh.mrc split=8
    $ nohup distr_simple.pl prg=prime3D stk=groel-stk.spi
    vol1=sym_recvol_state1msk.spi smpd=1.62 msk=60 
    eo=yes oritab=mapped_ptcls_params.txt npart=8 > 
    PRIME3DOUT2 &
\end{verbatim}
With the first instruction we split the stack for distributed execution. Here the refinement run will be split over 8 different CPU sockets on a Linux cluster (\texttt{split=8}; see Section \ref{paraexec} for more details). We use PRIME3D differently this time. Instead of setting a 20 \AA{} low-pass limit, the resolution of the volume is calculated automatically at every iteration (\texttt{eo=yes}) and we are starting from our symmetrised volume (\texttt{vol1=sym\_recvol\_state1msk.spi}). After the 10 iterations required for convergence, the final resolution  (better than 8 \AA{}) is printed in the end of the \texttt{PRIME3DOUT2} output (and also stored in the \texttt{fsc\_state1.bin}). Examination of the volume shows helical features consistent with the GroEL X-ray structure.
\begin{verbatim}
    >>> RESOLUTION AT FSC=0.143 DETERMINED TO:   7.32
    >>> RESOLUTION AT FSC=0.500 DETERMINED TO:   8.10
\end{verbatim}
\textbf{A note on overfitting:} In contrast to most other packages, the only exception being Frealign, SIMPLE does all of its interpolations and correlation calculations in the Fourier domain. Other packages may argue that they do as well but there are subtle important differences. For example, Spider, EMAN and SPARX interpolate polar coordinates in real space and then calculate one-dimensional Fourier transforms along concentric rings to obtain their "polar Fourier transforms", which are in fact polar real images. The advantage of doing it in this way is that you can use a hard mask in real space and avoid including too much background noise in the representation. However, the fundamental disadvantage is that you loose the ability to control which Fourier components are being used for the matching. Initially, it was assumed that the low-pass filtering of the volume based on the FSC ought to be sufficient to avoid overfitting. This has proven not to be true with this kind of representation, as both EMAN2 and SPARX now implement the "gold-standard approach". We instead use gridding interpolation \textit{in Fourier space} to obtain our polar central sections. The minor disadvantage is that we have to apply a soft-edged mask in real space and risk introduce slightly more background noise in the representation. However, the major advantage is that we can control exactly which Fourier components we use for matching. The default high-pass limit is set to Fourier index 2 but if you think you have a lot of inelastic scattering at low resolution (this is typical for icosahedral viruses) you may want to change the high-pass limit via \texttt{hp=X \AA{}}. The hard low-pass limit, when \prgname{simple\_prime3D} is executed with \texttt{eo=yes} is set according to the \texttt{FSC=0.143} criterion. We have yet to detect any overfitting visually or using the noise substitution test \citep{Chen:2013aa} with this approach on standard EM data obtained with the underfocusing approach. However, while processing close-to-focus phase plate data we have observed severe overfitting and we recommend to battle it using hard low-pass limitation with \texttt{lpstop=X \AA{}}. If you do all your analyses with a hard  low-pass limit of \texttt{X} and the resolution extends significantly beyond the limit, there should be no reason to worry about overfitting.

\section{Individual SIMPLE programs}

\subsection{2D alignment/clustering}

\subsubsection{Program: \prgname{simple\_prime2D\_init}}
\label{prime2D_init}
\prgname{simple\_prime2D\_init} is a program for initialising prime2D. We use it to produce the initial random references when executing \prgname{simple\_prime2D}.
\begin{verbatim}
    $ SIMPLE_PRIME2D_INIT stk=<stack.ext> smpd=<sampling distance(in A)> msk=<mask}
    radius(in pixels)> ncls=<nr of clusters> [nthr=<nr of OpenMP threads{1}>]
    [oritab=<input doc>]
\end{verbatim}
\noindent\textbf{Comments:} The program assumes that the images have been phase-flipped, as no CTF correction by Wiener restoration is implemented yet. The random clustering and in-plane alignment will be printed in the file \texttt{prime2D\_startdoc.txt} produced by the program. This file is used together with the initial references (\texttt{startcavgsmsk.ext}) to execute \prgname{simple\_prime2D}.

\subsubsection{Program: \prgname{simple\_prime2D}}
\label{prime2D}
\prgname{simple\_prime2D} is a reference-free 2D alignment/clustering algorithm adopted from the prime3D probabilistic \textit{ab initio} 3D reconstruction algorithm. It is assumed that the images are phase-flipped (phase flipping can be done with \prgname{simple\_stackops}). Do \textit{not} search the origin shifts initially, when the cluster centers are of low quality. If your images are far off centre, use \prgname{simple\_stackops} with option \texttt{shalgn=yes} instead to shiftalign the images beforehand (the algorithm implemented is the same as EMAN's \texttt{cenalignint} program). Use \prgname{distr\_simple.pl} for distributed PRIME2D execution.
\begin{verbatim}
    $ SIMPLE_PRIME2D stk=<stack.ext> smpd=<sampling distance(in A)> msk=<mask}
    radius(in pixels)> ncls=<nr of clusters> refs=<initial_references.ext>
    oritab=<previous clustering doc> [lp=<low-pass limit(in A){20}>] [trs=<origin
    shift(in pixels){0}>] [nthr=<nr of OpenMP threads{1}>] [startit=<start
    iteration>] [hp=<high-pass limit(in A)>] [srch_inpl=<yes|no{yes}>]
    ** less commonly used **
    [maxits=<max iterations{500}>] [inner=<inner mask radius(in pixels)>]
    [width=<pixels falloff inner mask(in pixels){10}>]
\end{verbatim}

\subsubsection{Program: \prgname{simple\_rank\_cavgs}}
\label{rank_cavgs}
\prgname{simple\_rank\_cavgs} is a program for ranking class averages by decreasing population, given the stack of class averages (\texttt{stk} argument) and the 2D orientations document (\texttt{oritab}) generated by \prgname{simple\_prime2D}.
\begin{verbatim}
    $ SIMPLE_RANK_CAVGS stk=<cavgs.ext> oritab=<2D clustering doc> [outstk=<ranked}
    cavgs stack>]
\end{verbatim}

\subsubsection{Program: \prgname{simple\_map2ptcls}}
\label{map2ptcls}
\prgname{simple\_map2ptcls} is a program for mapping parameters that have been obtained using class averages to the individual particle images. There are many functionalities present that will become critical in future releases. Right now we recommend using this program exclusively to exclude the particles corresponding to deselected class averages. See the workflows section of the manual for further info.
\begin{verbatim}
    $ SIMPLE_MAP2PTCLS stk=<particles.ext> stk2=<selected_cavgs.ext>}
    stk3=<orig_cavgs.ext> oritab=<PRIME 2D doc> [oritab2=<prime3D shc doc>]
    [comlindoc=<shc_clustering_nclsX.txt>] [doclist=<list of oritabs for the
    different states>] [deftab=<text file defocus values>] [outfile=<output
    parameter file{mapped_ptcls_params.txt}>] [nthr=<nr of OpenMP
    threads{1}>]
\end{verbatim}

\subsubsection{Program: \prgname{simple\_doc2cavgs}}
\label{doc2cavgs}
\prgname{simple\_doc2cavgs} is a program for generating class averages. We use it to to re-generate class averages when \prgname{simple\_prime2d} has been run on downscaled images. If the images processed with PRIME2D were downscaled from 200x200 to 100x00, set \texttt{mul=2}.
\begin{verbatim}
    $ SIMPLE_DOC2CAVGS stk=<stack.ext> smpd=<sampling distance(in A)> msk=<mask}
    radius(in pixels)> ncls=<nr of clusters> oritab=<previous clustering doc>
    which_iter=<iteration nr> [mul=<shift multiplication factor{1}>] [nthr=<nr
    of OpenMP threads{1}>]
\end{verbatim}
\noindent\textbf{Comments:} The program assumes that the images have been phase-flipped, as no CTF correction by Wiener restoration is implemented yet.

\subsection{\textit{Ab initio} 3D reconstruction}

\subsubsection{Program: \prgname{simple\_resrange}}
\label{resrange}
\prgname{simple\_resrange} is a program for estimating the resolution range used in the heuristic resolution-stepping scheme in the PRIME3D initial model production procedure. The initial low-pass limit is set so that each image receives ten nonzero orientation weights. When quasi-convergence has been reached, the limit is updated one Fourier index at the time, until PRIME reaches the condition where six nonzero orientation weights are assigned to each image. FSC-based filtering is unfortunately not possible to do in the \textit{ab initio} reconstruction step, because when the orientations are mostly random, the FSC overestimates the resolution. This program is used internally by \prgname{distr\_simple.pl} when executing PRIME in distributed mode. We advise you to check the starting and stopping low-pass limits before executing PRIME3D using this program.
\begin{verbatim}
    $ SIMPLE_RESRANGE smpd=<sampling distance(in A)> [nspace=<nr of reference}
    sections{1000}>] [pgrp=<cn|dn|t|o|i{c1}>] [box=<image size(in pixels)>]
    [moldiam=<molecular diameter(in A))>]
\end{verbatim}
\noindent\textbf{Comments:} The resolution range estimate depends on the molecular diameter, which is estimated based on the box size. If you want to override this estimate, set \texttt{moldiam} to the desired value (in \AA{}). This may be necessary if your images have a lot of background "padding". However, for starting model generation it is probably better to clip the images snugly around the particle, because smaller images equal less computation.

\subsubsection{Program: \prgname{simple\_prime3D\_init}}
\label{prime3D_init}
\prgname{simple\_prime3D\_init} is a program for generating a random initial model for initialisation of PRIME3D when executed in distributed mode. It is assumed that the images have been phase flipped. If the data set is large (>5000 images), generating a random model can be quite slow. To speedup, set \texttt{nran} to some smaller number, resulting in \texttt{nran} images selected randomly for reconstruction.
\begin{verbatim}
    $ SIMPLE_PRIME3D_INIT stk=<stack.ext> smpd=<sampling distance(in A)> msk=<mask}
    radius(in pixels)> [nspace=<nr reference sections{1000}>] [nran=<size of
    random sample>] [lp=<low-pass limit(in A)>] [nthr=<nr OpenMP threads{1}>]
    ** less commonly used **
    [pgrp=<cn|dn|t|o|i{c1}>] [npeaks=<nr nonzero orientation weights{1}>]
    [ctf=<yes|no|flip|mul{no}>] [kv=<acceleration voltage(in kV){300.}>]
    [fraca=<frac amp contrast{0.07}>] [cs=<spherical aberration constant(in
    mm){2.7}>] [deftab=<text file with defocus values>] [inner=<inner mask
    radius(in pixels)>] [width=<pixels falloff inner mask{10}>]
    [xfel=<yes|no{no}>]
\end{verbatim}

\subsubsection{Program: \prgname{simple\_prime3D}}
\label{prime3D}
\prgname{simple\_prime3D} is an \textit{ab inito} reconstruction/refinement program based on probabilistic projection matching. PRIME is shorthand for PRobabilistic Initial 3D Model Generation for Single-Particle Cryo-Electron Microscopy. You should use phase-flipped images for initial model production with PRIME3D (phase flipping can be done with \prgname{simple\_stackops}). Do not search the origin shifts initially, when the model is of very low quality. If your images are far off centre, use \prgname{simple\_stackops} with option \texttt{shalgn=yes} instead to shiftalign the images beforehand (the algorithm implemented is the same as EMAN's \texttt{cenalignint} program). We recommend running the first round of PRIME with the default dynamic resolution stepping \texttt{dynlp=yes}. The \texttt{dynlp} option implements a heuristic resolution weighting/update scheme. The initial low-pass limit is set so that each image receives ten nonzero orientation weights. When quasi-convergence has been reached, the limit is updated one Fourier index at the time until PRIME reaches the condition where six nonzero orientation weights are assigned to each image. FSC-based filtering is unfortunately not possible to do in the ab initio reconstruction step, because when the orientations are mostly random, the FSC overestimates the resolution. Once the initial model has converged, we recommend start searching the shifts (by setting \texttt{trs} to some nonzero value), applying the FSC for resolution-weighting (by setting \texttt{eo=yes}). You should NOT give \texttt{ctf=flip} on the command line unless the model has converged. Giving \texttt{ctf=flip} on the command lines signal to PRIME that tou have obtain a reconstruction of decent resolution and you want to take it further by applying Wiener restoration by resolution-weighting the reocnstructed volume more accurately. In order to be able to use Wiener restoration you also need to input CTF parameters, for example via \texttt{deftab=defocus\_values.txt}. Remember that the defocus values should be given in microns and the astigmatism angle in degrees (one row of the file \texttt{defocus\_values.txt} may look like: \texttt{dfx=3.5} \texttt{dfy=3.3} \texttt{angast=20.0}).
\begin{verbatim}
    $ SIMPLE_PRIME3D stk=<stack.ext> vol1=<invol.ext> [vol2=<refvol_2.ext> etc.]}
    smpd=<sampling distance(in A)> msk=<mask radius(in pixels)> [oritab=<previous
    alignment doc>] [trs=<origin shift(in pixels){0}>] [lp=<low-pass
    limit{20}>] [dynlp=<yes|no{yes}>] [nstates=<nstates to reconstruct>]
    [frac=<fraction of ptcls to include{1}>] [mw=<molecular weight(in kD)>]
    [nthr=<nr of OpenMP threads{1}>] [startit=<start iteration>]
    [refine=<no|shc|neigh|shcneigh{no}>] [lpstop=<stay at this low-pass limit (in
    A)>] [deftab=<text file defocus values>] [nspace=<nr reference
    sections{1000}>] [eo=<yes|no{no}>] [amsklp=<automask low-pass limit(in A)>]
    [pgrp=<cn|dn|t|o|i{c1}>] [ctf=<yes|no|flip|mul{no}>] [kv=<acceleration
    voltage(in kV){300.}>] [cs=<spherical aberration constant(in mm){2.7}>]
    [fraca=<frac amp contrast{0.07}>] [hp=<high-pass limit(in A)>]
    [diversify=<yes|no{yes}>] [xfel=<yes|no{no}>]
    ** less commonly used **
    [maxits=<max iterations{100}>] [edge=<edge size for softening molecular
    envelope(in pixels){3}>] [noise=<yes|no{no}>] [npeaks=<number of nonzero
    orientation weights>] [dens=<density(e.g. 9.368 Da/A3 4 gold clusters){0.}>]
    [nvox=<nr of voxels in mask{0}>] [inner=<inner mask radius(in pixels)>]
    [width=<pixels falloff inner mask{10}>]
\end{verbatim}
\noindent\textbf{Comments:} Note that we do not assume any point-group symmetry in the initial runs. However, the \prgname{simple\_symsrch} program can be used to align the reconstruction to its symmetry axis so that future searches can be restricted to the asymmetric unit in refinement. Less commonly used and less obvious input parameters are \texttt{nspace}, which  controls the number of reference projections, \texttt{amsklp}, which controls the low-pass limit used in the automask routine, \texttt{maxits}, which controls the maximum number of iterations executed, \texttt{pgrp}, which controls the point-group symmetry, assuming that the starting volume is aligned to its principal symmetry axis, \texttt{edge}, which controls the size of the softening edge in the automask routine.

\subsubsection{Program: \prgname{simple\_symsrch}}
\label{symsrch}
\prgname{simple\_symsrch} is a program for searching for the principal symmetry axis of a volume reconstructed without assuming any point-group symmetry. Our philosophy is to start off without assuming any symmetry, and then analyzse the reconstructed volume to identify the correct point-group symmetry. \prgname{simple\_symsrch} can be used for this purpose. The program takes as input the asymmetrical reconstruction (obtained with \prgname{simple\_prime3D}), the alignment document for all the particle images that have gone into the reconstruction, and the desired point-group symmetry. It then projects the reconstruction in 20 (default option) even directions, uses common lines-based optimisation to identify the principal symmetry axis, applies the rotational transformation to the inputted orientations, and produces a new alignment document. Input this document to \texttt{simple\_recvol} or \texttt{simple\_eo\_recvol} together with the images and the point-group symmetry to generate a symmetrised map. If you are unsure about the point-group, you should of course test many different point-groups and compare the asymmetric map with the symmetrised maps. SIMPLE now implements most point-groups: c- and d-groups, as well as tetrahedral, octahedral, and icosahedral groups.
\begin{verbatim}
    $ SIMPLE_SYMSRCH vol1=<vol.ext> smpd=<sampling distance(in A)> oritab=<input}
    alignment doc> pgrp=<cn|dn|t|o|i{c1}> outfile=<output alignment doc>
    lp=<low-pass limit(in A)> [amsklp=<low-pass limit for centering mask(in
    A){50}>] [hp=<high-pass limit(in A)>] [nthr=<nr openMP threads{1}>]
    [nspace=<nr of projs{20}>]
\end{verbatim}
\noindent\textbf{Comments:} The \texttt{state} parameter allows you to apply symmetry for the given state.

\subsubsection{Program: \prgname{simple\_recvol}}
\label{recvol}
\prgname{simple\_recvol} is a program for reconstructing volumes from MRC and SPIDER stacks, given input orientations and state assignments (obtained by program \prgname{simple\_prime3D}). The algorithm is based on direct Fourier inversion with a Kaiser-Bessel (KB) interpolation kernel. This window function reduces the real-space ripple artifacts associated with direct moving windowed-sinc interpolation. The feature sought when implementing this algorithm was to enable quick, reliable reconstruction from aligned individual particle images.
\begin{verbatim}
    $ SIMPLE_RECVOL stk=<ptcls.ext> smpd=<sampling distance(in A)>}
    oritab=<algndoc.txt> msk=<mask radius(in pixels)> [lp=<low-pass limit{20}>]
    [frac=<fraction of ptcls to include{1.}>] [nthr=<nr of openMP threads{1}>]
    [pgrp=<cn|dn|t|o|i{c1}>]
    ** less commonly used **
    [mw=<molecular weight(in kD)>] [amsklp=<low-pass limit(in A){20}>]
    [mul=<shift multiplication factor{1}>] [ctf=<yes|no|flip|mul{no}>]
    [kv=<acceleration voltage(in kV){300.}>] [fraca=<frac amp contrast{0.07}>]
    [cs=<spherical aberration constant(in mm){2.7}>] [deftab=<text file defocus
    values>] [state=<state to reconstruct{all}>] [edge=<edge size for softening
    molecular envelope(in pixels){3}>] [dens=<density(e.g.9.368 Da/A3 4 gold
    clusters){0.}>] [inner=<inner mask radius(in pixels)>] [width=<pixels falloff
    inner mask{10}>] [mirr=<yes|no{no}>] [even=<yes|no{no}>]
    [odd=<yes|no{no}>]
\end{verbatim}
\noindent\textbf{Comments:} \texttt{mul} is used to scale the origin shifts if down-sampled were used for alignment and the original images are used for reconstruction. This program can be run in distributed mode using \prgname{distr\_simple.pl}. \texttt{ctf}, \texttt{kv}, \texttt{fraca}, \texttt{cs} and \texttt{deftab} are used to communicate CTF information to the program. \texttt{ctf=yes}, \texttt{ctf=flip} or \texttt{ctf=mul} turns on the Wiener restoration. If the images were pre-multiplied with CTF set \texttt{ctf=mul} or if the images were phase-flipped set \texttt{ctf=flip}. \texttt{amsklp}, \texttt{mw}, and \texttt{edge} are parameters that control the solvent mask: the low-pass limit used to generate the envelope; the molecular weight of the molecule (protein assumed but it works reasonably well also for RNA; slight modification of \texttt{mw} might be needed). The \texttt{inner} parameter controls the radius of the soft-edged mask used to remove the unordered DNA/RNA core of spherical icosahedral viruses. The \texttt{even} and \texttt{odd} parameters allow you to reconstruct either the even or the odd pair.

\subsubsection{Program: \prgname{simple\_eo\_recvol}}
\label{eo_recvol}
\prgname{simple\_eo\_recvol} is a program for reconstructing volumes from MRC or SPIDER stacks, given input orientations and state assignments (obtained by program \prgname{simple\_prime3D}). The algorithm is based on direct Fourier inversion with a Kaiser-Bessel (KB) interpolation kernel. This window function reduces the real-space ripple artefacts associated with direct moving windowed-sinc interpolation. The feature sought when implementing this algorithm was to enable quick, reliable reconstruction from aligned individual particle images. The even and odd pairs are automatically reconstructed, the FSC calculated, and the Wiener filter formalism used for image restoration (CTF correction). Use \prgname{distr\_simple.pl} for distributed execution.
\begin{verbatim}
    $ SIMPLE_EO_RECVOL stk=<ptcls.ext> msk=<mask radius(in pixels)> smpd=<sampling}
    distance(in A)> oritab=<algndoc.txt> [frac=<fraction ptcls to include{1.}>]
    [nthr=<nr openMP threads{1}>] [pgrp=<cn|dn|t|o|i{c1}>]
    ** less commonly used **
    [mul=<shift multiplication factor{1}>] [ctf=<yes|no|flip|mul{no}>]
    [kv=<acceleration voltage(in kV){300.}>] [fraca=<frac amp contrast{0.07}>]
    [cs=<spherical aberration constant(in mm){2.7}>] [deftab=<text file defocus
    values>] [state=<state to reconstruct{all}>] [mw=<molecular weight(in kD)>]
    [amsklp=<low-pass limit(in A){20}>] [edge=<edge size softening molecular
    envelope(in pixels){3}>] [inner=<inner mask radius(in pixels)>]
    [width=<pixels falloff inner mask{10}>]
\end{verbatim}
\noindent\textbf{Comments:} \texttt{mul} is used to scale the origin shifts if down-sampled images were used for alignment and the original images are used for reconstruction. \texttt{ctf}, \texttt{kv}, \texttt{fraca}, \texttt{cs} and \texttt{deftab} are used to communicate CTF information to the program. \texttt{ctf=yes}, \texttt{ctf=flip} or \texttt{ctf=mul} turns on the Wiener restoration. If you input CTF info to the program, please ensure that the correct kV, Cs and fraca (fraction of amplitude contrast) parameters are inputted as well. If the images were pre-multiplied with the CTF, set \texttt{ctf=mul} or if the images were phase-flipped set \texttt{ctf=flip}. \texttt{amsklp} and \texttt{mw} parameters control the solvent mask: the low-pass limit used to generate the envelope; the molecular weight of the molecule (protein assumed but it works reasonably well also for RNA; slight modification of \texttt{mw} might be needed). The \texttt{inner} parameter controls the radius of the soft-edged mask used to remove the unordered DNA/RNA core of spherical icosahedral viruses.

\subsection{Standard image/volume operations (ops)}

\subsubsection{Program: \prgname{simple\_automask}}
\label{automask}
\prgname{simple\_automask} is a program for solvent flattening of a volume (MRC or SPIDER). The algorithm for background removal is based on low-pass filtering and binarization. First, the volume is low-pass filtered to \texttt{amsklp}. A binary volume is then generated by assigning foreground pixels (=1) based on the volume calculated from the molecular weight, assuming a protein density of 1.43 g/mL. A real-space low-pass filter softens the edge of the resulting binary volume before multiplying it with the unmasked input volume to generate the flattened map.
\begin{verbatim}
    $ SIMPLE_AUTOMASK vol1=<invol.ext> [vol2=<invol2.ext> etc.] smpd=<sampling}
    distance(in A)> [mw=<molecular weight(in kD)>] [amsklp=<low-pass limit(in
    A){20}>] [nthr=<nr of OpenMP threads{1}>]
    ** less commonly used **
    [edge=<edge size for softening molecular envelope(in pixels){3}>]
\end{verbatim}

\subsubsection{Program: \prgname{simple\_converter}}
\label{converter}
\prgname{simple\_converter} is a program for converting between SPIDER and MRC formats.
\begin{verbatim}
    $ SIMPLE_CONVERTER [stk=<input particle stack>] [vol1=<invol.ext>]}
    [outstk=<output particle stack>] [outvol=<outvol.ext>]
\end{verbatim}

\subsubsection{Program: \prgname{simple\_iminfo}}
\label{iminfo}
\prgname{simple\_iminfo} is a program for printing header information in MRC and SPIDER stacks and volumes
\begin{verbatim}
    $ SIMPLE_IMINFO [fname=<filename.ext>] [box=<box size(pixels)>] [smpd=<sampling}
    distance(in A)>] [stats=<yes|no|print{no}>]
\end{verbatim}

\subsubsection{Program: \prgname{simple\_simimgs}}
\label{simimgs}
\prgname{simple\_simimgs} is a program for simulating cryo-EM images. It is not a very sophisticated simulator, but it is nevertheless useful for testing purposes. It does not do any multi-slice simulation and it cannot be used for simulating molecules containing heavy atoms. It does not even accept a PDB file as an input. Input is a cryo-EM map, which we usually generate from a PDB file using EMAN's program \texttt{pdb2mrc}. \prgname{simple\_simimgs} then projects the volume using Fourier interpolation, applies 20\% of the total noise to the images (pink noise), Fourier transforms them, and multiplies them with astigmatic CTF and B-factor. The images are inverse FTed before the remaining 80\% of the noise (white noise) is added.
\begin{verbatim}
    $ SIMPLE_SIMIMGS vol1=<invol.ext> smpd=<sampling distance(in A)> msk=<mask}
    radius(in pixels)> nptcls=<number of particles> snr=<signal2noise ratio>
    [sherr=<shift error(in pixels){2}>] [ctf=<yes|no|flip|mul{yes}>]
    [kv=<acceleration voltage(in kV){300.}>] [fraca=<frac amp contrast{0.07}>]
    [cs=<spherical aberration constant(in mm){2.7}>] [defocus=<defocus(in
    microns){3.0}>] [deferr=<defocus error(in microns){1.0}>]
    [astigerr=<astigmatism error(in microns){0.1}>] [bfac=<bfactor(in
    A**2){0}>] [bfacerr=<bfactor error(in A**2){0}>] [oritab=<input alignment
    doc>] [outfile=<output alignment doc{simoris.txt}>] [outstk=<ouput
    stack{simimgs.ext}>] [nthr=<nr of OpenMP threads{1}>]
\end{verbatim}

\subsubsection{Program: \prgname{simple\_stackops}}
\label{stackops}
\prgname{simple\_stackops} is a program that provides standard single-particle image processing routines that are applied to MRC or SPIDER stacks.
\begin{verbatim}
    $ SIMPLE_STACKOPS [stk=<stack.ext>] [stk2=<stack2.ext>] [nptcls=<nr of imgs>]}
    [smpd=<sampling distance(in A)>] [outstk=<outstk.ext>] [split=<nr of partitions
    to split the stack into>] [oritab=<SIMPLE alignment doc>] [hp=<high-pass
    limit(in A)>](in A)>] [shalgn=<yes|no{no}>] [mul=<shift multiplication
    factor{1}>] [trs=<origin shift halfwidth(in pixels){0}] [lp=<low-pass
    limit(in A){20}>] [state=<state to extract>] [frac=<fraction of ptcls to
    extract{1}>] [class=<cluster2extract>] [snr=<signal2noise ratio>] [msk=<mask
    radius(in pixels){box/2}>] [vis=<yes|no>] [bin=<binarize{no}>]
    [acf=<yes|no{no}>] [phrand=<yes|no{no}>] [fromp=<start ptcl>] [top=<stop
    ptcl>] [nran=<number of random images to select>] [newbox=<scaled box>]
    [scale=<scale factor{1}>] [hfun=<sigm|tanh|lin{sigm}>]
    [norm=<yes|no{no}>] [noise_norm=<yes|no>] [nthr=<nr of openMP threads{1}>]
    [avg=<yes|no>] [filetab=<filenames.txt>] [stats=<yes|no{yes}>]
    [ctf=<yes|no|flip|mul|abs{no}>] [kv=<acceleration voltage(in kV){300.}>]
    [fraca=<frac amp contrast{0.07}>] [cs=<spherical aberration constant(in
    mm){2.7}>] [deftab=<text file with defocus values>] [ft2img=<yes|no{no}>]
    [frameavg=<nr of frames to average{0}>] [clip=<clipped box size{box}>]
    [compare=<yes|no{no}>] [mirr=<no|x|y{no}>] [neg=<yes|no{no}>] [box=<image
    size(in pixels)>] [outfile=<output_params.txt>] [ctfsq=<yes|no{no}>]
    [masscen=<yes|no{no}>] [thres=<threshold4bin[0,1]{0.6}>] [inner=<inner mask
    radius(in pixels)>] [width=<pixels falloff inner mask{10}>]
    [append=<yes|no{no}>]
\end{verbatim}
\noindent\textbf{Comments:} You can do many things with \prgname{simple\_stackops}. Inputting two stacks of the same size results in the calculation of the joint Fourier Ring  Correlation (FRC) between the images. Inputting no stacks, but setting \texttt{nptcls}, results in production of \texttt{nptcls} pure noise images, unless \texttt{ctf=yes}, then CTF images are produced. Filtering is controlled by the \texttt{hp} and \texttt{lp} arguments. If you input an alignment document (via \texttt{oritab}) \texttt{shalgn=yes} will produce a shift-aligned stack based on the inputted orientations, whereas if you do \textit{not} input an alignment document, the alignment will be done in a reference-free manner (remember to set \texttt{trs} to some nonzero value). If you want to centre the images based on their centre of mass, set \texttt{masscen=yes}. If you want to extract a particular state, give an alignment document (\texttt{oritab}) and set \texttt{state} to the state that you want to extract. If you want to select the fraction of best particles (according to the goal function), input an alignment doc (\texttt{oritab}) and set \texttt{frac}. You can combine the \texttt{state} and \texttt{frac} options. If you want to apply noise to images, give the desired signal-to-noise ratio via \texttt{snr}. If you want to mask your images with a spherical mask with a soft falloff, set \texttt{msk} to the radius in pixels. If you want to binarize your images, set \texttt{bin=yes}. If \texttt{thres} is defined, the images are sigmoid normalised to $\in{[0,1]}$ and threshold binarized. If \texttt{thres} is not defined the foreground/background pixels are assigned by sort-means (a variant of the continuous k-means algorithm where the initial centres are obtained by sorting the real values). If you want to calculate the autocorrelation function of your images set \texttt{acf=yes}. If you want to randomise the phases of the Fourier transforms of your images, set \texttt{phrand=yes} and \texttt{lp} to the desired low-pass limit. If you want to extract a contiguous subset of particle images from the stack, set \texttt{fromp} and \texttt{top}. If you want to fish out a number of particle images from your stack at random, set \texttt{nran} to some nonzero integer number less than \texttt{nptcls}. If you want to resize you images, set the desired box to \texttt{newbox} or use the \texttt{scale} option. It is often convenient to use \texttt{scale} in combination with \texttt{clip} to resize images.  If you want to normalise your images, set \texttt{norm=yes}. \texttt{hfun} controls the normalisation function. With \texttt{avg=yes} the global average of the inputted stack is calculated. With \texttt{ctf=flip} the contrast inversions due to the CTF are corrected by the infamous (but effective) phase-flipping heuristic. This requires additional input of CTF-related parameters (\texttt{kv}, \texttt{fraca} and \texttt{cs}) in addition to the defocus and astigmatism angle values, communicated either via \texttt{oritab} or via \texttt{deftab}. Even if you do initially phase-flip the images, which you should do for initial model production with PRIME, you can turn on the Wiener restoration later anyway, to accomplish correct weighting of information around the CTF zeroes and maximal noise reduction. \texttt{ft2img=yes} produces images of the square power spectrum of the images in \texttt{stk}. If you define \texttt{frameavg} to some integer number larger than one averages with chunk sizes of \texttt{frameavg} are produced, which may be useful for analysis of dose-fractionated image series. \texttt{clip} can be used to re-window or pad the images to a different box size. When \texttt{compare=yes}, the two inputted stacks are Fourier ring correlated. \texttt{neg} inverts the contrast of the images. \texttt{ctfsq} applies the squared CTF to the inputted images. \texttt{inner} is for applying an inner mask with fall-off width \texttt{width}. Finally, \texttt{append} is for appending stack \texttt{stk2} with stack \texttt{stk}, so that the \texttt{stk2} images occur last in the series and the stk name is preserved.

\subsubsection{Program: \prgname{simple\_volops}}
\label{volops}
\prgname{simple\_volops} provides standard single-particle image processing routines that are applied to MRC or SPIDER volumes.
\begin{verbatim}
    $ SIMPLE_VOLOPS [vol1=<invol.ext>] [vol2=<invol2.ext>] [smpd=<sampling}
    distance(in A)>] [outvol=<outvol.ext>] [nthr=<nr of openMP threads{1}>]
    [phrand=<yes|no{no}>] [msk=<mask radius(in pixels)>] [lp=<low-pass
    limit{20}>] [hp=<high-pass limit{100}>] [snr=<signal-to-noise ratio>]
    [center=<yes|no{no}>] [soften=<yes|no{no}>] [guinier=<yes|no{no}>]
    [bfac=<bfactor(in A**2){200.}>] [edge=<edge size for softening molecular
    envelope(in pixels){3}>] [mskfile=<mask.ext>] [countvox=<yes|no{no}>]
    [newbox=<scaled box>] [scale=<scale factor{1}>] [msktype=<hard|soft{soft}>]
    [inner=<inner mask radius(in pixels)>] [width=<pixels falloff inner
    mask{10}>] [cube=<side (in pixels){0}>] [e1=<1st Euler{0}>] [e2=<2nd
    Euler{0}>] [e3=<3d Euler{0}>] [corner=<corner size{0}>]
    [neg=<yes|no{no}>] [voltab=<file table>] [voltab2=<file table>]
    [bin=<yes|no{no}>] [nvox=<nr of voxels{0}>] [xsh=<x shift(pixels){0}>]
    [ysh=<y shift(pixels){0}>] [zsh=<z shift(pixels){0}>]
\end{verbatim}
\noindent\textbf{Comments:} If you input two volumes and the sampling distance, the FSC is calculated between the volumes. The FSC plot is written to STDOUT together with resolution estimates at $FSC=0.5$ and $FSC=0.143$. The volumes subjected to FSC calculation should be masked with a soft-edged (not hard-edged) mask and they should not have been subjected to any "auto" or threshold masking. If \texttt{phrand} and \texttt{lp} are given, the Fourier phases of the input volume \texttt{vol1} are randomized. \texttt{msk} is used for spherical masking with a soft (cosine edge) fall-off. \texttt{lp} and \texttt{hp} are the low-pass and high-pass limits used for filtering. To add noise to a volume, give the desired signal-to-noise ratio via \texttt{snr}. Give \texttt{center=yes} and \texttt{lp} to center the input volume according to center of mass. The 3D origin shift vector is found by low-pass filtering the volume to \texttt{lp}, binarizing the density, identifying the center of mass, and calculating the vector needed to place the center of mass in the center of the box. \texttt{soften=yes} applies a real-space low-pass filter using pixel width \texttt{edge}. \texttt{mskfile} is used for masking a volume using an externally generated mask. \texttt{countvox=yes} counts the number of foreground voxels (the binarization method is k-means). \texttt{newbox} and \texttt{scale} are used for resizing the volume. \texttt{msktype} controls the mask type (\texttt{hard} or \texttt{soft}). \texttt{inner} controls the radius of the inner mask with fall-off \texttt{width}. \texttt{cube} is used to generate a binary cube (4 testing purposes). \texttt{e1,e2,e3} is the Euler triplet used to rotate the input volume using Kaiser-Bessel interpolation in Fourier space. \texttt{corner} is used for filling in the corners of the box with binary cubes (4 testing purposes). \texttt{neg} inverts the contrast of the input volume by multiplication with $-1$ in Fourier space. \texttt{voltab} and \texttt{voltab2} are used to give text files with the names of volume files that are correlated and the nearest neighbour structure of the comparison is written to STDOUT.

\subsection{Utility programs}

\subsubsection{Program: \prgname{simple\_print\_fsc}}
\label{print_fsc}
\prgname{simple\_print\_fsc} is a program for printing the binary FSC files produced by PRIME3D
\begin{verbatim}
    $ SIMPLE_PRINT_FSC smpd=<sampling distance(in A)> box=<image size(in pixels)>}
    fsc=<fsc_state1.bin>
\end{verbatim}

\subsubsection{Program: \prgname{simple\_res}}
\label{res}
\prgname{simple\_res} is a program for checking the low-pass resolution limit for a given Fourier index.
\begin{verbatim}
    $ SIMPLE_RES smpd=<sampling distance(in A)> find=<Fourier index> box=<box size}
    (in pixels)>
\end{verbatim}

\subsubsection{Program: \prgname{simple\_projvol}}
\label{projvol}
\prgname{simple\_projvol} is a program for projecting a volume using interpolation in Fourier space. Input is a SPIDER or MRC volume. Output is a stack of projection images of the same format as the inputted volume.
\begin{verbatim}
    $ SIMPLE_PROJVOL vol1=<invol.ext> smpd=<sampling distance(in A)> [nspace=<nr of}
    projs{1000}>] [outstk=<ouput stack>] [oritab=<SIMPLE alignment doc>]
    [nthr=<nr of openMP threads{1}>] [rnd=<yes|no{no}>] [trs=<origin shift(in
    pixels){0}>]
    ** less commonly used **
    [pgrp=<cn|dn|t|o|i{c1}>] [ctf=<yes|no|flip|mul{no}>] [kv=<acceleration
    voltage(in kV){300.}>] [fraca=<frac amp contrast{0.07}>] [cs=<spherical
    aberration constant(in mm){2.7}>] [defocus=<underfocus(in microns){3.}>]
    [bfac=<bfactor(in A**2){200.}>] [neg=<yes|no{no}>]
    [mirr=<yes|x|y|no{no}>] [top=<stop at this index>] [xfel=<yes|no{no}>]
\end{verbatim}
\noindent\textbf{Comments:} Projections are generated by extraction of central sections from the Fourier volume and back transformation of the 2D FTs. \texttt{nspace} controls the number of projection images generated with quasi-even projection directions.The \texttt{oritab} parameter allows you to input the orientations that you wish to have your volume projected in. If \texttt{rnd=yes}, random rather than quasi-even projections are generated, \texttt{trs} then controls the halfwidth of the random origin shift. Less commonly used parameters are \texttt{pgrp}, which controls the point-group symmetry \texttt{c} (rotational), \texttt{d} (dihedral), \texttt{t} (tetrahedral), \texttt{o} (octahedral) or \texttt{i} (icosahedral). The point-group symmetry is used to restrict the set of projections to within the asymmetric unit. \texttt{ctf=yes} allows you to apply CTF to the images, using constant defocus and no astigmatism. If you want to do this you need to define the parameters \texttt{kv}, \texttt{fraca}, \texttt{cs}, \texttt{defocus} and \texttt{bfac}. \texttt{neg} inverts the contrast of the projections. \texttt{mirr=yes} mirrors the projection by modifying the Euler angles. If \texttt{mirr=x} or \texttt{mirr=y} the projection is physically mirrored after it has been generated.

\section{Command Line Dictionary}
\begin{tabular}{ll}
\texttt{acf}&{yes|no\{no\}}\\
\texttt{amsklp}&{automask low-pass limit(in \AA{})}\\
\texttt{angerr}&{angular error(in degrees)}\\
\texttt{append}&{yes|no\{no\}}\\
\texttt{astigerr}&{astigmatism error(in degrees)}\\
\texttt{avg}&{yes|no}\\
\texttt{bfac}&{bfactor}\\
\texttt{bfacerr}&{bfactor error}\\
\texttt{bin}&{binarize\{no\}}\\
\texttt{box}&{image size(in pixels)}\\
\texttt{boxtab}&{boxfiles.txt}\\
\texttt{center}&{yes|no\{no\}}\\
\texttt{chunksz}&{chunk size}\\
\texttt{class}&{cluster2extract}\\
\texttt{clip}&{clip2box\{256\}}\\
\texttt{clustvalid}&{yes|homo|no|\{no\}}\\
\texttt{comlindoc}&{shc\_clustering\_nclsX.txt}\\
\texttt{compare}&{yes|no\{no\}}\\
\texttt{corner}&{corner size(in pixels)}\\
\texttt{countvox}&{yes|no\{no\}}\\
\texttt{cs}&{spherical aberration constant(in mm)\{2.7\}}\\
\texttt{ctf}&{yes|no|flip|mul\{no\}}\\
\texttt{ctfsq}&{yes|no\{no\}}\\
\texttt{ctfstats}&{yes|no\{no\}}\\
\texttt{cube}&{cube side(in pixels)}\\
\texttt{deferr}&{defocus error(in microns)}\\
\texttt{defocus}&{defocus(in microns)}\\
\texttt{deftab}&{text file with CTF info}\\
\texttt{dens}&{density}\\
\texttt{dir}&{directory}\\
\texttt{discrete}&{yes|no\{no\}}\\
\texttt{diversify}&{yes|no\{yes\}}\\
\texttt{doclist}&{list of oritabs}\\
\texttt{dynlp}&{yes|no\{yes\}}\\
\texttt{e1}&{1st Euler angle}\\
\texttt{e2}&{2nd Euler angle}\\
\texttt{e3}&{3d Euler angle}\\
\texttt{edge}&{edge size(in pixels)}\\
\texttt{eo}&{yes|no\{yes\}}\\
\texttt{errify}&{yes|no\{no\}}\\
\texttt{even}&{yes|no\{no\}}\\
\texttt{fbody}&{body of file}\\
\texttt{filetab}&{movies.txt}\\
\texttt{find}&{Fourier index}\\
\texttt{fname}&{filename}\\
\texttt{frac}&{fraction}\\
\texttt{fraca}&{fraction of amplitude contrast\{0.07\}}\\
\texttt{fromp}&{from particle index}\\
\end{tabular}

\begin{tabular}{ll}
\texttt{fsc}&{fsc\_state1.bin}\\
\texttt{ft2img}&{yes|no\{no\}}\\
\texttt{guinier}&{yes|no\{no\}}\\
\texttt{hfun}&{sigm|tanh|lin\{sigm\}}\\
\texttt{hist}&{var2plot}\\
\texttt{hp}&{high-pass limit(in \AA{})}\\
\texttt{inner}&{inner mask radius(in pixels)}\\
\texttt{kv}&{acceleration voltage\{300\}}\\
\texttt{label}&{class|state|subclass\{class\}}\\
\texttt{lp}&{low-pass limit(in \AA{})\{20\}}\\
\texttt{lpstart}&{starting low-pass limit}\\
\texttt{lpstop}&{stay at this low-pass limit}\\
\texttt{masscen}&{yes|no\{no\}}\\
\texttt{maxits}&{maximum number of iterations\{500\}}\\
\texttt{minp}&{minimum cluster population}\\
\texttt{mirr}&{no|2d|3d\{no\}}\\
\texttt{moldiam}&{molecular diameter(in \AA{})}\\
\texttt{msk}&{mask radius(in pixels)}\\
\texttt{mskfile}&{mask.ext}\\
\texttt{msktype}&{hard|soft\{soft\}}\\
\texttt{mul}&{shift multiplication factor}\\
\texttt{mw}&{molecular weight(in kDa)}\\
\texttt{ncls}&{nr of clusters}\\
\texttt{ndiscrete}&{nr of discrete oris}\\
\texttt{ndocs}&{nr of documents}\\
\texttt{neg}&{yes|no}\\
\texttt{newbox}&{new box size(in pixles)}\\
\texttt{nframes}&{nr of movie frames }\\
\texttt{noise}&{yes|no\{no\}}\\
\texttt{noise\_norm}&{yes|no}\\
\texttt{norm}&{yes|no\{no\}}\\
\texttt{npart}&{nr of partitions(nodes)}\\
\texttt{npeaks}&{nr of correlation peaks}\\
\texttt{nptcls}&{nr of particles}\\
\texttt{nran}&{size of random sample}\\
\texttt{nspace}&{nr of orientations in discrete space}\\
\texttt{nstates}&{nr of conformational states}\\
\texttt{nthr}&{nr of threads (CPUs within a socket)}\\
\texttt{nvox}&{nr of voxels}\\
\texttt{odd}&{yes|no\{no\}}\\
\texttt{oritab}&{orientations}\\
\texttt{oritab2}&{orientations}\\
\texttt{outfile}&{output text file}\\
\texttt{outstk}&{output image stack}\\
\texttt{outvol}&{outvol.ext}\\
\texttt{pgrp}&{cn|dn|t|o|i\{c1\}}\\
\texttt{phrand}&{yes|no\{no\}}\\
\texttt{plot}&{yes|no\{no\}}\\
\texttt{pspecsz}&{box size of power spectrum}\\
\texttt{refine}&{no|shc\{no\}}\\
\end{tabular}

\begin{tabular}{ll}
\texttt{refs}&{initial\_references.ext}\\
\texttt{rnd}&{yes|no\{no\}}\\
\texttt{round}&{yes|no\{no\}}\\
\texttt{scale}&{scale factor}\\
\texttt{shalgn}&{yes|no\{no\}}\\
\texttt{sherr}&{shift error(in pixels)}\\
\texttt{smpd}&{sampling distance(in \AA{})}\\
\texttt{snr}&{signal2noise ratio}\\
\texttt{soften}&{yes|no\{no\}}\\
\texttt{split}&{nr of partitions to split into}\\
\texttt{srch\_inpl}&{yes|no\{yes\}}\\
\texttt{startit}&{start iteration nr}\\
\texttt{state}&{state index}\\
\texttt{stats}&{yes|no|print\{no\}}\\
\texttt{stk}&{input particle stack}\\
\texttt{stk2}&{input particle stack nr 2}\\
\texttt{stk3}&{input particle stack nr 3}\\
\texttt{thres}&{threshold}\\
\texttt{top}&{stop particle index}\\
\texttt{trs}&{origin shift range[-trs,trs](in pixels)}\\
\texttt{vis}&{yes|no\{no\}}\\
\texttt{vol1}&{invol.ext}\\
\texttt{vol2}&{invol2.ext}\\
\texttt{which\_iter}&{iteration number}\\
\texttt{width}&{pixels width}\\
\texttt{xdim}&{nr of pixels in x-dim}\\
\texttt{xsh}&{x shift(in pixels)}\\
\texttt{ydim}&{nr of pixels in y-dim}\\
\texttt{ysh}&{y shift(in pixels)}\\
\texttt{zero}&{yes|no\{no\}}\\
\texttt{zsh}&{z shift(in pixels)}\\
\end{tabular}

\clearpage
\def\bibfont{\footnotesize}
\bibliographystyle{cell}
\bibliography{myrefs}

\end{document}
