!> \brief \b IEEECK                                                     
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download IEEECK + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       INTEGER          FUNCTION IEEECK( ISPEC, ZERO, ONE )            
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            ISPEC                                        
!       REAL               ONE, ZERO                                    
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> IEEECK is called from the ILAENV to verify that Infinity and         
!> possibly NaN arithmetic is safe (i.e. will not trap).                
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] ISPEC                                                     
!> \verbatim                                                            
!>          ISPEC is INTEGER                                            
!>          Specifies whether to test just for inifinity arithmetic     
!>          or whether to test for infinity and NaN arithmetic.         
!>          = 0: Verify infinity arithmetic only.                       
!>          = 1: Verify infinity and NaN arithmetic.                    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ZERO                                                      
!> \verbatim                                                            
!>          ZERO is REAL                                                
!>          Must contain the value 0.0                                  
!>          This is passed to prevent the compiler from optimizing      
!>          away this code.                                             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ONE                                                       
!> \verbatim                                                            
!>          ONE is REAL                                                 
!>          Must contain the value 1.0                                  
!>          This is passed to prevent the compiler from optimizing      
!>          away this code.                                             
!>                                                                      
!>  RETURN VALUE:  INTEGER                                              
!>          = 0:  Arithmetic failed to produce the correct answers      
!>          = 1:  Arithmetic produced the correct answers               
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!  =====================================================================
      INTEGER          FUNCTION IEEECK( ISPEC, ZERO, ONE ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            ISPEC 
      REAL               ONE, ZERO 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Local Scalars ..                                               
      REAL               NAN1, NAN2, NAN3, NAN4, NAN5, NAN6, NEGINF,    &
     &                   NEGZRO, NEWZRO, POSINF                         
!     ..                                                                
!     .. Executable Statements ..                                       
      IEEECK = 1 
!                                                                       
      POSINF = ONE / ZERO 
      IF( POSINF.LE.ONE ) THEN 
         IEEECK = 0 
         RETURN 
      END IF 
!                                                                       
      NEGINF = -ONE / ZERO 
      IF( NEGINF.GE.ZERO ) THEN 
         IEEECK = 0 
         RETURN 
      END IF 
!                                                                       
      NEGZRO = ONE / ( NEGINF+ONE ) 
      IF( NEGZRO.NE.ZERO ) THEN 
         IEEECK = 0 
         RETURN 
      END IF 
!                                                                       
      NEGINF = ONE / NEGZRO 
      IF( NEGINF.GE.ZERO ) THEN 
         IEEECK = 0 
         RETURN 
      END IF 
!                                                                       
      NEWZRO = NEGZRO + ZERO 
      IF( NEWZRO.NE.ZERO ) THEN 
         IEEECK = 0 
         RETURN 
      END IF 
!                                                                       
      POSINF = ONE / NEWZRO 
      IF( POSINF.LE.ONE ) THEN 
         IEEECK = 0 
         RETURN 
      END IF 
!                                                                       
      NEGINF = NEGINF*POSINF 
      IF( NEGINF.GE.ZERO ) THEN 
         IEEECK = 0 
         RETURN 
      END IF 
!                                                                       
      POSINF = POSINF*POSINF 
      IF( POSINF.LE.ONE ) THEN 
         IEEECK = 0 
         RETURN 
      END IF 
!                                                                       
!                                                                       
!                                                                       
!                                                                       
!     Return if we were only asked to check infinity arithmetic         
!                                                                       
      IF( ISPEC.EQ.0 )                                                  &
     &   RETURN                                                         
!                                                                       
      NAN1 = POSINF + NEGINF 
!                                                                       
      NAN2 = POSINF / NEGINF 
!                                                                       
      NAN3 = POSINF / POSINF 
!                                                                       
      NAN4 = POSINF*ZERO 
!                                                                       
      NAN5 = NEGINF*NEGZRO 
!                                                                       
      NAN6 = NAN5*ZERO 
!                                                                       
      IF( NAN1.EQ.NAN1 ) THEN 
         IEEECK = 0 
         RETURN 
      END IF 
!                                                                       
      IF( NAN2.EQ.NAN2 ) THEN 
         IEEECK = 0 
         RETURN 
      END IF 
!                                                                       
      IF( NAN3.EQ.NAN3 ) THEN 
         IEEECK = 0 
         RETURN 
      END IF 
!                                                                       
      IF( NAN4.EQ.NAN4 ) THEN 
         IEEECK = 0 
         RETURN 
      END IF 
!                                                                       
      IF( NAN5.EQ.NAN5 ) THEN 
         IEEECK = 0 
         RETURN 
      END IF 
!                                                                       
      IF( NAN6.EQ.NAN6 ) THEN 
         IEEECK = 0 
         RETURN 
      END IF 
!                                                                       
      RETURN 
      END                                           
!> \brief \b ILAENV                                                     
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download ILAENV + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       INTEGER FUNCTION ILAENV( ISPEC, NAME, OPTS, N1, N2, N3, N4 )    
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER*( * )    NAME, OPTS                                   
!       INTEGER            ISPEC, N1, N2, N3, N4                        
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> ILAENV is called from the LAPACK routines to choose problem-dependent
!> parameters for the local environment.  See ISPEC for a description of
!> the parameters.                                                      
!>                                                                      
!> ILAENV returns an INTEGER                                            
!> if ILAENV >= 0: ILAENV returns the value of the parameter specified b
!> if ILAENV < 0:  if ILAENV = -k, the k-th argument had an illegal valu
!>                                                                      
!> This version provides a set of parameters which should give good,    
!> but not optimal, performance on many of the currently available      
!> computers.  Users are encouraged to modify this subroutine to set    
!> the tuning parameters for their particular machine using the option  
!> and problem size information in the arguments.                       
!>                                                                      
!> This routine will not function correctly if it is converted to all   
!> lower case.  Converting it to all upper case is allowed.             
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] ISPEC                                                     
!> \verbatim                                                            
!>          ISPEC is INTEGER                                            
!>          Specifies the parameter to be returned as the value of      
!>          ILAENV.                                                     
!>          = 1: the optimal blocksize; if this value is 1, an unblocked
!>               algorithm will give the best performance.              
!>          = 2: the minimum block size for which the block routine     
!>               should be used; if the usable block size is less than  
!>               this value, an unblocked routine should be used.       
!>          = 3: the crossover point (in a block routine, for N less    
!>               than this value, an unblocked routine should be used)  
!>          = 4: the number of shifts, used in the nonsymmetric         
!>               eigenvalue routines (DEPRECATED)                       
!>          = 5: the minimum column dimension for blocking to be used;  
!>               rectangular blocks must have dimension at least k by m,
!>               where k is given by ILAENV(2,...) and m by ILAENV(5,...
!>          = 6: the crossover point for the SVD (when reducing an m by 
!>               matrix to bidiagonal form, if max(m,n)/min(m,n) exceeds
!>               this value, a QR factorization is used first to reduce 
!>               the matrix to a triangular form.)                      
!>          = 7: the number of processors                               
!>          = 8: the crossover point for the multishift QR method       
!>               for nonsymmetric eigenvalue problems (DEPRECATED)      
!>          = 9: maximum size of the subproblems at the bottom of the   
!>               computation tree in the divide-and-conquer algorithm   
!>               (used by xGELSD and xGESDD)                            
!>          =10: ieee NaN arithmetic can be trusted not to trap         
!>          =11: infinity arithmetic can be trusted not to trap         
!>          12 <= ISPEC <= 16:                                          
!>               xHSEQR or related subroutines,                         
!>               see IPARMQ for detailed explanation                    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] NAME                                                      
!> \verbatim                                                            
!>          NAME is CHARACTER*(*)                                       
!>          The name of the calling subroutine, in either upper case or 
!>          lower case.                                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] OPTS                                                      
!> \verbatim                                                            
!>          OPTS is CHARACTER*(*)                                       
!>          The character options to the subroutine NAME, concatenated  
!>          into a single character string.  For example, UPLO = 'U',   
!>          TRANS = 'T', and DIAG = 'N' for a triangular routine would  
!>          be specified as OPTS = 'UTN'.                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N1                                                        
!> \verbatim                                                            
!>          N1 is INTEGER                                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N2                                                        
!> \verbatim                                                            
!>          N2 is INTEGER                                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N3                                                        
!> \verbatim                                                            
!>          N3 is INTEGER                                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N4                                                        
!> \verbatim                                                            
!>          N4 is INTEGER                                               
!>          Problem dimensions for the subroutine NAME; these may not al
!>          be required.                                                
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date November 2019                                                  
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  The following conventions have been used when calling ILAENV from th
!>  LAPACK routines:                                                    
!>  1)  OPTS is a concatenation of all of the character options to      
!>      subroutine NAME, in the same order that they appear in the      
!>      argument list for NAME, even if they are not used in determining
!>      the value of the parameter specified by ISPEC.                  
!>  2)  The problem dimensions N1, N2, N3, N4 are specified in the order
!>      that they appear in the argument list for NAME.  N1 is used     
!>      first, N2 second, and so on, and unused problem dimensions are  
!>      passed a value of -1.                                           
!>  3)  The parameter value returned by ILAENV is checked for validity i
!>      the calling subroutine.  For example, ILAENV is used to retrieve
!>      the optimal blocksize for STRTRI as follows:                    
!>                                                                      
!>      NB = ILAENV( 1, 'STRTRI', UPLO // DIAG, N, -1, -1, -1 )         
!>      IF( NB.LE.1 ) NB = MAX( 1, N )                                  
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      INTEGER FUNCTION ILAENV( ISPEC, NAME, OPTS, N1, N2, N3, N4 ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.9.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     November 2019                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER*( * )    NAME, OPTS 
      INTEGER            ISPEC, N1, N2, N3, N4 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Local Scalars ..                                               
      INTEGER            I, IC, IZ, NB, NBMIN, NX 
      LOGICAL            CNAME, SNAME, TWOSTAGE 
      CHARACTER          C1*1, C2*2, C4*2, C3*3, SUBNAM*16 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          CHAR, ICHAR, INT, MIN, REAL 
!     ..                                                                
!     .. External Functions ..                                          
      INTEGER            IEEECK, IPARMQ, IPARAM2STAGE 
      EXTERNAL           IEEECK, IPARMQ, IPARAM2STAGE 
!     ..                                                                
!     .. Executable Statements ..                                       
!
      select case(ISPEC)
         case(1, 2, 3)
            GO TO 10
         case(4)
            GO TO 80
         case(5)
            GO TO 90
         case(6)
            GO TO 100
         case(7)
            GO TO 110
         case(8)
            GO TO 120
         case(9)
            GO TO 130
         case(10)
            GO TO 140
         case(11)
            GO TO 150
         case(12, 13, 14, 15, 16)
            GO TO 160
      end select
!                                                                       
!     Invalid value for ISPEC                                           
!                                                                       
      ILAENV = -1 
      RETURN 
!                                                                       
   10 CONTINUE 
!                                                                       
!     Convert NAME to upper case if the first character is lower case.  
!                                                                       
      ILAENV = 1 
      SUBNAM = NAME 
      IC = ICHAR( SUBNAM( 1: 1 ) ) 
      IZ = ICHAR( 'Z' ) 
      IF( IZ.EQ.90 .OR. IZ.EQ.122 ) THEN 
!                                                                       
!        ASCII character set                                            
!                                                                       
         IF( IC.GE.97 .AND. IC.LE.122 ) THEN 
            SUBNAM( 1: 1 ) = CHAR( IC-32 ) 
            DO 20 I = 2, 6 
               IC = ICHAR( SUBNAM( I: I ) ) 
               IF( IC.GE.97 .AND. IC.LE.122 )                           &
     &            SUBNAM( I: I ) = CHAR( IC-32 )                        
   20       CONTINUE 
         END IF 
!                                                                       
      ELSE IF( IZ.EQ.233 .OR. IZ.EQ.169 ) THEN 
!                                                                       
!        EBCDIC character set                                           
!                                                                       
         IF( ( IC.GE.129 .AND. IC.LE.137 ) .OR.                         &
     &       ( IC.GE.145 .AND. IC.LE.153 ) .OR.                         &
     &       ( IC.GE.162 .AND. IC.LE.169 ) ) THEN                       
            SUBNAM( 1: 1 ) = CHAR( IC+64 ) 
            DO 30 I = 2, 6 
               IC = ICHAR( SUBNAM( I: I ) ) 
               IF( ( IC.GE.129 .AND. IC.LE.137 ) .OR.                   &
     &             ( IC.GE.145 .AND. IC.LE.153 ) .OR.                   &
     &             ( IC.GE.162 .AND. IC.LE.169 ) )SUBNAM( I:            &
     &             I ) = CHAR( IC+64 )                                  
   30       CONTINUE 
         END IF 
!                                                                       
      ELSE IF( IZ.EQ.218 .OR. IZ.EQ.250 ) THEN 
!                                                                       
!        Prime machines:  ASCII+128                                     
!                                                                       
         IF( IC.GE.225 .AND. IC.LE.250 ) THEN 
            SUBNAM( 1: 1 ) = CHAR( IC-32 ) 
            DO 40 I = 2, 6 
               IC = ICHAR( SUBNAM( I: I ) ) 
               IF( IC.GE.225 .AND. IC.LE.250 )                          &
     &            SUBNAM( I: I ) = CHAR( IC-32 )                        
   40       CONTINUE 
         END IF 
      END IF 
!                                                                       
      C1 = SUBNAM( 1: 1 ) 
      SNAME = C1.EQ.'S' .OR. C1.EQ.'D' 
      CNAME = C1.EQ.'C' .OR. C1.EQ.'Z' 
      IF( .NOT.( CNAME .OR. SNAME ) )                                   &
     &   RETURN                                                         
      C2 = SUBNAM( 2: 3 ) 
      C3 = SUBNAM( 4: 6 ) 
      C4 = C3( 2: 3 ) 
      TWOSTAGE = LEN( SUBNAM ).GE.11                                    &
     &           .AND. SUBNAM( 11: 11 ).EQ.'2'                          
!                                                                       
      select case(ISPEC)
         case(1)
            GO TO 50
         case(2)
            GO TO 60
         case(3)
            GO TO 70
      end select
!                                                                       
   50 CONTINUE 
!                                                                       
!     ISPEC = 1:  block size                                            
!                                                                       
!     In these examples, separate code is provided for setting NB for   
!     real and complex.  We assume that NB will take the same value in  
!     single or double precision.                                       
!                                                                       
      NB = 1 
!                                                                       
      IF( SUBNAM(2:6).EQ.'LAORH' ) THEN 
!                                                                       
!        This is for *LAORHR_GETRFNP routine                            
!                                                                       
         IF( SNAME ) THEN 
             NB = 32 
         ELSE 
             NB = 32 
         END IF 
      ELSE IF( C2.EQ.'GE' ) THEN 
         IF( C3.EQ.'TRF' ) THEN 
            IF( SNAME ) THEN 
               NB = 64 
            ELSE 
               NB = 64 
            END IF 
         ELSE IF( C3.EQ.'QRF' .OR. C3.EQ.'RQF' .OR. C3.EQ.'LQF' .OR.    &
     &            C3.EQ.'QLF' ) THEN                                    
            IF( SNAME ) THEN 
               NB = 32 
            ELSE 
               NB = 32 
            END IF 
         ELSE IF( C3.EQ.'QR ') THEN 
            IF( N3 .EQ. 1) THEN 
               IF( SNAME ) THEN 
!     M*N                                                               
                  IF ((N1*N2.LE.131072).OR.(N1.LE.8192)) THEN 
                     NB = N1 
                  ELSE 
                     NB = 32768/N2 
                  END IF 
               ELSE 
                  IF ((N1*N2.LE.131072).OR.(N1.LE.8192)) THEN 
                     NB = N1 
                  ELSE 
                     NB = 32768/N2 
                  END IF 
               END IF 
            ELSE 
               IF( SNAME ) THEN 
                  NB = 1 
               ELSE 
                  NB = 1 
               END IF 
            END IF 
         ELSE IF( C3.EQ.'LQ ') THEN 
            IF( N3 .EQ. 2) THEN 
               IF( SNAME ) THEN 
!     M*N                                                               
                  IF ((N1*N2.LE.131072).OR.(N1.LE.8192)) THEN 
                     NB = N1 
                  ELSE 
                     NB = 32768/N2 
                  END IF 
               ELSE 
                  IF ((N1*N2.LE.131072).OR.(N1.LE.8192)) THEN 
                     NB = N1 
                  ELSE 
                     NB = 32768/N2 
                  END IF 
               END IF 
            ELSE 
               IF( SNAME ) THEN 
                  NB = 1 
               ELSE 
                  NB = 1 
               END IF 
            END IF 
         ELSE IF( C3.EQ.'HRD' ) THEN 
            IF( SNAME ) THEN 
               NB = 32 
            ELSE 
               NB = 32 
            END IF 
         ELSE IF( C3.EQ.'BRD' ) THEN 
            IF( SNAME ) THEN 
               NB = 32 
            ELSE 
               NB = 32 
            END IF 
         ELSE IF( C3.EQ.'TRI' ) THEN 
            IF( SNAME ) THEN 
               NB = 64 
            ELSE 
               NB = 64 
            END IF 
         END IF 
      ELSE IF( C2.EQ.'PO' ) THEN 
         IF( C3.EQ.'TRF' ) THEN 
            IF( SNAME ) THEN 
               NB = 64 
            ELSE 
               NB = 64 
            END IF 
         END IF 
      ELSE IF( C2.EQ.'SY' ) THEN 
         IF( C3.EQ.'TRF' ) THEN 
            IF( SNAME ) THEN 
               IF( TWOSTAGE ) THEN 
                  NB = 192 
               ELSE 
                  NB = 64 
               END IF 
            ELSE 
               IF( TWOSTAGE ) THEN 
                  NB = 192 
               ELSE 
                  NB = 64 
               END IF 
            END IF 
         ELSE IF( SNAME .AND. C3.EQ.'TRD' ) THEN 
            NB = 32 
         ELSE IF( SNAME .AND. C3.EQ.'GST' ) THEN 
            NB = 64 
         END IF 
      ELSE IF( CNAME .AND. C2.EQ.'HE' ) THEN 
         IF( C3.EQ.'TRF' ) THEN 
            IF( TWOSTAGE ) THEN 
               NB = 192 
            ELSE 
               NB = 64 
            END IF 
         ELSE IF( C3.EQ.'TRD' ) THEN 
            NB = 32 
         ELSE IF( C3.EQ.'GST' ) THEN 
            NB = 64 
         END IF 
      ELSE IF( SNAME .AND. C2.EQ.'OR' ) THEN 
         IF( C3( 1: 1 ).EQ.'G' ) THEN 
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR. C4.EQ.  &
     &          'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR. C4.EQ.'BR' )  &
     &           THEN                                                   
               NB = 32 
            END IF 
         ELSE IF( C3( 1: 1 ).EQ.'M' ) THEN 
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR. C4.EQ.  &
     &          'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR. C4.EQ.'BR' )  &
     &           THEN                                                   
               NB = 32 
            END IF 
         END IF 
      ELSE IF( CNAME .AND. C2.EQ.'UN' ) THEN 
         IF( C3( 1: 1 ).EQ.'G' ) THEN 
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR. C4.EQ.  &
     &          'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR. C4.EQ.'BR' )  &
     &           THEN                                                   
               NB = 32 
            END IF 
         ELSE IF( C3( 1: 1 ).EQ.'M' ) THEN 
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR. C4.EQ.  &
     &          'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR. C4.EQ.'BR' )  &
     &           THEN                                                   
               NB = 32 
            END IF 
         END IF 
      ELSE IF( C2.EQ.'GB' ) THEN 
         IF( C3.EQ.'TRF' ) THEN 
            IF( SNAME ) THEN 
               IF( N4.LE.64 ) THEN 
                  NB = 1 
               ELSE 
                  NB = 32 
               END IF 
            ELSE 
               IF( N4.LE.64 ) THEN 
                  NB = 1 
               ELSE 
                  NB = 32 
               END IF 
            END IF 
         END IF 
      ELSE IF( C2.EQ.'PB' ) THEN 
         IF( C3.EQ.'TRF' ) THEN 
            IF( SNAME ) THEN 
               IF( N2.LE.64 ) THEN 
                  NB = 1 
               ELSE 
                  NB = 32 
               END IF 
            ELSE 
               IF( N2.LE.64 ) THEN 
                  NB = 1 
               ELSE 
                  NB = 32 
               END IF 
            END IF 
         END IF 
      ELSE IF( C2.EQ.'TR' ) THEN 
         IF( C3.EQ.'TRI' ) THEN 
            IF( SNAME ) THEN 
               NB = 64 
            ELSE 
               NB = 64 
            END IF 
         ELSE IF ( C3.EQ.'EVC' ) THEN 
            IF( SNAME ) THEN 
               NB = 64 
            ELSE 
               NB = 64 
            END IF 
         END IF 
      ELSE IF( C2.EQ.'LA' ) THEN 
         IF( C3.EQ.'UUM' ) THEN 
            IF( SNAME ) THEN 
               NB = 64 
            ELSE 
               NB = 64 
            END IF 
         END IF 
      ELSE IF( SNAME .AND. C2.EQ.'ST' ) THEN 
         IF( C3.EQ.'EBZ' ) THEN 
            NB = 1 
         END IF 
      ELSE IF( C2.EQ.'GG' ) THEN 
         NB = 32 
         IF( C3.EQ.'HD3' ) THEN 
            IF( SNAME ) THEN 
               NB = 32 
            ELSE 
               NB = 32 
            END IF 
         END IF 
      END IF 
      ILAENV = NB 
      RETURN 
!                                                                       
   60 CONTINUE 
!                                                                       
!     ISPEC = 2:  minimum block size                                    
!                                                                       
      NBMIN = 2 
      IF( C2.EQ.'GE' ) THEN 
         IF( C3.EQ.'QRF' .OR. C3.EQ.'RQF' .OR. C3.EQ.'LQF' .OR. C3.EQ.  &
     &       'QLF' ) THEN                                               
            IF( SNAME ) THEN 
               NBMIN = 2 
            ELSE 
               NBMIN = 2 
            END IF 
         ELSE IF( C3.EQ.'HRD' ) THEN 
            IF( SNAME ) THEN 
               NBMIN = 2 
            ELSE 
               NBMIN = 2 
            END IF 
         ELSE IF( C3.EQ.'BRD' ) THEN 
            IF( SNAME ) THEN 
               NBMIN = 2 
            ELSE 
               NBMIN = 2 
            END IF 
         ELSE IF( C3.EQ.'TRI' ) THEN 
            IF( SNAME ) THEN 
               NBMIN = 2 
            ELSE 
               NBMIN = 2 
            END IF 
         END IF 
      ELSE IF( C2.EQ.'SY' ) THEN 
         IF( C3.EQ.'TRF' ) THEN 
            IF( SNAME ) THEN 
               NBMIN = 8 
            ELSE 
               NBMIN = 8 
            END IF 
         ELSE IF( SNAME .AND. C3.EQ.'TRD' ) THEN 
            NBMIN = 2 
         END IF 
      ELSE IF( CNAME .AND. C2.EQ.'HE' ) THEN 
         IF( C3.EQ.'TRD' ) THEN 
            NBMIN = 2 
         END IF 
      ELSE IF( SNAME .AND. C2.EQ.'OR' ) THEN 
         IF( C3( 1: 1 ).EQ.'G' ) THEN 
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR. C4.EQ.  &
     &          'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR. C4.EQ.'BR' )  &
     &           THEN                                                   
               NBMIN = 2 
            END IF 
         ELSE IF( C3( 1: 1 ).EQ.'M' ) THEN 
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR. C4.EQ.  &
     &          'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR. C4.EQ.'BR' )  &
     &           THEN                                                   
               NBMIN = 2 
            END IF 
         END IF 
      ELSE IF( CNAME .AND. C2.EQ.'UN' ) THEN 
         IF( C3( 1: 1 ).EQ.'G' ) THEN 
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR. C4.EQ.  &
     &          'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR. C4.EQ.'BR' )  &
     &           THEN                                                   
               NBMIN = 2 
            END IF 
         ELSE IF( C3( 1: 1 ).EQ.'M' ) THEN 
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR. C4.EQ.  &
     &          'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR. C4.EQ.'BR' )  &
     &           THEN                                                   
               NBMIN = 2 
            END IF 
         END IF 
      ELSE IF( C2.EQ.'GG' ) THEN 
         NBMIN = 2 
         IF( C3.EQ.'HD3' ) THEN 
            NBMIN = 2 
         END IF 
      END IF 
      ILAENV = NBMIN 
      RETURN 
!                                                                       
   70 CONTINUE 
!                                                                       
!     ISPEC = 3:  crossover point                                       
!                                                                       
      NX = 0 
      IF( C2.EQ.'GE' ) THEN 
         IF( C3.EQ.'QRF' .OR. C3.EQ.'RQF' .OR. C3.EQ.'LQF' .OR. C3.EQ.  &
     &       'QLF' ) THEN                                               
            IF( SNAME ) THEN 
               NX = 128 
            ELSE 
               NX = 128 
            END IF 
         ELSE IF( C3.EQ.'HRD' ) THEN 
            IF( SNAME ) THEN 
               NX = 128 
            ELSE 
               NX = 128 
            END IF 
         ELSE IF( C3.EQ.'BRD' ) THEN 
            IF( SNAME ) THEN 
               NX = 128 
            ELSE 
               NX = 128 
            END IF 
         END IF 
      ELSE IF( C2.EQ.'SY' ) THEN 
         IF( SNAME .AND. C3.EQ.'TRD' ) THEN 
            NX = 32 
         END IF 
      ELSE IF( CNAME .AND. C2.EQ.'HE' ) THEN 
         IF( C3.EQ.'TRD' ) THEN 
            NX = 32 
         END IF 
      ELSE IF( SNAME .AND. C2.EQ.'OR' ) THEN 
         IF( C3( 1: 1 ).EQ.'G' ) THEN 
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR. C4.EQ.  &
     &          'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR. C4.EQ.'BR' )  &
     &           THEN                                                   
               NX = 128 
            END IF 
         END IF 
      ELSE IF( CNAME .AND. C2.EQ.'UN' ) THEN 
         IF( C3( 1: 1 ).EQ.'G' ) THEN 
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR. C4.EQ.  &
     &          'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR. C4.EQ.'BR' )  &
     &           THEN                                                   
               NX = 128 
            END IF 
         END IF 
      ELSE IF( C2.EQ.'GG' ) THEN 
         NX = 128 
         IF( C3.EQ.'HD3' ) THEN 
            NX = 128 
         END IF 
      END IF 
      ILAENV = NX 
      RETURN 
!                                                                       
   80 CONTINUE 
!                                                                       
!     ISPEC = 4:  number of shifts (used by xHSEQR)                     
!                                                                       
      ILAENV = 6 
      RETURN 
!                                                                       
   90 CONTINUE 
!                                                                       
!     ISPEC = 5:  minimum column dimension (not used)                   
!                                                                       
      ILAENV = 2 
      RETURN 
!                                                                       
  100 CONTINUE 
!                                                                       
!     ISPEC = 6:  crossover point for SVD (used by xGELSS and xGESVD)   
!                                                                       
      ILAENV = INT( REAL( MIN( N1, N2 ) )*1.6E0 ) 
      RETURN 
!                                                                       
  110 CONTINUE 
!                                                                       
!     ISPEC = 7:  number of processors (not used)                       
!                                                                       
      ILAENV = 1 
      RETURN 
!                                                                       
  120 CONTINUE 
!                                                                       
!     ISPEC = 8:  crossover point for multishift (used by xHSEQR)       
!                                                                       
      ILAENV = 50 
      RETURN 
!                                                                       
  130 CONTINUE 
!                                                                       
!     ISPEC = 9:  maximum size of the subproblems at the bottom of the  
!                 computation tree in the divide-and-conquer algorithm  
!                 (used by xGELSD and xGESDD)                           
!                                                                       
      ILAENV = 25 
      RETURN 
!                                                                       
  140 CONTINUE 
!                                                                       
!     ISPEC = 10: ieee NaN arithmetic can be trusted not to trap        
!                                                                       
!     ILAENV = 0                                                        
      ILAENV = 1 
      IF( ILAENV.EQ.1 ) THEN 
         ILAENV = IEEECK( 1, 0.0, 1.0 ) 
      END IF 
      RETURN 
!                                                                       
  150 CONTINUE 
!                                                                       
!     ISPEC = 11: infinity arithmetic can be trusted not to trap        
!                                                                       
!     ILAENV = 0                                                        
      ILAENV = 1 
      IF( ILAENV.EQ.1 ) THEN 
         ILAENV = IEEECK( 0, 0.0, 1.0 ) 
      END IF 
      RETURN 
!                                                                       
  160 CONTINUE 
!                                                                       
!     12 <= ISPEC <= 16: xHSEQR or related subroutines.                 
!                                                                       
      ILAENV = IPARMQ( ISPEC, NAME, OPTS, N1, N2, N3, N4 ) 
      RETURN 
!                                                                       
!     End of ILAENV                                                     
!                                                                       
      END                                           
!> \brief \b ILASLC scans a matrix for its last non-zero column.        
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download ILASLC + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       INTEGER FUNCTION ILASLC( M, N, A, LDA )                         
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            M, N, LDA                                    
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL               A( LDA, * )                                  
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> ILASLC scans A for its last non-zero column.                         
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The number of rows of the matrix A.                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The number of columns of the matrix A.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is REAL array, dimension (LDA,N)                          
!>          The m by n matrix A.                                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>          The leading dimension of the array A. LDA >= max(1,M).      
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2017                                                      
!                                                                       
!> \ingroup realOTHERauxiliary                                          
!                                                                       
!  =====================================================================
      INTEGER FUNCTION ILASLC( M, N, A, LDA ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.1) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2017                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            M, N, LDA 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               A( LDA, * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL             ZERO 
      PARAMETER ( ZERO = 0.0E+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER I 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Quick test for the common case where one corner is non-zero.      
      IF( N.EQ.0 ) THEN 
         ILASLC = N 
      ELSE IF( A(1, N).NE.ZERO .OR. A(M, N).NE.ZERO ) THEN 
         ILASLC = N 
      ELSE 
!     Now scan each column from the end, returning with the first non-ze
         DO ILASLC = N, 1, -1 
            DO I = 1, M 
               IF( A(I, ILASLC).NE.ZERO ) RETURN 
            END DO 
         END DO 
      END IF 
      RETURN 
      END                                           
!> \brief \b ILASLR scans a matrix for its last non-zero row.           
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download ILASLR + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       INTEGER FUNCTION ILASLR( M, N, A, LDA )                         
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            M, N, LDA                                    
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL               A( LDA, * )                                  
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> ILASLR scans A for its last non-zero row.                            
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The number of rows of the matrix A.                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The number of columns of the matrix A.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is REAL array, dimension (LDA,N)                          
!>          The m by n matrix A.                                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>          The leading dimension of the array A. LDA >= max(1,M).      
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup realOTHERauxiliary                                          
!                                                                       
!  =====================================================================
      INTEGER FUNCTION ILASLR( M, N, A, LDA ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            M, N, LDA 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               A( LDA, * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL             ZERO 
      PARAMETER ( ZERO = 0.0E+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER I, J 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Quick test for the common case where one corner is non-zero.      
      IF( M.EQ.0 ) THEN 
         ILASLR = M 
      ELSEIF( A(M, 1).NE.ZERO .OR. A(M, N).NE.ZERO ) THEN 
         ILASLR = M 
      ELSE 
!     Scan up each column tracking the last zero row seen.              
         ILASLR = 0 
         DO J = 1, N 
            I=M 
            DO WHILE((A(MAX(I,1),J).EQ.ZERO).AND.(I.GE.1)) 
               I=I-1 
            ENDDO 
            ILASLR = MAX( ILASLR, I ) 
         END DO 
      END IF 
      RETURN 
!> \brief \b IPARMQ                                                     
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download IPARMQ + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       INTEGER FUNCTION IPARMQ( ISPEC, NAME, OPTS, N, ILO, IHI, LWORK )
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            IHI, ILO, ISPEC, LWORK, N                    
!       CHARACTER          NAME*( * ), OPTS*( * )                       
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>      This program sets problem and machine dependent parameters      
!>      useful for xHSEQR and related subroutines for eigenvalue        
!>      problems. It is called whenever                                 
!>      IPARMQ is called with 12 <= ISPEC <= 16                         
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] ISPEC                                                     
!> \verbatim                                                            
!>          ISPEC is INTEGER                                            
!>              ISPEC specifies which tunable parameter IPARMQ should   
!>              return.                                                 
!>                                                                      
!>              ISPEC=12: (INMIN)  Matrices of order nmin or less       
!>                        are sent directly to xLAHQR, the implicit     
!>                        double shift QR algorithm.  NMIN must be      
!>                        at least 11.                                  
!>                                                                      
!>              ISPEC=13: (INWIN)  Size of the deflation window.        
!>                        This is best set greater than or equal to     
!>                        the number of simultaneous shifts NS.         
!>                        Larger matrices benefit from larger deflation 
!>                        windows.                                      
!>                                                                      
!>              ISPEC=14: (INIBL) Determines when to stop nibbling and  
!>                        invest in an (expensive) multi-shift QR sweep.
!>                        If the aggressive early deflation subroutine  
!>                        finds LD converged eigenvalues from an order  
!>                        NW deflation window and LD > (NW*NIBBLE)/100, 
!>                        then the next QR sweep is skipped and early   
!>                        deflation is applied immediately to the       
!>                        remaining active diagonal block.  Setting     
!>                        IPARMQ(ISPEC=14) = 0 causes TTQRE to skip a   
!>                        multi-shift QR sweep whenever early deflation 
!>                        finds a converged eigenvalue.  Setting        
!>                        IPARMQ(ISPEC=14) greater than or equal to 100 
!>                        prevents TTQRE from skipping a multi-shift    
!>                        QR sweep.                                     
!>                                                                      
!>              ISPEC=15: (NSHFTS) The number of simultaneous shifts in 
!>                        a multi-shift QR iteration.                   
!>                                                                      
!>              ISPEC=16: (IACC22) IPARMQ is set to 0, 1 or 2 with the  
!>                        following meanings.                           
!>                        0:  During the multi-shift QR/QZ sweep,       
!>                            blocked eigenvalue reordering, blocked    
!>                            Hessenberg-triangular reduction,          
!>                            reflections and/or rotations are not      
!>                            accumulated when updating the             
!>                            far-from-diagonal matrix entries.         
!>                        1:  During the multi-shift QR/QZ sweep,       
!>                            blocked eigenvalue reordering, blocked    
!>                            Hessenberg-triangular reduction,          
!>                            reflections and/or rotations are          
!>                            accumulated, and matrix-matrix            
!>                            multiplication is used to update the      
!>                            far-from-diagonal matrix entries.         
!>                        2:  During the multi-shift QR/QZ sweep,       
!>                            blocked eigenvalue reordering, blocked    
!>                            Hessenberg-triangular reduction,          
!>                            reflections and/or rotations are          
!>                            accumulated, and 2-by-2 block structure   
!>                            is exploited during matrix-matrix         
!>                            multiplies.                               
!>                        (If xTRMM is slower than xGEMM, then          
!>                        IPARMQ(ISPEC=16)=1 may be more efficient than 
!>                        IPARMQ(ISPEC=16)=2 despite the greater level o
!>                        arithmetic work implied by the latter choice.)
!> \endverbatim                                                         
!>                                                                      
!> \param[in] NAME                                                      
!> \verbatim                                                            
!>          NAME is CHARACTER string                                    
!>               Name of the calling subroutine                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] OPTS                                                      
!> \verbatim                                                            
!>          OPTS is CHARACTER string                                    
!>               This is a concatenation of the string arguments to     
!>               TTQRE.                                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>               N is the order of the Hessenberg matrix H.             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ILO                                                       
!> \verbatim                                                            
!>          ILO is INTEGER                                              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IHI                                                       
!> \verbatim                                                            
!>          IHI is INTEGER                                              
!>               It is assumed that H is already upper triangular       
!>               in rows and columns 1:ILO-1 and IHI+1:N.               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LWORK                                                     
!> \verbatim                                                            
!>          LWORK is INTEGER                                            
!>               The amount of workspace available.                     
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2017                                                      
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>       Little is known about how best to choose these parameters.     
!>       It is possible to use different values of the parameters       
!>       for each of CHSEQR, DHSEQR, SHSEQR and ZHSEQR.                 
!>                                                                      
!>       It is probably best to choose different parameters for         
!>       different matrices and different parameters at different       
!>       times during the iteration, but this has not been              
!>       implemented --- yet.                                           
!>                                                                      
!>                                                                      
!>       The best choices of most of the parameters depend              
!>       in an ill-understood way on the relative execution             
!>       rate of xLAQR3 and xLAQR5 and on the nature of each            
!>       particular eigenvalue problem.  Experiment may be the          
!>       only practical way to determine which choices are most         
!>       effective.                                                     
!>                                                                      
!>       Following is a list of default values supplied by IPARMQ.      
!>       These defaults may be adjusted in order to attain better       
!>       performance in any particular computational environment.       
!>                                                                      
!>       IPARMQ(ISPEC=12) The xLAHQR vs xLAQR0 crossover point.         
!>                        Default: 75. (Must be at least 11.)           
!>                                                                      
!>       IPARMQ(ISPEC=13) Recommended deflation window size.            
!>                        This depends on ILO, IHI and NS, the          
!>                        number of simultaneous shifts returned        
!>                        by IPARMQ(ISPEC=15).  The default for         
!>                        (IHI-ILO+1) <= 500 is NS.  The default        
!>                        for (IHI-ILO+1) > 500 is 3*NS/2.              
!>                                                                      
!>       IPARMQ(ISPEC=14) Nibble crossover point.  Default: 14.         
!>                                                                      
!>       IPARMQ(ISPEC=15) Number of simultaneous shifts, NS.            
!>                        a multi-shift QR iteration.                   
!>                                                                      
!>                        If IHI-ILO+1 is ...                           
!>                                                                      
!>                        greater than      ...but less    ... the      
!>                        or equal to ...      than        default is   
!>                                                                      
!>                                0               30       NS =   2+    
!>                               30               60       NS =   4+    
      END                                           
!>                               60              150       NS =  10     
!>                              150              590       NS =  **     
!>                              590             3000       NS =  64     
!>                             3000             6000       NS = 128     
!>                             6000             infinity   NS = 256     
!>                                                                      
!>                    (+)  By default matrices of this order are        
!>                         passed to the implicit double shift routine  
!>                         xLAHQR.  See IPARMQ(ISPEC=12) above.   These 
!>                         values of NS are used only in case of a rare 
!>                         xLAHQR failure.                              
!>                                                                      
!>                    (**) The asterisks (**) indicate an ad-hoc        
!>                         function increasing from 10 to 64.           
!>                                                                      
!>       IPARMQ(ISPEC=16) Select structured matrix multiply.            
!>                        (See ISPEC=16 above for details.)             
!>                        Default: 3.                                   
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      INTEGER FUNCTION IPARMQ( ISPEC, NAME, OPTS, N, ILO, IHI, LWORK ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.1) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2017                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            IHI, ILO, ISPEC, LWORK, N 
      CHARACTER          NAME*( * ), OPTS*( * ) 
!                                                                       
!  ================================================================     
!     .. Parameters ..                                                  
      INTEGER            INMIN, INWIN, INIBL, ISHFTS, IACC22 
      PARAMETER          ( INMIN = 12, INWIN = 13, INIBL = 14,          &
     &                   ISHFTS = 15, IACC22 = 16 )                     
      INTEGER            NMIN, K22MIN, KACMIN, NIBBLE, KNWSWP 
      PARAMETER          ( NMIN = 75, K22MIN = 14, KACMIN = 14,         &
     &                   NIBBLE = 14, KNWSWP = 500 )                    
      REAL               TWO 
      PARAMETER          ( TWO = 2.0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            NH, NS 
      INTEGER            I, IC, IZ 
      CHARACTER          SUBNAM*6 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          LOG, MAX, MOD, NINT, REAL 
!     ..                                                                
!     .. Executable Statements ..                                       
      IF( ( ISPEC.EQ.ISHFTS ) .OR. ( ISPEC.EQ.INWIN ) .OR.              &
     &    ( ISPEC.EQ.IACC22 ) ) THEN                                    
!                                                                       
!        ==== Set the number simultaneous shifts ====                   
!                                                                       
         NH = IHI - ILO + 1 
         NS = 2 
         IF( NH.GE.30 )                                                 &
     &      NS = 4                                                      
         IF( NH.GE.60 )                                                 &
     &      NS = 10                                                     
         IF( NH.GE.150 )                                                &
     &      NS = MAX( 10, NH / NINT( LOG( REAL( NH ) ) / LOG( TWO ) ) ) 
         IF( NH.GE.590 )                                                &
     &      NS = 64                                                     
         IF( NH.GE.3000 )                                               &
     &      NS = 128                                                    
         IF( NH.GE.6000 )                                               &
     &      NS = 256                                                    
         NS = MAX( 2, NS-MOD( NS, 2 ) ) 
      END IF 
!                                                                       
      IF( ISPEC.EQ.INMIN ) THEN 
!                                                                       
!                                                                       
!        ===== Matrices of order smaller than NMIN get sent             
!        .     to xLAHQR, the classic double shift algorithm.           
!        .     This must be at least 11. ====                           
!                                                                       
         IPARMQ = NMIN 
!                                                                       
      ELSE IF( ISPEC.EQ.INIBL ) THEN 
!                                                                       
!        ==== INIBL: skip a multi-shift qr iteration and                
!        .    whenever aggressive early deflation finds                 
!        .    at least (NIBBLE*(window size)/100) deflations. ====      
!                                                                       
         IPARMQ = NIBBLE 
!                                                                       
      ELSE IF( ISPEC.EQ.ISHFTS ) THEN 
!                                                                       
!        ==== NSHFTS: The number of simultaneous shifts =====           
!                                                                       
         IPARMQ = NS 
!                                                                       
      ELSE IF( ISPEC.EQ.INWIN ) THEN 
!                                                                       
!        ==== NW: deflation window size.  ====                          
!                                                                       
         IF( NH.LE.KNWSWP ) THEN 
            IPARMQ = NS 
         ELSE 
            IPARMQ = 3*NS / 2 
         END IF 
!                                                                       
      ELSE IF( ISPEC.EQ.IACC22 ) THEN 
!                                                                       
!        ==== IACC22: Whether to accumulate reflections                 
!        .     before updating the far-from-diagonal elements           
!        .     and whether to use 2-by-2 block structure while          
!        .     doing it.  A small amount of work could be saved         
!        .     by making this choice dependent also upon the            
!        .     NH=IHI-ILO+1.                                            
!                                                                       
!                                                                       
!        Convert NAME to upper case if the first character is lower case
!                                                                       
         IPARMQ = 0 
         SUBNAM = NAME 
         IC = ICHAR( SUBNAM( 1: 1 ) ) 
         IZ = ICHAR( 'Z' ) 
         IF( IZ.EQ.90 .OR. IZ.EQ.122 ) THEN 
!                                                                       
!           ASCII character set                                         
!                                                                       
            IF( IC.GE.97 .AND. IC.LE.122 ) THEN 
               SUBNAM( 1: 1 ) = CHAR( IC-32 ) 
               DO I = 2, 6 
                  IC = ICHAR( SUBNAM( I: I ) ) 
                  IF( IC.GE.97 .AND. IC.LE.122 )                        &
     &               SUBNAM( I: I ) = CHAR( IC-32 )                     
               END DO 
            END IF 
!                                                                       
         ELSE IF( IZ.EQ.233 .OR. IZ.EQ.169 ) THEN 
!                                                                       
!           EBCDIC character set                                        
!                                                                       
            IF( ( IC.GE.129 .AND. IC.LE.137 ) .OR.                      &
     &          ( IC.GE.145 .AND. IC.LE.153 ) .OR.                      &
     &          ( IC.GE.162 .AND. IC.LE.169 ) ) THEN                    
               SUBNAM( 1: 1 ) = CHAR( IC+64 ) 
               DO I = 2, 6 
                  IC = ICHAR( SUBNAM( I: I ) ) 
                  IF( ( IC.GE.129 .AND. IC.LE.137 ) .OR.                &
     &                ( IC.GE.145 .AND. IC.LE.153 ) .OR.                &
     &                ( IC.GE.162 .AND. IC.LE.169 ) )SUBNAM( I:         &
     &                I ) = CHAR( IC+64 )                               
               END DO 
            END IF 
!                                                                       
         ELSE IF( IZ.EQ.218 .OR. IZ.EQ.250 ) THEN 
!                                                                       
!           Prime machines:  ASCII+128                                  
!                                                                       
            IF( IC.GE.225 .AND. IC.LE.250 ) THEN 
               SUBNAM( 1: 1 ) = CHAR( IC-32 ) 
               DO I = 2, 6 
                  IC = ICHAR( SUBNAM( I: I ) ) 
                  IF( IC.GE.225 .AND. IC.LE.250 )                       &
     &               SUBNAM( I: I ) = CHAR( IC-32 )                     
               END DO 
            END IF 
         END IF 
!                                                                       
         IF( SUBNAM( 2:6 ).EQ.'GGHRD' .OR.                              &
     &       SUBNAM( 2:6 ).EQ.'GGHD3' ) THEN                            
            IPARMQ = 1 
            IF( NH.GE.K22MIN )                                          &
     &         IPARMQ = 2                                               
         ELSE IF ( SUBNAM( 4:6 ).EQ.'EXC' ) THEN 
            IF( NH.GE.KACMIN )                                          &
     &         IPARMQ = 1                                               
            IF( NH.GE.K22MIN )                                          &
     &         IPARMQ = 2                                               
         ELSE IF ( SUBNAM( 2:6 ).EQ.'HSEQR' .OR.                        &
     &             SUBNAM( 2:5 ).EQ.'LAQR' ) THEN                       
            IF( NS.GE.KACMIN )                                          &
     &         IPARMQ = 1                                               
            IF( NS.GE.K22MIN )                                          &
     &         IPARMQ = 2                                               
         END IF 
!                                                                       
      ELSE 
!        ===== invalid value of ispec =====                             
         IPARMQ = -1 
!                                                                       
      END IF 
!                                                                       
!     ==== End of IPARMQ ====                                           
!                                                                       
      END                                           
!> \brief \b ISAMAX                                                     
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       INTEGER FUNCTION ISAMAX(N,SX,INCX)                              
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER INCX,N                                                  
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL SX(*)                                                      
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>    ISAMAX finds the index of the first element having maximum absolut
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>         number of elements in input vector(s)                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] SX                                                        
!> \verbatim                                                            
!>          SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) )   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCX                                                      
!> \verbatim                                                            
!>          INCX is INTEGER                                             
!>         storage spacing between elements of SX                       
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date November 2017                                                  
!                                                                       
!> \ingroup aux_blas                                                    
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>     jack dongarra, linpack, 3/11/78.                                 
!>     modified 3/93 to return if incx .le. 0.                          
!>     modified 12/3/93, array(1) declarations changed to array(*)      
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      INTEGER FUNCTION ISAMAX(N,SX,INCX) 
!                                                                       
!  -- Reference BLAS level1 routine (version 3.8.0) --                  
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     November 2017                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER INCX,N 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL SX(*) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Local Scalars ..                                               
      REAL SMAX 
      INTEGER I,IX 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC ABS 
!     ..                                                                
      ISAMAX = 0 
      IF (N.LT.1 .OR. INCX.LE.0) RETURN 
      ISAMAX = 1 
      IF (N.EQ.1) RETURN 
      IF (INCX.EQ.1) THEN 
!                                                                       
!        code for increment equal to 1                                  
!                                                                       
         SMAX = ABS(SX(1)) 
         DO I = 2,N 
            IF (ABS(SX(I)).GT.SMAX) THEN 
               ISAMAX = I 
               SMAX = ABS(SX(I)) 
            END IF 
         END DO 
      ELSE 
!                                                                       
!        code for increment not equal to 1                              
!                                                                       
         IX = 1 
         SMAX = ABS(SX(1)) 
         IX = IX + INCX 
         DO I = 2,N 
            IF (ABS(SX(IX)).GT.SMAX) THEN 
               ISAMAX = I 
               SMAX = ABS(SX(IX)) 
            END IF 
            IX = IX + INCX 
         END DO 
      END IF 
      RETURN 
      END                                           
!> \brief \b LSAME                                                      
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       LOGICAL FUNCTION LSAME(CA,CB)                                   
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER CA,CB                                                 
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> LSAME returns .TRUE. if CA is the same letter as CB regardless of    
!> case.                                                                
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] CA                                                        
!> \verbatim                                                            
!>          CA is CHARACTER*1                                           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] CB                                                        
!> \verbatim                                                            
!>          CB is CHARACTER*1                                           
!>          CA and CB specify the single characters to be compared.     
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup aux_blas                                                    
!                                                                       
!  =====================================================================
      LOGICAL FUNCTION LSAME(CA,CB) 
!                                                                       
!  -- Reference BLAS level1 routine (version 3.1) --                    
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER CA,CB 
!     ..                                                                
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Intrinsic Functions ..                                         
      INTRINSIC ICHAR 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER INTA,INTB,ZCODE 
!     ..                                                                
!                                                                       
!     Test if the characters are equal                                  
!                                                                       
      LSAME = CA .EQ. CB 
      IF (LSAME) RETURN 
!                                                                       
!     Now test for equivalence if both characters are alphabetic.       
!                                                                       
      ZCODE = ICHAR('Z') 
!                                                                       
!     Use 'Z' rather than 'A' so that ASCII can be detected on Prime    
!     machines, on which ICHAR returns a value with bit 8 set.          
!     ICHAR('A') on Prime machines returns 193 which is the same as     
!     ICHAR('A') on an EBCDIC machine.                                  
!                                                                       
      INTA = ICHAR(CA) 
      INTB = ICHAR(CB) 
!                                                                       
      IF (ZCODE.EQ.90 .OR. ZCODE.EQ.122) THEN 
!                                                                       
!        ASCII is assumed - ZCODE is the ASCII code of either lower or  
!        upper case 'Z'.                                                
!                                                                       
          IF (INTA.GE.97 .AND. INTA.LE.122) INTA = INTA - 32 
          IF (INTB.GE.97 .AND. INTB.LE.122) INTB = INTB - 32 
!                                                                       
      ELSE IF (ZCODE.EQ.233 .OR. ZCODE.EQ.169) THEN 
!                                                                       
!        EBCDIC is assumed - ZCODE is the EBCDIC code of either lower or
!        upper case 'Z'.                                                
!                                                                       
          IF (INTA.GE.129 .AND. INTA.LE.137 .OR.                        &
     &        INTA.GE.145 .AND. INTA.LE.153 .OR.                        &
     &        INTA.GE.162 .AND. INTA.LE.169) INTA = INTA + 64           
          IF (INTB.GE.129 .AND. INTB.LE.137 .OR.                        &
     &        INTB.GE.145 .AND. INTB.LE.153 .OR.                        &
     &        INTB.GE.162 .AND. INTB.LE.169) INTB = INTB + 64           
!                                                                       
      ELSE IF (ZCODE.EQ.218 .OR. ZCODE.EQ.250) THEN 
!                                                                       
!        ASCII is assumed, on Prime machines - ZCODE is the ASCII code  
!        plus 128 of either lower or upper case 'Z'.                    
!                                                                       
          IF (INTA.GE.225 .AND. INTA.LE.250) INTA = INTA - 32 
          IF (INTB.GE.225 .AND. INTB.LE.250) INTB = INTB - 32 
      END IF 
      LSAME = INTA .EQ. INTB 
!                                                                       
!     RETURN                                                            
!                                                                       
!     End of LSAME                                                      
!                                                                       
      END                                           
!> \brief \b SAXPY                                                      
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SAXPY(N,SA,SX,INCX,SY,INCY)                          
!                                                                       
!       .. Scalar Arguments ..                                          
!       REAL SA                                                         
!       INTEGER INCX,INCY,N                                             
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL SX(*),SY(*)                                                
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>    SAXPY constant times a vector plus a vector.                      
!>    uses unrolled loops for increments equal to one.                  
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>         number of elements in input vector(s)                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] SA                                                        
!> \verbatim                                                            
!>          SA is REAL                                                  
!>           On entry, SA specifies the scalar alpha.                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] SX                                                        
!> \verbatim                                                            
!>          SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) )   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCX                                                      
!> \verbatim                                                            
!>          INCX is INTEGER                                             
!>         storage spacing between elements of SX                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] SY                                                    
!> \verbatim                                                            
!>          SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCY ) )   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCY                                                      
!> \verbatim                                                            
!>          INCY is INTEGER                                             
!>         storage spacing between elements of SY                       
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date November 2017                                                  
!                                                                       
!> \ingroup single_blas_level1                                          
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>     jack dongarra, linpack, 3/11/78.                                 
!>     modified 12/3/93, array(1) declarations changed to array(*)      
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE SAXPY(N,SA,SX,INCX,SY,INCY) 
!                                                                       
!  -- Reference BLAS level1 routine (version 3.8.0) --                  
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     November 2017                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      REAL SA 
      INTEGER INCX,INCY,N 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL SX(*),SY(*) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Local Scalars ..                                               
      INTEGER I,IX,IY,M,MP1 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC MOD 
!     ..                                                                
      IF (N.LE.0) RETURN 
      IF (SA.EQ.0.0) RETURN 
      IF (INCX.EQ.1 .AND. INCY.EQ.1) THEN 
!                                                                       
!        code for both increments equal to 1                            
!                                                                       
!                                                                       
!        clean-up loop                                                  
!                                                                       
         M = MOD(N,4) 
         IF (M.NE.0) THEN 
            DO I = 1,M 
               SY(I) = SY(I) + SA*SX(I) 
            END DO 
         END IF 
         IF (N.LT.4) RETURN 
         MP1 = M + 1 
         DO I = MP1,N,4 
            SY(I) = SY(I) + SA*SX(I) 
            SY(I+1) = SY(I+1) + SA*SX(I+1) 
            SY(I+2) = SY(I+2) + SA*SX(I+2) 
            SY(I+3) = SY(I+3) + SA*SX(I+3) 
         END DO 
      ELSE 
!                                                                       
!        code for unequal increments or equal increments                
!          not equal to 1                                               
!                                                                       
         IX = 1 
         IY = 1 
         IF (INCX.LT.0) IX = (-N+1)*INCX + 1 
         IF (INCY.LT.0) IY = (-N+1)*INCY + 1 
         DO I = 1,N 
          SY(IY) = SY(IY) + SA*SX(IX) 
          IX = IX + INCX 
          IY = IY + INCY 
         END DO 
      END IF 
      RETURN 
      END                                           
!> \brief \b SCOMBSSQ adds two scaled sum of squares quantities         
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SCOMBSSQ( V1, V2 )                                   
!                                                                       
!       .. Array Arguments ..                                           
!       REAL               V1( 2 ), V2( 2 )                             
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SCOMBSSQ adds two scaled sum of squares quantities, V1 := V1 + V2.   
!> That is,                                                             
!>                                                                      
!>    V1_scale**2 * V1_sumsq := V1_scale**2 * V1_sumsq                  
!>                            + V2_scale**2 * V2_sumsq                  
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in,out] V1                                                    
!> \verbatim                                                            
!>          V1 is REAL array, dimension (2).                            
!>          The first scaled sum.                                       
!>          V1(1) = V1_scale, V1(2) = V1_sumsq.                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] V2                                                        
!> \verbatim                                                            
!>          V2 is REAL array, dimension (2).                            
!>          The second scaled sum.                                      
!>          V2(1) = V2_scale, V2(2) = V2_sumsq.                         
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date November 2018                                                  
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!  =====================================================================
      SUBROUTINE SCOMBSSQ( V1, V2 ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     November 2018                                                     
!                                                                       
!     .. Array Arguments ..                                             
      REAL               V1( 2 ), V2( 2 ) 
!     ..                                                                
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Parameters ..                                                  
      REAL               ZERO 
      PARAMETER          ( ZERO = 0.0D+0 ) 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      IF( V1( 1 ).GE.V2( 1 ) ) THEN 
         IF( V1( 1 ).NE.ZERO ) THEN 
            V1( 2 ) = V1( 2 ) + ( V2( 1 ) / V1( 1 ) )**2 * V2( 2 ) 
         ELSE 
            V1( 2 ) = V1( 2 ) + V2( 2 ) 
         END IF 
      ELSE 
         V1( 2 ) = V2( 2 ) + ( V1( 1 ) / V2( 1 ) )**2 * V1( 2 ) 
         V1( 1 ) = V2( 1 ) 
      END IF 
      RETURN 
!                                                                       
!     End of SCOMBSSQ                                                   
!                                                                       
      END                                           
!> \brief \b SCOPY                                                      
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SCOPY(N,SX,INCX,SY,INCY)                             
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER INCX,INCY,N                                             
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL SX(*),SY(*)                                                
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>    SCOPY copies a vector, x, to a vector, y.                         
!>    uses unrolled loops for increments equal to 1.                    
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>         number of elements in input vector(s)                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] SX                                                        
!> \verbatim                                                            
!>          SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) )   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCX                                                      
!> \verbatim                                                            
!>          INCX is INTEGER                                             
!>         storage spacing between elements of SX                       
!> \endverbatim                                                         
!>                                                                      
!> \param[out] SY                                                       
!> \verbatim                                                            
!>          SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCY ) )   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCY                                                      
!> \verbatim                                                            
!>          INCY is INTEGER                                             
!>         storage spacing between elements of SY                       
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date November 2017                                                  
!                                                                       
!> \ingroup single_blas_level1                                          
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>     jack dongarra, linpack, 3/11/78.                                 
!>     modified 12/3/93, array(1) declarations changed to array(*)      
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE SCOPY(N,SX,INCX,SY,INCY) 
!                                                                       
!  -- Reference BLAS level1 routine (version 3.8.0) --                  
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     November 2017                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER INCX,INCY,N 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL SX(*),SY(*) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Local Scalars ..                                               
      INTEGER I,IX,IY,M,MP1 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC MOD 
!     ..                                                                
      IF (N.LE.0) RETURN 
      IF (INCX.EQ.1 .AND. INCY.EQ.1) THEN 
!                                                                       
!        code for both increments equal to 1                            
!                                                                       
!                                                                       
!        clean-up loop                                                  
!                                                                       
         M = MOD(N,7) 
         IF (M.NE.0) THEN 
            DO I = 1,M 
               SY(I) = SX(I) 
            END DO 
            IF (N.LT.7) RETURN 
         END IF 
         MP1 = M + 1 
         DO I = MP1,N,7 
            SY(I) = SX(I) 
            SY(I+1) = SX(I+1) 
            SY(I+2) = SX(I+2) 
            SY(I+3) = SX(I+3) 
            SY(I+4) = SX(I+4) 
            SY(I+5) = SX(I+5) 
            SY(I+6) = SX(I+6) 
         END DO 
      ELSE 
!                                                                       
!        code for unequal increments or equal increments                
!          not equal to 1                                               
!                                                                       
         IX = 1 
         IY = 1 
         IF (INCX.LT.0) IX = (-N+1)*INCX + 1 
         IF (INCY.LT.0) IY = (-N+1)*INCY + 1 
         DO I = 1,N 
            SY(IY) = SX(IX) 
            IX = IX + INCX 
            IY = IY + INCY 
         END DO 
      END IF 
      RETURN 
      END                                           
!> \brief \b SDOT                                                       
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       REAL FUNCTION SDOT(N,SX,INCX,SY,INCY)                           
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER INCX,INCY,N                                             
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL SX(*),SY(*)                                                
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>    SDOT forms the dot product of two vectors.                        
!>    uses unrolled loops for increments equal to one.                  
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>         number of elements in input vector(s)                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] SX                                                        
!> \verbatim                                                            
!>          SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) )   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCX                                                      
!> \verbatim                                                            
!>          INCX is INTEGER                                             
!>         storage spacing between elements of SX                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] SY                                                        
!> \verbatim                                                            
!>          SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCY ) )   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCY                                                      
!> \verbatim                                                            
!>          INCY is INTEGER                                             
!>         storage spacing between elements of SY                       
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date November 2017                                                  
!                                                                       
!> \ingroup single_blas_level1                                          
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>     jack dongarra, linpack, 3/11/78.                                 
!>     modified 12/3/93, array(1) declarations changed to array(*)      
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      REAL FUNCTION SDOT(N,SX,INCX,SY,INCY) 
!                                                                       
!  -- Reference BLAS level1 routine (version 3.8.0) --                  
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     November 2017                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER INCX,INCY,N 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL SX(*),SY(*) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Local Scalars ..                                               
      REAL STEMP 
      INTEGER I,IX,IY,M,MP1 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC MOD 
!     ..                                                                
      STEMP = 0.0e0 
      SDOT = 0.0e0 
      IF (N.LE.0) RETURN 
      IF (INCX.EQ.1 .AND. INCY.EQ.1) THEN 
!                                                                       
!        code for both increments equal to 1                            
!                                                                       
!                                                                       
!        clean-up loop                                                  
!                                                                       
         M = MOD(N,5) 
         IF (M.NE.0) THEN 
            DO I = 1,M 
               STEMP = STEMP + SX(I)*SY(I) 
            END DO 
            IF (N.LT.5) THEN 
               SDOT=STEMP 
            RETURN 
            END IF 
         END IF 
         MP1 = M + 1 
         DO I = MP1,N,5 
          STEMP = STEMP + SX(I)*SY(I) + SX(I+1)*SY(I+1) +               &
     &            SX(I+2)*SY(I+2) + SX(I+3)*SY(I+3) + SX(I+4)*SY(I+4)   
         END DO 
      ELSE 
!                                                                       
!        code for unequal increments or equal increments                
!          not equal to 1                                               
!                                                                       
         IX = 1 
         IY = 1 
         IF (INCX.LT.0) IX = (-N+1)*INCX + 1 
         IF (INCY.LT.0) IY = (-N+1)*INCY + 1 
         DO I = 1,N 
            STEMP = STEMP + SX(IX)*SY(IY) 
            IX = IX + INCX 
            IY = IY + INCY 
         END DO 
      END IF 
      SDOT = STEMP 
      RETURN 
      END                                           
!> \brief \b SGEMM                                                      
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LD
!                                                                       
!       .. Scalar Arguments ..                                          
!       REAL ALPHA,BETA                                                 
!       INTEGER K,LDA,LDB,LDC,M,N                                       
!       CHARACTER TRANSA,TRANSB                                         
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL A(LDA,*),B(LDB,*),C(LDC,*)                                 
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SGEMM  performs one of the matrix-matrix operations                  
!>                                                                      
!>    C := alpha*op( A )*op( B ) + beta*C,                              
!>                                                                      
!> where  op( X ) is one of                                             
!>                                                                      
!>    op( X ) = X   or   op( X ) = X**T,                                
!>                                                                      
!> alpha and beta are scalars, and A, B and C are matrices, with op( A )
!> an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] TRANSA                                                    
!> \verbatim                                                            
!>          TRANSA is CHARACTER*1                                       
!>           On entry, TRANSA specifies the form of op( A ) to be used i
!>           the matrix multiplication as follows:                      
!>                                                                      
!>              TRANSA = 'N' or 'n',  op( A ) = A.                      
!>                                                                      
!>              TRANSA = 'T' or 't',  op( A ) = A**T.                   
!>                                                                      
!>              TRANSA = 'C' or 'c',  op( A ) = A**T.                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TRANSB                                                    
!> \verbatim                                                            
!>          TRANSB is CHARACTER*1                                       
!>           On entry, TRANSB specifies the form of op( B ) to be used i
!>           the matrix multiplication as follows:                      
!>                                                                      
!>              TRANSB = 'N' or 'n',  op( B ) = B.                      
!>                                                                      
!>              TRANSB = 'T' or 't',  op( B ) = B**T.                   
!>                                                                      
!>              TRANSB = 'C' or 'c',  op( B ) = B**T.                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>           On entry,  M  specifies  the number  of rows  of the  matri
!>           op( A )  and of the  matrix  C.  M  must  be at least  zero
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>           On entry,  N  specifies the number  of columns of the matri
!>           op( B ) and the number of columns of the matrix C. N must b
!>           at least zero.                                             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] K                                                         
!> \verbatim                                                            
!>          K is INTEGER                                                
!>           On entry,  K  specifies  the number of columns of the matri
!>           op( A ) and the number of rows of the matrix op( B ). K mus
!>           be at least  zero.                                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ALPHA                                                     
!> \verbatim                                                            
!>          ALPHA is REAL                                               
!>           On entry, ALPHA specifies the scalar alpha.                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is REAL array, dimension ( LDA, ka ), where ka is         
!>           k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.       
!>           Before entry with  TRANSA = 'N' or 'n',  the leading  m by 
!>           part of the array  A  must contain the matrix  A,  otherwis
!>           the leading  k by m  part of the array  A  must contain  th
!>           matrix A.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>           On entry, LDA specifies the first dimension of A as declare
!>           in the calling (sub) program. When  TRANSA = 'N' or 'n' the
!>           LDA must be at least  max( 1, m ), otherwise  LDA must be a
!>           least  max( 1, k ).                                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] B                                                         
!> \verbatim                                                            
!>          B is REAL array, dimension ( LDB, kb ), where kb is         
!>           n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.       
!>           Before entry with  TRANSB = 'N' or 'n',  the leading  k by 
!>           part of the array  B  must contain the matrix  B,  otherwis
!>           the leading  n by k  part of the array  B  must contain  th
!>           matrix B.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDB                                                       
!> \verbatim                                                            
!>          LDB is INTEGER                                              
!>           On entry, LDB specifies the first dimension of B as declare
!>           in the calling (sub) program. When  TRANSB = 'N' or 'n' the
!>           LDB must be at least  max( 1, k ), otherwise  LDB must be a
!>           least  max( 1, n ).                                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] BETA                                                      
!> \verbatim                                                            
!>          BETA is REAL                                                
!>           On entry,  BETA  specifies the scalar  beta.  When  BETA  i
!>           supplied as zero then C need not be set on input.          
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] C                                                     
!> \verbatim                                                            
!>          C is REAL array, dimension ( LDC, N )                       
!>           Before entry, the leading  m by n  part of the array  C mus
!>           contain the matrix  C,  except when  beta  is zero, in whic
!>           case C need not be set on entry.                           
!>           On exit, the array  C  is overwritten by the  m by n  matri
!>           ( alpha*op( A )*op( B ) + beta*C ).                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDC                                                       
!> \verbatim                                                            
!>          LDC is INTEGER                                              
!>           On entry, LDC specifies the first dimension of C as declare
!>           in  the  calling  (sub)  program.   LDC  must  be  at  leas
!>           max( 1, m ).                                               
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup single_blas_level3                                          
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  Level 3 Blas routine.                                               
!>                                                                      
!>  -- Written on 8-February-1989.                                      
!>     Jack Dongarra, Argonne National Laboratory.                      
!>     Iain Duff, AERE Harwell.                                         
!>     Jeremy Du Croz, Numerical Algorithms Group Ltd.                  
!>     Sven Hammarling, Numerical Algorithms Group Ltd.                 
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE SGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC) 
!                                                                       
!  -- Reference BLAS level3 routine (version 3.7.0) --                  
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      REAL ALPHA,BETA 
      INTEGER K,LDA,LDB,LDC,M,N 
      CHARACTER TRANSA,TRANSB 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL A(LDA,*),B(LDB,*),C(LDC,*) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. External Functions ..                                          
      LOGICAL LSAME 
      EXTERNAL LSAME 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL XERBLA 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC MAX 
!     ..                                                                
!     .. Local Scalars ..                                               
      REAL TEMP 
      INTEGER I,INFO,J,L,NCOLA,NROWA,NROWB 
      LOGICAL NOTA,NOTB 
!     ..                                                                
!     .. Parameters ..                                                  
      REAL ONE,ZERO 
      PARAMETER (ONE=1.0E+0,ZERO=0.0E+0) 
!     ..                                                                
!                                                                       
!     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not
!     transposed and set  NROWA, NCOLA and  NROWB  as the number of rows
!     and  columns of  A  and the  number of  rows  of  B  respectively.
!                                                                       
      NOTA = LSAME(TRANSA,'N') 
      NOTB = LSAME(TRANSB,'N') 
      IF (NOTA) THEN 
          NROWA = M 
          NCOLA = K 
      ELSE 
          NROWA = K 
          NCOLA = M 
      END IF 
      IF (NOTB) THEN 
          NROWB = K 
      ELSE 
          NROWB = N 
      END IF 
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0 
      IF ((.NOT.NOTA) .AND. (.NOT.LSAME(TRANSA,'C')) .AND.              &
     &    (.NOT.LSAME(TRANSA,'T'))) THEN                                
          INFO = 1 
      ELSE IF ((.NOT.NOTB) .AND. (.NOT.LSAME(TRANSB,'C')) .AND.         &
     &         (.NOT.LSAME(TRANSB,'T'))) THEN                           
          INFO = 2 
      ELSE IF (M.LT.0) THEN 
          INFO = 3 
      ELSE IF (N.LT.0) THEN 
          INFO = 4 
      ELSE IF (K.LT.0) THEN 
          INFO = 5 
      ELSE IF (LDA.LT.MAX(1,NROWA)) THEN 
          INFO = 8 
      ELSE IF (LDB.LT.MAX(1,NROWB)) THEN 
          INFO = 10 
      ELSE IF (LDC.LT.MAX(1,M)) THEN 
          INFO = 13 
      END IF 
      IF (INFO.NE.0) THEN 
          CALL XERBLA('SGEMM ',INFO) 
          RETURN 
      END IF 
!                                                                       
!     Quick return if possible.                                         
!                                                                       
      IF ((M.EQ.0) .OR. (N.EQ.0) .OR.                                   &
     &    (((ALPHA.EQ.ZERO).OR. (K.EQ.0)).AND. (BETA.EQ.ONE))) RETURN   
!                                                                       
!     And if  alpha.eq.zero.                                            
!                                                                       
      IF (ALPHA.EQ.ZERO) THEN 
          IF (BETA.EQ.ZERO) THEN 
              DO 20 J = 1,N 
                  DO 10 I = 1,M 
                      C(I,J) = ZERO 
   10             CONTINUE 
   20         CONTINUE 
          ELSE 
              DO 40 J = 1,N 
                  DO 30 I = 1,M 
                      C(I,J) = BETA*C(I,J) 
   30             CONTINUE 
   40         CONTINUE 
          END IF 
          RETURN 
      END IF 
!                                                                       
!     Start the operations.                                             
!                                                                       
      IF (NOTB) THEN 
          IF (NOTA) THEN 
!                                                                       
!           Form  C := alpha*A*B + beta*C.                              
!                                                                       
              DO 90 J = 1,N 
                  IF (BETA.EQ.ZERO) THEN 
                      DO 50 I = 1,M 
                          C(I,J) = ZERO 
   50                 CONTINUE 
                  ELSE IF (BETA.NE.ONE) THEN 
                      DO 60 I = 1,M 
                          C(I,J) = BETA*C(I,J) 
   60                 CONTINUE 
                  END IF 
                  DO 80 L = 1,K 
                      TEMP = ALPHA*B(L,J) 
                      DO 70 I = 1,M 
                          C(I,J) = C(I,J) + TEMP*A(I,L) 
   70                 CONTINUE 
   80             CONTINUE 
   90         CONTINUE 
          ELSE 
!                                                                       
!           Form  C := alpha*A**T*B + beta*C                            
!                                                                       
              DO 120 J = 1,N 
                  DO 110 I = 1,M 
                      TEMP = ZERO 
                      DO 100 L = 1,K 
                          TEMP = TEMP + A(L,I)*B(L,J) 
  100                 CONTINUE 
                      IF (BETA.EQ.ZERO) THEN 
                          C(I,J) = ALPHA*TEMP 
                      ELSE 
                          C(I,J) = ALPHA*TEMP + BETA*C(I,J) 
                      END IF 
  110             CONTINUE 
  120         CONTINUE 
          END IF 
      ELSE 
          IF (NOTA) THEN 
!                                                                       
!           Form  C := alpha*A*B**T + beta*C                            
!                                                                       
              DO 170 J = 1,N 
                  IF (BETA.EQ.ZERO) THEN 
                      DO 130 I = 1,M 
                          C(I,J) = ZERO 
  130                 CONTINUE 
                  ELSE IF (BETA.NE.ONE) THEN 
                      DO 140 I = 1,M 
                          C(I,J) = BETA*C(I,J) 
  140                 CONTINUE 
                  END IF 
                  DO 160 L = 1,K 
                      TEMP = ALPHA*B(J,L) 
                      DO 150 I = 1,M 
                          C(I,J) = C(I,J) + TEMP*A(I,L) 
  150                 CONTINUE 
  160             CONTINUE 
  170         CONTINUE 
          ELSE 
!                                                                       
!           Form  C := alpha*A**T*B**T + beta*C                         
!                                                                       
              DO 200 J = 1,N 
                  DO 190 I = 1,M 
                      TEMP = ZERO 
                      DO 180 L = 1,K 
                          TEMP = TEMP + A(L,I)*B(J,L) 
  180                 CONTINUE 
                      IF (BETA.EQ.ZERO) THEN 
                          C(I,J) = ALPHA*TEMP 
                      ELSE 
                          C(I,J) = ALPHA*TEMP + BETA*C(I,J) 
                      END IF 
  190             CONTINUE 
  200         CONTINUE 
          END IF 
      END IF 
!                                                                       
      RETURN 
!                                                                       
!     End of SGEMM .                                                    
!                                                                       
      END                                           
!> \brief \b SGEMV                                                      
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SGEMV(TRANS,M,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY)      
!                                                                       
!       .. Scalar Arguments ..                                          
!       REAL ALPHA,BETA                                                 
!       INTEGER INCX,INCY,LDA,M,N                                       
!       CHARACTER TRANS                                                 
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL A(LDA,*),X(*),Y(*)                                         
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SGEMV  performs one of the matrix-vector operations                  
!>                                                                      
!>    y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,       
!>                                                                      
!> where alpha and beta are scalars, x and y are vectors and A is an    
!> m by n matrix.                                                       
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] TRANS                                                     
!> \verbatim                                                            
!>          TRANS is CHARACTER*1                                        
!>           On entry, TRANS specifies the operation to be performed as 
!>           follows:                                                   
!>                                                                      
!>              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.           
!>                                                                      
!>              TRANS = 'T' or 't'   y := alpha*A**T*x + beta*y.        
!>                                                                      
!>              TRANS = 'C' or 'c'   y := alpha*A**T*x + beta*y.        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>           On entry, M specifies the number of rows of the matrix A.  
!>           M must be at least zero.                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>           On entry, N specifies the number of columns of the matrix A
!>           N must be at least zero.                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ALPHA                                                     
!> \verbatim                                                            
!>          ALPHA is REAL                                               
!>           On entry, ALPHA specifies the scalar alpha.                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is REAL array, dimension ( LDA, N )                       
!>           Before entry, the leading m by n part of the array A must  
!>           contain the matrix of coefficients.                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>           On entry, LDA specifies the first dimension of A as declare
!>           in the calling (sub) program. LDA must be at least         
!>           max( 1, m ).                                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] X                                                         
!> \verbatim                                                            
!>          X is REAL array, dimension at least                         
!>           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'      
!>           and at least                                               
!>           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.                   
!>           Before entry, the incremented array X must contain the     
!>           vector x.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCX                                                      
!> \verbatim                                                            
!>          INCX is INTEGER                                             
!>           On entry, INCX specifies the increment for the elements of 
!>           X. INCX must not be zero.                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] BETA                                                      
!> \verbatim                                                            
!>          BETA is REAL                                                
!>           On entry, BETA specifies the scalar beta. When BETA is     
!>           supplied as zero then Y need not be set on input.          
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] Y                                                     
!> \verbatim                                                            
!>          Y is REAL array, dimension at least                         
!>           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'      
!>           and at least                                               
!>           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.                   
!>           Before entry with BETA non-zero, the incremented array Y   
!>           must contain the vector y. On exit, Y is overwritten by the
!>           updated vector y.                                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCY                                                      
!> \verbatim                                                            
!>          INCY is INTEGER                                             
!>           On entry, INCY specifies the increment for the elements of 
!>           Y. INCY must not be zero.                                  
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup single_blas_level2                                          
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  Level 2 Blas routine.                                               
!>  The vector and matrix arguments are not referenced when N = 0, or M 
!>                                                                      
!>  -- Written on 22-October-1986.                                      
!>     Jack Dongarra, Argonne National Lab.                             
!>     Jeremy Du Croz, Nag Central Office.                              
!>     Sven Hammarling, Nag Central Office.                             
!>     Richard Hanson, Sandia National Labs.                            
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE SGEMV(TRANS,M,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) 
!                                                                       
!  -- Reference BLAS level2 routine (version 3.7.0) --                  
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      REAL ALPHA,BETA 
      INTEGER INCX,INCY,LDA,M,N 
      CHARACTER TRANS 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL A(LDA,*),X(*),Y(*) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL ONE,ZERO 
      PARAMETER (ONE=1.0E+0,ZERO=0.0E+0) 
!     ..                                                                
!     .. Local Scalars ..                                               
      REAL TEMP 
      INTEGER I,INFO,IX,IY,J,JX,JY,KX,KY,LENX,LENY 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL LSAME 
      EXTERNAL LSAME 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL XERBLA 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC MAX 
!     ..                                                                
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0 
      IF (.NOT.LSAME(TRANS,'N') .AND. .NOT.LSAME(TRANS,'T') .AND.       &
     &    .NOT.LSAME(TRANS,'C')) THEN                                   
          INFO = 1 
      ELSE IF (M.LT.0) THEN 
          INFO = 2 
      ELSE IF (N.LT.0) THEN 
          INFO = 3 
      ELSE IF (LDA.LT.MAX(1,M)) THEN 
          INFO = 6 
      ELSE IF (INCX.EQ.0) THEN 
          INFO = 8 
      ELSE IF (INCY.EQ.0) THEN 
          INFO = 11 
      END IF 
      IF (INFO.NE.0) THEN 
          CALL XERBLA('SGEMV ',INFO) 
          RETURN 
      END IF 
!                                                                       
!     Quick return if possible.                                         
!                                                                       
      IF ((M.EQ.0) .OR. (N.EQ.0) .OR.                                   &
     &    ((ALPHA.EQ.ZERO).AND. (BETA.EQ.ONE))) RETURN                  
!                                                                       
!     Set  LENX  and  LENY, the lengths of the vectors x and y, and set 
!     up the start points in  X  and  Y.                                
!                                                                       
      IF (LSAME(TRANS,'N')) THEN 
          LENX = N 
          LENY = M 
      ELSE 
          LENX = M 
          LENY = N 
      END IF 
      IF (INCX.GT.0) THEN 
          KX = 1 
      ELSE 
          KX = 1 - (LENX-1)*INCX 
      END IF 
      IF (INCY.GT.0) THEN 
          KY = 1 
      ELSE 
          KY = 1 - (LENY-1)*INCY 
      END IF 
!                                                                       
!     Start the operations. In this version the elements of A are       
!     accessed sequentially with one pass through A.                    
!                                                                       
!     First form  y := beta*y.                                          
!                                                                       
      IF (BETA.NE.ONE) THEN 
          IF (INCY.EQ.1) THEN 
              IF (BETA.EQ.ZERO) THEN 
                  DO 10 I = 1,LENY 
                      Y(I) = ZERO 
   10             CONTINUE 
              ELSE 
                  DO 20 I = 1,LENY 
                      Y(I) = BETA*Y(I) 
   20             CONTINUE 
              END IF 
          ELSE 
              IY = KY 
              IF (BETA.EQ.ZERO) THEN 
                  DO 30 I = 1,LENY 
                      Y(IY) = ZERO 
                      IY = IY + INCY 
   30             CONTINUE 
              ELSE 
                  DO 40 I = 1,LENY 
                      Y(IY) = BETA*Y(IY) 
                      IY = IY + INCY 
   40             CONTINUE 
              END IF 
          END IF 
      END IF 
      IF (ALPHA.EQ.ZERO) RETURN 
      IF (LSAME(TRANS,'N')) THEN 
!                                                                       
!        Form  y := alpha*A*x + y.                                      
!                                                                       
          JX = KX 
          IF (INCY.EQ.1) THEN 
              DO 60 J = 1,N 
                  TEMP = ALPHA*X(JX) 
                  DO 50 I = 1,M 
                      Y(I) = Y(I) + TEMP*A(I,J) 
   50             CONTINUE 
                  JX = JX + INCX 
   60         CONTINUE 
          ELSE 
              DO 80 J = 1,N 
                  TEMP = ALPHA*X(JX) 
                  IY = KY 
                  DO 70 I = 1,M 
                      Y(IY) = Y(IY) + TEMP*A(I,J) 
                      IY = IY + INCY 
   70             CONTINUE 
                  JX = JX + INCX 
   80         CONTINUE 
          END IF 
      ELSE 
!                                                                       
!        Form  y := alpha*A**T*x + y.                                   
!                                                                       
          JY = KY 
          IF (INCX.EQ.1) THEN 
              DO 100 J = 1,N 
                  TEMP = ZERO 
                  DO 90 I = 1,M 
                      TEMP = TEMP + A(I,J)*X(I) 
   90             CONTINUE 
                  Y(JY) = Y(JY) + ALPHA*TEMP 
                  JY = JY + INCY 
  100         CONTINUE 
          ELSE 
              DO 120 J = 1,N 
                  TEMP = ZERO 
                  IX = KX 
                  DO 110 I = 1,M 
                      TEMP = TEMP + A(I,J)*X(IX) 
                      IX = IX + INCX 
  110             CONTINUE 
                  Y(JY) = Y(JY) + ALPHA*TEMP 
                  JY = JY + INCY 
  120         CONTINUE 
          END IF 
      END IF 
!                                                                       
      RETURN 
!                                                                       
!     End of SGEMV .                                                    
!                                                                       
      END                                           
!> \brief \b SGER                                                       
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SGER(M,N,ALPHA,X,INCX,Y,INCY,A,LDA)                  
!                                                                       
!       .. Scalar Arguments ..                                          
!       REAL ALPHA                                                      
!       INTEGER INCX,INCY,LDA,M,N                                       
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL A(LDA,*),X(*),Y(*)                                         
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SGER   performs the rank 1 operation                                 
!>                                                                      
!>    A := alpha*x*y**T + A,                                            
!>                                                                      
!> where alpha is a scalar, x is an m element vector, y is an n element 
!> vector and A is an m by n matrix.                                    
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>           On entry, M specifies the number of rows of the matrix A.  
!>           M must be at least zero.                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>           On entry, N specifies the number of columns of the matrix A
!>           N must be at least zero.                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ALPHA                                                     
!> \verbatim                                                            
!>          ALPHA is REAL                                               
!>           On entry, ALPHA specifies the scalar alpha.                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] X                                                         
!> \verbatim                                                            
!>          X is REAL array, dimension at least                         
!>           ( 1 + ( m - 1 )*abs( INCX ) ).                             
!>           Before entry, the incremented array X must contain the m   
!>           element vector x.                                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCX                                                      
!> \verbatim                                                            
!>          INCX is INTEGER                                             
!>           On entry, INCX specifies the increment for the elements of 
!>           X. INCX must not be zero.                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] Y                                                         
!> \verbatim                                                            
!>          Y is REAL array, dimension at least                         
!>           ( 1 + ( n - 1 )*abs( INCY ) ).                             
!>           Before entry, the incremented array Y must contain the n   
!>           element vector y.                                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCY                                                      
!> \verbatim                                                            
!>          INCY is INTEGER                                             
!>           On entry, INCY specifies the increment for the elements of 
!>           Y. INCY must not be zero.                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] A                                                     
!> \verbatim                                                            
!>          A is REAL array, dimension ( LDA, N )                       
!>           Before entry, the leading m by n part of the array A must  
!>           contain the matrix of coefficients. On exit, A is          
!>           overwritten by the updated matrix.                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>           On entry, LDA specifies the first dimension of A as declare
!>           in the calling (sub) program. LDA must be at least         
!>           max( 1, m ).                                               
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup single_blas_level2                                          
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  Level 2 Blas routine.                                               
!>                                                                      
!>  -- Written on 22-October-1986.                                      
!>     Jack Dongarra, Argonne National Lab.                             
!>     Jeremy Du Croz, Nag Central Office.                              
!>     Sven Hammarling, Nag Central Office.                             
!>     Richard Hanson, Sandia National Labs.                            
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE SGER(M,N,ALPHA,X,INCX,Y,INCY,A,LDA) 
!                                                                       
!  -- Reference BLAS level2 routine (version 3.7.0) --                  
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      REAL ALPHA 
      INTEGER INCX,INCY,LDA,M,N 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL A(LDA,*),X(*),Y(*) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL ZERO 
      PARAMETER (ZERO=0.0E+0) 
!     ..                                                                
!     .. Local Scalars ..                                               
      REAL TEMP 
      INTEGER I,INFO,IX,J,JY,KX 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL XERBLA 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC MAX 
!     ..                                                                
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0 
      IF (M.LT.0) THEN 
          INFO = 1 
      ELSE IF (N.LT.0) THEN 
          INFO = 2 
      ELSE IF (INCX.EQ.0) THEN 
          INFO = 5 
      ELSE IF (INCY.EQ.0) THEN 
          INFO = 7 
      ELSE IF (LDA.LT.MAX(1,M)) THEN 
          INFO = 9 
      END IF 
      IF (INFO.NE.0) THEN 
          CALL XERBLA('SGER  ',INFO) 
          RETURN 
      END IF 
!                                                                       
!     Quick return if possible.                                         
!                                                                       
      IF ((M.EQ.0) .OR. (N.EQ.0) .OR. (ALPHA.EQ.ZERO)) RETURN 
!                                                                       
!     Start the operations. In this version the elements of A are       
!     accessed sequentially with one pass through A.                    
!                                                                       
      IF (INCY.GT.0) THEN 
          JY = 1 
      ELSE 
          JY = 1 - (N-1)*INCY 
      END IF 
      IF (INCX.EQ.1) THEN 
          DO 20 J = 1,N 
              IF (Y(JY).NE.ZERO) THEN 
                  TEMP = ALPHA*Y(JY) 
                  DO 10 I = 1,M 
                      A(I,J) = A(I,J) + X(I)*TEMP 
   10             CONTINUE 
              END IF 
              JY = JY + INCY 
   20     CONTINUE 
      ELSE 
          IF (INCX.GT.0) THEN 
              KX = 1 
          ELSE 
              KX = 1 - (M-1)*INCX 
          END IF 
          DO 40 J = 1,N 
              IF (Y(JY).NE.ZERO) THEN 
                  TEMP = ALPHA*Y(JY) 
                  IX = KX 
                  DO 30 I = 1,M 
                      A(I,J) = A(I,J) + X(IX)*TEMP 
                      IX = IX + INCX 
   30             CONTINUE 
              END IF 
              JY = JY + INCY 
   40     CONTINUE 
      END IF 
!                                                                       
      RETURN 
!                                                                       
!     End of SGER  .                                                    
!                                                                       
      END                                           
!> \brief \b SISNAN tests input for NaN.                                
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SISNAN + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       LOGICAL FUNCTION SISNAN( SIN )                                  
!                                                                       
!       .. Scalar Arguments ..                                          
!       REAL, INTENT(IN) :: SIN                                         
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SISNAN returns .TRUE. if its argument is NaN, and .FALSE.            
!> otherwise.  To be replaced by the Fortran 2003 intrinsic in the      
!> future.                                                              
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] SIN                                                       
!> \verbatim                                                            
!>          SIN is REAL                                                 
!>          Input to test for NaN.                                      
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2017                                                      
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!  =====================================================================
      LOGICAL FUNCTION SISNAN( SIN ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.1) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2017                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      REAL, INTENT(IN) :: SIN 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!  .. External Functions ..                                             
      LOGICAL SLAISNAN 
      EXTERNAL SLAISNAN 
!  ..                                                                   
!  .. Executable Statements ..                                          
      SISNAN = SLAISNAN(SIN,SIN) 
      RETURN 
      END                                           
!> \brief \b SLAE2 computes the eigenvalues of a 2-by-2 symmetric matrix
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLAE2 + dependencies                                        
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SLAE2( A, B, C, RT1, RT2 )                           
!                                                                       
!       .. Scalar Arguments ..                                          
!       REAL               A, B, C, RT1, RT2                            
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SLAE2  computes the eigenvalues of a 2-by-2 symmetric matrix         
!>    [  A   B  ]                                                       
!>    [  B   C  ].                                                      
!> On return, RT1 is the eigenvalue of larger absolute value, and RT2   
!> is the eigenvalue of smaller absolute value.                         
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is REAL                                                   
!>          The (1,1) element of the 2-by-2 matrix.                     
!> \endverbatim                                                         
!>                                                                      
!> \param[in] B                                                         
!> \verbatim                                                            
!>          B is REAL                                                   
!>          The (1,2) and (2,1) elements of the 2-by-2 matrix.          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] C                                                         
!> \verbatim                                                            
!>          C is REAL                                                   
!>          The (2,2) element of the 2-by-2 matrix.                     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] RT1                                                      
!> \verbatim                                                            
!>          RT1 is REAL                                                 
!>          The eigenvalue of larger absolute value.                    
!> \endverbatim                                                         
!>                                                                      
!> \param[out] RT2                                                      
!> \verbatim                                                            
!>          RT2 is REAL                                                 
!>          The eigenvalue of smaller absolute value.                   
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  RT1 is accurate to a few ulps barring over/underflow.               
!>                                                                      
!>  RT2 may be inaccurate if there is massive cancellation in the       
!>  determinant A*C-B*B; higher precision or correctly rounded or       
!>  correctly truncated arithmetic would be needed to compute RT2       
!>  accurately in all cases.                                            
!>                                                                      
!>  Overflow is possible only if RT1 is within a factor of 5 of overflow
!>  Underflow is harmless if the input data is 0 or exceeds             
!>     underflow_threshold / macheps.                                   
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE SLAE2( A, B, C, RT1, RT2 ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      REAL               A, B, C, RT1, RT2 
!     ..                                                                
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Parameters ..                                                  
      REAL               ONE 
      PARAMETER          ( ONE = 1.0E0 ) 
      REAL               TWO 
      PARAMETER          ( TWO = 2.0E0 ) 
      REAL               ZERO 
      PARAMETER          ( ZERO = 0.0E0 ) 
      REAL               HALF 
      PARAMETER          ( HALF = 0.5E0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      REAL               AB, ACMN, ACMX, ADF, DF, RT, SM, TB 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, SQRT 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Compute the eigenvalues                                           
!                                                                       
      SM = A + C 
      DF = A - C 
      ADF = ABS( DF ) 
      TB = B + B 
      AB = ABS( TB ) 
      IF( ABS( A ).GT.ABS( C ) ) THEN 
         ACMX = A 
         ACMN = C 
      ELSE 
         ACMX = C 
         ACMN = A 
      END IF 
      IF( ADF.GT.AB ) THEN 
         RT = ADF*SQRT( ONE+( AB / ADF )**2 ) 
      ELSE IF( ADF.LT.AB ) THEN 
         RT = AB*SQRT( ONE+( ADF / AB )**2 ) 
      ELSE 
!                                                                       
!        Includes case AB=ADF=0                                         
!                                                                       
         RT = AB*SQRT( TWO ) 
      END IF 
      IF( SM.LT.ZERO ) THEN 
         RT1 = HALF*( SM-RT ) 
!                                                                       
!        Order of execution important.                                  
!        To get fully accurate smaller eigenvalue,                      
!        next line needs to be executed in higher precision.            
!                                                                       
         RT2 = ( ACMX / RT1 )*ACMN - ( B / RT1 )*B 
      ELSE IF( SM.GT.ZERO ) THEN 
         RT1 = HALF*( SM+RT ) 
!                                                                       
!        Order of execution important.                                  
!        To get fully accurate smaller eigenvalue,                      
!        next line needs to be executed in higher precision.            
!                                                                       
         RT2 = ( ACMX / RT1 )*ACMN - ( B / RT1 )*B 
      ELSE 
!                                                                       
!        Includes case RT1 = RT2 = 0                                    
!                                                                       
         RT1 = HALF*RT 
         RT2 = -HALF*RT 
      END IF 
      RETURN 
!                                                                       
!     End of SLAE2                                                      
!                                                                       
!> \brief \b SLAEBZ computes the number of eigenvalues of a real symmetr
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLAEBZ + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SLAEBZ( IJOB, NITMAX, N, MMAX, MINP, NBMIN, ABSTOL,  
!                          RELTOL, PIVMIN, D, E, E2, NVAL, AB, C, MOUT, 
!                          NAB, WORK, IWORK, INFO )                     
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            IJOB, INFO, MINP, MMAX, MOUT, N, NBMIN, NITMA
!       REAL               ABSTOL, PIVMIN, RELTOL                       
!       ..                                                              
!       .. Array Arguments ..                                           
!       INTEGER            IWORK( * ), NAB( MMAX, * ), NVAL( * )        
!       REAL               AB( MMAX, * ), C( * ), D( * ), E( * ), E2( * 
!      $                   WORK( * )                                    
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SLAEBZ contains the iteration loops which compute and use the        
!> function N(w), which is the count of eigenvalues of a symmetric      
!> tridiagonal matrix T less than or equal to its argument  w.  It      
!> performs a choice of two types of loops:                             
!>                                                                      
!> IJOB=1, followed by                                                  
!> IJOB=2: It takes as input a list of intervals and returns a list of  
!>         sufficiently small intervals whose union contains the same   
!>         eigenvalues as the union of the original intervals.          
!>         The input intervals are (AB(j,1),AB(j,2)], j=1,...,MINP.     
!>         The output interval (AB(j,1),AB(j,2)] will contain           
!>         eigenvalues NAB(j,1)+1,...,NAB(j,2), where 1 <= j <= MOUT.   
!>                                                                      
!> IJOB=3: It performs a binary search in each input interval           
!>         (AB(j,1),AB(j,2)] for a point  w(j)  such that               
!>         N(w(j))=NVAL(j), and uses  C(j)  as the starting point of    
!>         the search.  If such a w(j) is found, then on output         
!>         AB(j,1)=AB(j,2)=w.  If no such w(j) is found, then on output 
!>         (AB(j,1),AB(j,2)] will be a small interval containing the    
!>         point where N(w) jumps through NVAL(j), unless that point    
!>         lies outside the initial interval.                           
!>                                                                      
!> Note that the intervals are in all cases half-open intervals,        
!> i.e., of the form  (a,b] , which includes  b  but not  a .           
!>                                                                      
!> To avoid underflow, the matrix should be scaled so that its largest  
!> element is no greater than  overflow**(1/2) * underflow**(1/4)       
!> in absolute value.  To assure the most accurate computation          
!> of small eigenvalues, the matrix should be scaled to be              
!> not much smaller than that, either.                                  
!>                                                                      
!> See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal        
!> Matrix", Report CS41, Computer Science Dept., Stanford               
!> University, July 21, 1966                                            
!>                                                                      
!> Note: the arguments are, in general, *not* checked for unreasonable  
!> values.                                                              
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] IJOB                                                      
!> \verbatim                                                            
!>          IJOB is INTEGER                                             
!>          Specifies what is to be done:                               
!>          = 1:  Compute NAB for the initial intervals.                
!>          = 2:  Perform bisection iteration to find eigenvalues of T. 
!>          = 3:  Perform bisection iteration to invert N(w), i.e.,     
!>                to find a point which has a specified number of       
!>                eigenvalues of T to its left.                         
!>          Other values will cause SLAEBZ to return with INFO=-1.      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] NITMAX                                                    
!> \verbatim                                                            
!>          NITMAX is INTEGER                                           
!>          The maximum number of "levels" of bisection to be           
!>          performed, i.e., an interval of width W will not be made    
!>          smaller than 2^(-NITMAX) * W.  If not all intervals         
!>          have converged after NITMAX iterations, then INFO is set    
!>          to the number of non-converged intervals.                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The dimension n of the tridiagonal matrix T.  It must be at 
!>          least 1.                                                    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] MMAX                                                      
!> \verbatim                                                            
!>          MMAX is INTEGER                                             
!>          The maximum number of intervals.  If more than MMAX interval
!>          are generated, then SLAEBZ will quit with INFO=MMAX+1.      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] MINP                                                      
!> \verbatim                                                            
!>          MINP is INTEGER                                             
!>          The initial number of intervals.  It may not be greater than
!>          MMAX.                                                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] NBMIN                                                     
!> \verbatim                                                            
!>          NBMIN is INTEGER                                            
!>          The smallest number of intervals that should be processed   
!>          using a vector loop.  If zero, then only the scalar loop    
!>          will be used.                                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ABSTOL                                                    
!> \verbatim                                                            
!>          ABSTOL is REAL                                              
!>          The minimum (absolute) width of an interval.  When an       
!>          interval is narrower than ABSTOL, or than RELTOL times the  
!>          larger (in magnitude) endpoint, then it is considered to be 
!>          sufficiently small, i.e., converged.  This must be at least 
!>          zero.                                                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] RELTOL                                                    
!> \verbatim                                                            
!>          RELTOL is REAL                                              
!>          The minimum relative width of an interval.  When an interval
!>          is narrower than ABSTOL, or than RELTOL times the larger (in
!>          magnitude) endpoint, then it is considered to be            
!>          sufficiently small, i.e., converged.  Note: this should     
!>          always be at least radix*machine epsilon.                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] PIVMIN                                                    
!> \verbatim                                                            
!>          PIVMIN is REAL                                              
!>          The minimum absolute value of a "pivot" in the Sturm        
!>          sequence loop.                                              
!>          This must be at least  max |e(j)**2|*safe_min  and at       
!>          least safe_min, where safe_min is at least                  
!>          the smallest number that can divide one without overflow.   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] D                                                         
!> \verbatim                                                            
!>          D is REAL array, dimension (N)                              
!>          The diagonal elements of the tridiagonal matrix T.          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] E                                                         
!> \verbatim                                                            
!>          E is REAL array, dimension (N)                              
!>          The offdiagonal elements of the tridiagonal matrix T in     
!>          positions 1 through N-1.  E(N) is arbitrary.                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] E2                                                        
!> \verbatim                                                            
!>          E2 is REAL array, dimension (N)                             
!>          The squares of the offdiagonal elements of the tridiagonal  
!>          matrix T.  E2(N) is ignored.                                
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] NVAL                                                  
!> \verbatim                                                            
!>          NVAL is INTEGER array, dimension (MINP)                     
!>          If IJOB=1 or 2, not referenced.                             
!>          If IJOB=3, the desired values of N(w).  The elements of NVAL
!>          will be reordered to correspond with the intervals in AB.   
!>          Thus, NVAL(j) on output will not, in general be the same as 
!>          NVAL(j) on input, but it will correspond with the interval  
!>          (AB(j,1),AB(j,2)] on output.                                
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] AB                                                    
!> \verbatim                                                            
!>          AB is REAL array, dimension (MMAX,2)                        
!>          The endpoints of the intervals.  AB(j,1) is  a(j), the left 
!>          endpoint of the j-th interval, and AB(j,2) is b(j), the     
!>          right endpoint of the j-th interval.  The input intervals   
!>          will, in general, be modified, split, and reordered by the  
      END                                           
!>          calculation.                                                
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] C                                                     
!> \verbatim                                                            
!>          C is REAL array, dimension (MMAX)                           
!>          If IJOB=1, ignored.                                         
!>          If IJOB=2, workspace.                                       
!>          If IJOB=3, then on input C(j) should be initialized to the  
!>          first search point in the binary search.                    
!> \endverbatim                                                         
!>                                                                      
!> \param[out] MOUT                                                     
!> \verbatim                                                            
!>          MOUT is INTEGER                                             
!>          If IJOB=1, the number of eigenvalues in the intervals.      
!>          If IJOB=2 or 3, the number of intervals output.             
!>          If IJOB=3, MOUT will equal MINP.                            
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] NAB                                                   
!> \verbatim                                                            
!>          NAB is INTEGER array, dimension (MMAX,2)                    
!>          If IJOB=1, then on output NAB(i,j) will be set to N(AB(i,j))
!>          If IJOB=2, then on input, NAB(i,j) should be set.  It must  
!>             satisfy the condition:                                   
!>             N(AB(i,1)) <= NAB(i,1) <= NAB(i,2) <= N(AB(i,2)),        
!>             which means that in interval i only eigenvalues          
!>             NAB(i,1)+1,...,NAB(i,2) will be considered.  Usually,    
!>             NAB(i,j)=N(AB(i,j)), from a previous call to SLAEBZ with 
!>             IJOB=1.                                                  
!>             On output, NAB(i,j) will contain                         
!>             max(na(k),min(nb(k),N(AB(i,j)))), where k is the index of
!>             the input interval that the output interval              
!>             (AB(j,1),AB(j,2)] came from, and na(k) and nb(k) are the 
!>             the input values of NAB(k,1) and NAB(k,2).               
!>          If IJOB=3, then on output, NAB(i,j) contains N(AB(i,j)),    
!>             unless N(w) > NVAL(i) for all search points  w , in which
!>             case NAB(i,1) will not be modified, i.e., the output     
!>             value will be the same as the input value (modulo        
!>             reorderings -- see NVAL and AB), or unless N(w) < NVAL(i)
!>             for all search points  w , in which case NAB(i,2) will   
!>             not be modified.  Normally, NAB should be set to some    
!>             distinctive value(s) before SLAEBZ is called.            
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is REAL array, dimension (MMAX)                        
!>          Workspace.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[out] IWORK                                                    
!> \verbatim                                                            
!>          IWORK is INTEGER array, dimension (MMAX)                    
!>          Workspace.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0:       All intervals converged.                         
!>          = 1--MMAX: The last INFO intervals did not converge.        
!>          = MMAX+1:  More than MMAX intervals were generated.         
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>      This routine is intended to be called only by other LAPACK      
!>  routines, thus the interface is less user-friendly.  It is intended 
!>  for two purposes:                                                   
!>                                                                      
!>  (a) finding eigenvalues.  In this case, SLAEBZ should have one or   
!>      more initial intervals set up in AB, and SLAEBZ should be called
!>      with IJOB=1.  This sets up NAB, and also counts the eigenvalues.
!>      Intervals with no eigenvalues would usually be thrown out at    
!>      this point.  Also, if not all the eigenvalues in an interval i  
!>      are desired, NAB(i,1) can be increased or NAB(i,2) decreased.   
!>      For example, set NAB(i,1)=NAB(i,2)-1 to get the largest         
!>      eigenvalue.  SLAEBZ is then called with IJOB=2 and MMAX         
!>      no smaller than the value of MOUT returned by the call with     
!>      IJOB=1.  After this (IJOB=2) call, eigenvalues NAB(i,1)+1       
!>      through NAB(i,2) are approximately AB(i,1) (or AB(i,2)) to the  
!>      tolerance specified by ABSTOL and RELTOL.                       
!>                                                                      
!>  (b) finding an interval (a',b'] containing eigenvalues w(f),...,w(l)
!>      In this case, start with a Gershgorin interval  (a,b).  Set up  
!>      AB to contain 2 search intervals, both initially (a,b).  One    
!>      NVAL element should contain  f-1  and the other should contain  
!>      , while C should contain a and b, resp.  NAB(i,1) should be -1  
!>      and NAB(i,2) should be N+1, to flag an error if the desired     
!>      interval does not lie in (a,b).  SLAEBZ is then called with     
!>      IJOB=3.  On exit, if w(f-1) < w(f), then one of the intervals --
!>      j -- will have AB(j,1)=AB(j,2) and NAB(j,1)=NAB(j,2)=f-1, while 
!>      if, to the specified tolerance, w(f-k)=...=w(f+r), k > 0 and r  
!>      >= 0, then the interval will have  N(AB(j,1))=NAB(j,1)=f-k and  
!>      N(AB(j,2))=NAB(j,2)=f+r.  The cases w(l) < w(l+1) and           
!>      w(l-r)=...=w(l+k) are handled similarly.                        
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE SLAEBZ( IJOB, NITMAX, N, MMAX, MINP, NBMIN, ABSTOL,    &
     &                   RELTOL, PIVMIN, D, E, E2, NVAL, AB, C, MOUT,   &
     &                   NAB, WORK, IWORK, INFO )                       
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            IJOB, INFO, MINP, MMAX, MOUT, N, NBMIN, NITMAX 
      REAL               ABSTOL, PIVMIN, RELTOL 
!     ..                                                                
!     .. Array Arguments ..                                             
      INTEGER            IWORK( * ), NAB( MMAX, * ), NVAL( * ) 
      REAL               AB( MMAX, * ), C( * ), D( * ), E( * ), E2( * ),&
     &                   WORK( * )                                      
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ZERO, TWO, HALF 
      PARAMETER          ( ZERO = 0.0E0, TWO = 2.0E0,                   &
     &                   HALF = 1.0E0 / TWO )                           
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            ITMP1, ITMP2, J, JI, JIT, JP, KF, KFNEW, KL,   &
     &                   KLNEW                                          
      REAL               TMP1, TMP2 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, MAX, MIN 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Check for Errors                                                  
!                                                                       
      INFO = 0 
      IF( IJOB.LT.1 .OR. IJOB.GT.3 ) THEN 
         INFO = -1 
         RETURN 
      END IF 
!                                                                       
!     Initialize NAB                                                    
!                                                                       
      IF( IJOB.EQ.1 ) THEN 
!                                                                       
!        Compute the number of eigenvalues in the initial intervals.    
!                                                                       
         MOUT = 0 
         DO 30 JI = 1, MINP 
            DO 20 JP = 1, 2 
               TMP1 = D( 1 ) - AB( JI, JP ) 
               IF( ABS( TMP1 ).LT.PIVMIN )                              &
     &            TMP1 = -PIVMIN                                        
               NAB( JI, JP ) = 0 
               IF( TMP1.LE.ZERO )                                       &
     &            NAB( JI, JP ) = 1                                     
!                                                                       
               DO 10 J = 2, N 
                  TMP1 = D( J ) - E2( J-1 ) / TMP1 - AB( JI, JP ) 
                  IF( ABS( TMP1 ).LT.PIVMIN )                           &
     &               TMP1 = -PIVMIN                                     
                  IF( TMP1.LE.ZERO )                                    &
     &               NAB( JI, JP ) = NAB( JI, JP ) + 1                  
   10          CONTINUE 
   20       CONTINUE 
            MOUT = MOUT + NAB( JI, 2 ) - NAB( JI, 1 ) 
   30    CONTINUE 
         RETURN 
      END IF 
!                                                                       
!     Initialize for loop                                               
!                                                                       
!     KF and KL have the following meaning:                             
!        Intervals 1,...,KF-1 have converged.                           
!        Intervals KF,...,KL  still need to be refined.                 
!                                                                       
      KF = 1 
      KL = MINP 
!                                                                       
!     If IJOB=2, initialize C.                                          
!     If IJOB=3, use the user-supplied starting point.                  
!                                                                       
      IF( IJOB.EQ.2 ) THEN 
         DO 40 JI = 1, MINP 
            C( JI ) = HALF*( AB( JI, 1 )+AB( JI, 2 ) ) 
   40    CONTINUE 
      END IF 
!                                                                       
!     Iteration loop                                                    
!                                                                       
      DO 130 JIT = 1, NITMAX 
!                                                                       
!        Loop over intervals                                            
!                                                                       
         IF( KL-KF+1.GE.NBMIN .AND. NBMIN.GT.0 ) THEN 
!                                                                       
!           Begin of Parallel Version of the loop                       
!                                                                       
            DO 60 JI = KF, KL 
!                                                                       
!              Compute N(c), the number of eigenvalues less than c      
!                                                                       
               WORK( JI ) = D( 1 ) - C( JI ) 
               IWORK( JI ) = 0 
               IF( WORK( JI ).LE.PIVMIN ) THEN 
                  IWORK( JI ) = 1 
                  WORK( JI ) = MIN( WORK( JI ), -PIVMIN ) 
               END IF 
!                                                                       
               DO 50 J = 2, N 
                  WORK( JI ) = D( J ) - E2( J-1 ) / WORK( JI ) - C( JI ) 
                  IF( WORK( JI ).LE.PIVMIN ) THEN 
                     IWORK( JI ) = IWORK( JI ) + 1 
                     WORK( JI ) = MIN( WORK( JI ), -PIVMIN ) 
                  END IF 
   50          CONTINUE 
   60       CONTINUE 
!                                                                       
            IF( IJOB.LE.2 ) THEN 
!                                                                       
!              IJOB=2: Choose all intervals containing eigenvalues.     
!                                                                       
               KLNEW = KL 
               DO 70 JI = KF, KL 
!                                                                       
!                 Insure that N(w) is monotone                          
!                                                                       
                  IWORK( JI ) = MIN( NAB( JI, 2 ),                      &
     &                          MAX( NAB( JI, 1 ), IWORK( JI ) ) )      
!                                                                       
!                 Update the Queue -- add intervals if both halves      
!                 contain eigenvalues.                                  
!                                                                       
                  IF( IWORK( JI ).EQ.NAB( JI, 2 ) ) THEN 
!                                                                       
!                    No eigenvalue in the upper interval:               
!                    just use the lower interval.                       
!                                                                       
                     AB( JI, 2 ) = C( JI ) 
!                                                                       
                  ELSE IF( IWORK( JI ).EQ.NAB( JI, 1 ) ) THEN 
!                                                                       
!                    No eigenvalue in the lower interval:               
!                    just use the upper interval.                       
!                                                                       
                     AB( JI, 1 ) = C( JI ) 
                  ELSE 
                     KLNEW = KLNEW + 1 
                     IF( KLNEW.LE.MMAX ) THEN 
!                                                                       
!                       Eigenvalue in both intervals -- add upper to    
!                       queue.                                          
!                                                                       
                        AB( KLNEW, 2 ) = AB( JI, 2 ) 
                        NAB( KLNEW, 2 ) = NAB( JI, 2 ) 
                        AB( KLNEW, 1 ) = C( JI ) 
                        NAB( KLNEW, 1 ) = IWORK( JI ) 
                        AB( JI, 2 ) = C( JI ) 
                        NAB( JI, 2 ) = IWORK( JI ) 
                     ELSE 
                        INFO = MMAX + 1 
                     END IF 
                  END IF 
   70          CONTINUE 
               IF( INFO.NE.0 )                                          &
     &            RETURN                                                
               KL = KLNEW 
            ELSE 
!                                                                       
!              IJOB=3: Binary search.  Keep only the interval containing
!                      w   s.t. N(w) = NVAL                             
!                                                                       
               DO 80 JI = KF, KL 
                  IF( IWORK( JI ).LE.NVAL( JI ) ) THEN 
                     AB( JI, 1 ) = C( JI ) 
                     NAB( JI, 1 ) = IWORK( JI ) 
                  END IF 
                  IF( IWORK( JI ).GE.NVAL( JI ) ) THEN 
                     AB( JI, 2 ) = C( JI ) 
                     NAB( JI, 2 ) = IWORK( JI ) 
                  END IF 
   80          CONTINUE 
            END IF 
!                                                                       
         ELSE 
!                                                                       
!           End of Parallel Version of the loop                         
!                                                                       
!           Begin of Serial Version of the loop                         
!                                                                       
            KLNEW = KL 
            DO 100 JI = KF, KL 
!                                                                       
!              Compute N(w), the number of eigenvalues less than w      
!                                                                       
               TMP1 = C( JI ) 
               TMP2 = D( 1 ) - TMP1 
               ITMP1 = 0 
               IF( TMP2.LE.PIVMIN ) THEN 
                  ITMP1 = 1 
                  TMP2 = MIN( TMP2, -PIVMIN ) 
               END IF 
!                                                                       
               DO 90 J = 2, N 
                  TMP2 = D( J ) - E2( J-1 ) / TMP2 - TMP1 
                  IF( TMP2.LE.PIVMIN ) THEN 
                     ITMP1 = ITMP1 + 1 
                     TMP2 = MIN( TMP2, -PIVMIN ) 
                  END IF 
   90          CONTINUE 
!                                                                       
               IF( IJOB.LE.2 ) THEN 
!                                                                       
!                 IJOB=2: Choose all intervals containing eigenvalues.  
!                                                                       
!                 Insure that N(w) is monotone                          
!                                                                       
                  ITMP1 = MIN( NAB( JI, 2 ),                            &
     &                    MAX( NAB( JI, 1 ), ITMP1 ) )                  
!                                                                       
!                 Update the Queue -- add intervals if both halves      
!                 contain eigenvalues.                                  
!                                                                       
                  IF( ITMP1.EQ.NAB( JI, 2 ) ) THEN 
!                                                                       
!                    No eigenvalue in the upper interval:               
!                    just use the lower interval.                       
!                                                                       
                     AB( JI, 2 ) = TMP1 
!                                                                       
                  ELSE IF( ITMP1.EQ.NAB( JI, 1 ) ) THEN 
!                                                                       
!                    No eigenvalue in the lower interval:               
!                    just use the upper interval.                       
!                                                                       
                     AB( JI, 1 ) = TMP1 
                  ELSE IF( KLNEW.LT.MMAX ) THEN 
!                                                                       
!                    Eigenvalue in both intervals -- add upper to queue.
!                                                                       
                     KLNEW = KLNEW + 1 
                     AB( KLNEW, 2 ) = AB( JI, 2 ) 
                     NAB( KLNEW, 2 ) = NAB( JI, 2 ) 
                     AB( KLNEW, 1 ) = TMP1 
                     NAB( KLNEW, 1 ) = ITMP1 
                     AB( JI, 2 ) = TMP1 
                     NAB( JI, 2 ) = ITMP1 
                  ELSE 
                     INFO = MMAX + 1 
                     RETURN 
                  END IF 
               ELSE 
!                                                                       
!                 IJOB=3: Binary search.  Keep only the interval        
!                         containing  w  s.t. N(w) = NVAL               
!                                                                       
                  IF( ITMP1.LE.NVAL( JI ) ) THEN 
                     AB( JI, 1 ) = TMP1 
                     NAB( JI, 1 ) = ITMP1 
                  END IF 
                  IF( ITMP1.GE.NVAL( JI ) ) THEN 
                     AB( JI, 2 ) = TMP1 
                     NAB( JI, 2 ) = ITMP1 
                  END IF 
               END IF 
  100       CONTINUE 
            KL = KLNEW 
!                                                                       
         END IF 
!                                                                       
!        Check for convergence                                          
!                                                                       
         KFNEW = KF 
         DO 110 JI = KF, KL 
            TMP1 = ABS( AB( JI, 2 )-AB( JI, 1 ) ) 
            TMP2 = MAX( ABS( AB( JI, 2 ) ), ABS( AB( JI, 1 ) ) ) 
            IF( TMP1.LT.MAX( ABSTOL, PIVMIN, RELTOL*TMP2 ) .OR.         &
     &          NAB( JI, 1 ).GE.NAB( JI, 2 ) ) THEN                     
!                                                                       
!              Converged -- Swap with position KFNEW,                   
!                           then increment KFNEW                        
!                                                                       
               IF( JI.GT.KFNEW ) THEN 
                  TMP1 = AB( JI, 1 ) 
                  TMP2 = AB( JI, 2 ) 
                  ITMP1 = NAB( JI, 1 ) 
                  ITMP2 = NAB( JI, 2 ) 
                  AB( JI, 1 ) = AB( KFNEW, 1 ) 
                  AB( JI, 2 ) = AB( KFNEW, 2 ) 
                  NAB( JI, 1 ) = NAB( KFNEW, 1 ) 
                  NAB( JI, 2 ) = NAB( KFNEW, 2 ) 
                  AB( KFNEW, 1 ) = TMP1 
                  AB( KFNEW, 2 ) = TMP2 
                  NAB( KFNEW, 1 ) = ITMP1 
                  NAB( KFNEW, 2 ) = ITMP2 
                  IF( IJOB.EQ.3 ) THEN 
                     ITMP1 = NVAL( JI ) 
                     NVAL( JI ) = NVAL( KFNEW ) 
                     NVAL( KFNEW ) = ITMP1 
                  END IF 
               END IF 
               KFNEW = KFNEW + 1 
            END IF 
  110    CONTINUE 
         KF = KFNEW 
!                                                                       
!        Choose Midpoints                                               
!                                                                       
         DO 120 JI = KF, KL 
            C( JI ) = HALF*( AB( JI, 1 )+AB( JI, 2 ) ) 
  120    CONTINUE 
!                                                                       
!        If no more intervals to refine, quit.                          
!                                                                       
         IF( KF.GT.KL )                                                 &
     &      GO TO 140                                                   
  130 END DO 
!                                                                       
!     Converged                                                         
!                                                                       
  140 CONTINUE 
      INFO = MAX( KL+1-KF, 0 ) 
      MOUT = KL 
!                                                                       
      RETURN 
!                                                                       
!     End of SLAEBZ                                                     
!                                                                       
      END                                           
!> \brief \b SLAEV2 computes the eigenvalues and eigenvectors of a 2-by-
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLAEV2 + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SLAEV2( A, B, C, RT1, RT2, CS1, SN1 )                
!                                                                       
!       .. Scalar Arguments ..                                          
!       REAL               A, B, C, CS1, RT1, RT2, SN1                  
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SLAEV2 computes the eigendecomposition of a 2-by-2 symmetric matrix  
!>    [  A   B  ]                                                       
!>    [  B   C  ].                                                      
!> On return, RT1 is the eigenvalue of larger absolute value, RT2 is the
!> eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right
!> eigenvector for RT1, giving the decomposition                        
!>                                                                      
!>    [ CS1  SN1 ] [  A   B  ] [ CS1 -SN1 ]  =  [ RT1  0  ]             
!>    [-SN1  CS1 ] [  B   C  ] [ SN1  CS1 ]     [  0  RT2 ].            
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is REAL                                                   
!>          The (1,1) element of the 2-by-2 matrix.                     
!> \endverbatim                                                         
!>                                                                      
!> \param[in] B                                                         
!> \verbatim                                                            
!>          B is REAL                                                   
!>          The (1,2) element and the conjugate of the (2,1) element of 
!>          the 2-by-2 matrix.                                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] C                                                         
!> \verbatim                                                            
!>          C is REAL                                                   
!>          The (2,2) element of the 2-by-2 matrix.                     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] RT1                                                      
!> \verbatim                                                            
!>          RT1 is REAL                                                 
!>          The eigenvalue of larger absolute value.                    
!> \endverbatim                                                         
!>                                                                      
!> \param[out] RT2                                                      
!> \verbatim                                                            
!>          RT2 is REAL                                                 
!>          The eigenvalue of smaller absolute value.                   
!> \endverbatim                                                         
!>                                                                      
!> \param[out] CS1                                                      
!> \verbatim                                                            
!>          CS1 is REAL                                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[out] SN1                                                      
!> \verbatim                                                            
!>          SN1 is REAL                                                 
!>          The vector (CS1, SN1) is a unit right eigenvector for RT1.  
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  RT1 is accurate to a few ulps barring over/underflow.               
!>                                                                      
!>  RT2 may be inaccurate if there is massive cancellation in the       
!>  determinant A*C-B*B; higher precision or correctly rounded or       
!>  correctly truncated arithmetic would be needed to compute RT2       
!>  accurately in all cases.                                            
!>                                                                      
!>  CS1 and SN1 are accurate to a few ulps barring over/underflow.      
!>                                                                      
!>  Overflow is possible only if RT1 is within a factor of 5 of overflow
!>  Underflow is harmless if the input data is 0 or exceeds             
!>     underflow_threshold / macheps.                                   
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE SLAEV2( A, B, C, RT1, RT2, CS1, SN1 ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      REAL               A, B, C, CS1, RT1, RT2, SN1 
!     ..                                                                
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Parameters ..                                                  
      REAL               ONE 
      PARAMETER          ( ONE = 1.0E0 ) 
      REAL               TWO 
      PARAMETER          ( TWO = 2.0E0 ) 
      REAL               ZERO 
      PARAMETER          ( ZERO = 0.0E0 ) 
      REAL               HALF 
      PARAMETER          ( HALF = 0.5E0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            SGN1, SGN2 
      REAL               AB, ACMN, ACMX, ACS, ADF, CS, CT, DF, RT, SM,  &
     &                   TB, TN                                         
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, SQRT 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Compute the eigenvalues                                           
!                                                                       
      SM = A + C 
      DF = A - C 
      ADF = ABS( DF ) 
      TB = B + B 
      AB = ABS( TB ) 
      IF( ABS( A ).GT.ABS( C ) ) THEN 
         ACMX = A 
         ACMN = C 
      ELSE 
         ACMX = C 
         ACMN = A 
      END IF 
      IF( ADF.GT.AB ) THEN 
         RT = ADF*SQRT( ONE+( AB / ADF )**2 ) 
      ELSE IF( ADF.LT.AB ) THEN 
         RT = AB*SQRT( ONE+( ADF / AB )**2 ) 
      ELSE 
!                                                                       
!        Includes case AB=ADF=0                                         
!                                                                       
         RT = AB*SQRT( TWO ) 
      END IF 
      IF( SM.LT.ZERO ) THEN 
         RT1 = HALF*( SM-RT ) 
         SGN1 = -1 
!                                                                       
!        Order of execution important.                                  
!        To get fully accurate smaller eigenvalue,                      
!        next line needs to be executed in higher precision.            
!                                                                       
         RT2 = ( ACMX / RT1 )*ACMN - ( B / RT1 )*B 
      ELSE IF( SM.GT.ZERO ) THEN 
         RT1 = HALF*( SM+RT ) 
         SGN1 = 1 
!                                                                       
!        Order of execution important.                                  
!        To get fully accurate smaller eigenvalue,                      
!        next line needs to be executed in higher precision.            
!                                                                       
         RT2 = ( ACMX / RT1 )*ACMN - ( B / RT1 )*B 
      ELSE 
!                                                                       
!        Includes case RT1 = RT2 = 0                                    
!                                                                       
         RT1 = HALF*RT 
         RT2 = -HALF*RT 
         SGN1 = 1 
      END IF 
!                                                                       
!     Compute the eigenvector                                           
!                                                                       
      IF( DF.GE.ZERO ) THEN 
         CS = DF + RT 
         SGN2 = 1 
      ELSE 
         CS = DF - RT 
         SGN2 = -1 
      END IF 
      ACS = ABS( CS ) 
      IF( ACS.GT.AB ) THEN 
         CT = -TB / CS 
         SN1 = ONE / SQRT( ONE+CT*CT ) 
         CS1 = CT*SN1 
      ELSE 
         IF( AB.EQ.ZERO ) THEN 
            CS1 = ONE 
            SN1 = ZERO 
         ELSE 
            TN = -CS / TB 
            CS1 = ONE / SQRT( ONE+TN*TN ) 
            SN1 = TN*CS1 
         END IF 
      END IF 
      IF( SGN1.EQ.SGN2 ) THEN 
         TN = CS1 
         CS1 = -SN1 
         SN1 = TN 
      END IF 
      RETURN 
!                                                                       
!     End of SLAEV2                                                     
!                                                                       
      END                                           
!> \brief \b SLAGTF computes an LU factorization of a matrix T-I, wher
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLAGTF + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SLAGTF( N, A, LAMBDA, B, C, TOL, D, IN, INFO )       
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            INFO, N                                      
!       REAL               LAMBDA, TOL                                  
!       ..                                                              
!       .. Array Arguments ..                                           
!       INTEGER            IN( * )                                      
!       REAL               A( * ), B( * ), C( * ), D( * )               
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SLAGTF factorizes the matrix (T - lambda*I), where T is an n by n    
!> tridiagonal matrix and lambda is a scalar, as                        
!>                                                                      
!>    T - lambda*I = PLU,                                               
!>                                                                      
!> where P is a permutation matrix, L is a unit lower tridiagonal matrix
!> with at most one non-zero sub-diagonal elements per column and U is  
!> an upper triangular matrix with at most two non-zero super-diagonal  
!> elements per column.                                                 
!>                                                                      
!> The factorization is obtained by Gaussian elimination with partial   
!> pivoting and implicit row scaling.                                   
!>                                                                      
!> The parameter LAMBDA is included in the routine so that SLAGTF may   
!> be used, in conjunction with SLAGTS, to obtain eigenvectors of T by  
!> inverse iteration.                                                   
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix T.                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] A                                                     
!> \verbatim                                                            
!>          A is REAL array, dimension (N)                              
!>          On entry, A must contain the diagonal elements of T.        
!>                                                                      
!>          On exit, A is overwritten by the n diagonal elements of the 
!>          upper triangular matrix U of the factorization of T.        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LAMBDA                                                    
!> \verbatim                                                            
!>          LAMBDA is REAL                                              
!>          On entry, the scalar lambda.                                
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] B                                                     
!> \verbatim                                                            
!>          B is REAL array, dimension (N-1)                            
!>          On entry, B must contain the (n-1) super-diagonal elements o
!>          T.                                                          
!>                                                                      
!>          On exit, B is overwritten by the (n-1) super-diagonal       
!>          elements of the matrix U of the factorization of T.         
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] C                                                     
!> \verbatim                                                            
!>          C is REAL array, dimension (N-1)                            
!>          On entry, C must contain the (n-1) sub-diagonal elements of 
!>          T.                                                          
!>                                                                      
!>          On exit, C is overwritten by the (n-1) sub-diagonal elements
!>          of the matrix L of the factorization of T.                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TOL                                                       
!> \verbatim                                                            
!>          TOL is REAL                                                 
!>          On entry, a relative tolerance used to indicate whether or  
!>          not the matrix (T - lambda*I) is nearly singular. TOL should
!>          normally be chose as approximately the largest relative erro
!>          in the elements of T. For example, if the elements of T are 
!>          correct to about 4 significant figures, then TOL should be  
!>          set to about 5*10**(-4). If TOL is supplied as less than eps
!>          where eps is the relative machine precision, then the value 
!>          eps is used in place of TOL.                                
!> \endverbatim                                                         
!>                                                                      
!> \param[out] D                                                        
!> \verbatim                                                            
!>          D is REAL array, dimension (N-2)                            
!>          On exit, D is overwritten by the (n-2) second super-diagonal
!>          elements of the matrix U of the factorization of T.         
!> \endverbatim                                                         
!>                                                                      
!> \param[out] IN                                                       
!> \verbatim                                                            
!>          IN is INTEGER array, dimension (N)                          
!>          On exit, IN contains details of the permutation matrix P. If
!>          an interchange occurred at the kth step of the elimination, 
!>          then IN(k) = 1, otherwise IN(k) = 0. The element IN(n)      
!>          returns the smallest positive integer j such that           
!>                                                                      
!>             abs( u(j,j) ) <= norm( (T - lambda*I)(j) )*TOL,          
!>                                                                      
!>          where norm( A(j) ) denotes the sum of the absolute values of
!>          the jth row of the matrix A. If no such j exists then IN(n) 
!>          is returned as zero. If IN(n) is returned as positive, then 
!>          diagonal element of U is small, indicating that             
!>          (T - lambda*I) is singular or nearly singular,              
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0: successful exit                                        
!>          < 0: if INFO = -k, the kth argument had an illegal value    
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup auxOTHERcomputational                                       
!                                                                       
!  =====================================================================
      SUBROUTINE SLAGTF( N, A, LAMBDA, B, C, TOL, D, IN, INFO ) 
!                                                                       
!  -- LAPACK computational routine (version 3.7.0) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            INFO, N 
      REAL               LAMBDA, TOL 
!     ..                                                                
!     .. Array Arguments ..                                             
      INTEGER            IN( * ) 
      REAL               A( * ), B( * ), C( * ), D( * ) 
!     ..                                                                
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Parameters ..                                                  
      REAL               ZERO 
      PARAMETER          ( ZERO = 0.0E+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            K 
      REAL               EPS, MULT, PIV1, PIV2, SCALE1, SCALE2, TEMP, TL 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, MAX 
!     ..                                                                
!     .. External Functions ..                                          
      REAL               SLAMCH 
      EXTERNAL           SLAMCH 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           XERBLA 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      INFO = 0 
      IF( N.LT.0 ) THEN 
         INFO = -1 
         CALL XERBLA( 'SLAGTF', -INFO ) 
         RETURN 
      END IF 
!                                                                       
      IF( N.EQ.0 )                                                      &
     &   RETURN                                                         
!                                                                       
      A( 1 ) = A( 1 ) - LAMBDA 
      IN( N ) = 0 
      IF( N.EQ.1 ) THEN 
         IF( A( 1 ).EQ.ZERO )                                           &
     &      IN( 1 ) = 1                                                 
         RETURN 
      END IF 
!                                                                       
      EPS = SLAMCH( 'Epsilon' ) 
!                                                                       
      TL = MAX( TOL, EPS ) 
      SCALE1 = ABS( A( 1 ) ) + ABS( B( 1 ) ) 
      DO 10 K = 1, N - 1 
         A( K+1 ) = A( K+1 ) - LAMBDA 
         SCALE2 = ABS( C( K ) ) + ABS( A( K+1 ) ) 
         IF( K.LT.( N-1 ) )                                             &
     &      SCALE2 = SCALE2 + ABS( B( K+1 ) )                           
         IF( A( K ).EQ.ZERO ) THEN 
            PIV1 = ZERO 
         ELSE 
            PIV1 = ABS( A( K ) ) / SCALE1 
         END IF 
         IF( C( K ).EQ.ZERO ) THEN 
            IN( K ) = 0 
            PIV2 = ZERO 
            SCALE1 = SCALE2 
            IF( K.LT.( N-1 ) )                                          &
     &         D( K ) = ZERO                                            
         ELSE 
            PIV2 = ABS( C( K ) ) / SCALE2 
            IF( PIV2.LE.PIV1 ) THEN 
               IN( K ) = 0 
               SCALE1 = SCALE2 
               C( K ) = C( K ) / A( K ) 
               A( K+1 ) = A( K+1 ) - C( K )*B( K ) 
               IF( K.LT.( N-1 ) )                                       &
     &            D( K ) = ZERO                                         
            ELSE 
               IN( K ) = 1 
               MULT = A( K ) / C( K ) 
               A( K ) = C( K ) 
               TEMP = A( K+1 ) 
               A( K+1 ) = B( K ) - MULT*TEMP 
               IF( K.LT.( N-1 ) ) THEN 
                  D( K ) = B( K+1 ) 
                  B( K+1 ) = -MULT*D( K ) 
               END IF 
               B( K ) = TEMP 
               C( K ) = MULT 
            END IF 
         END IF 
         IF( ( MAX( PIV1, PIV2 ).LE.TL ) .AND. ( IN( N ).EQ.0 ) )       &
     &      IN( N ) = K                                                 
   10 END DO 
      IF( ( ABS( A( N ) ).LE.SCALE1*TL ) .AND. ( IN( N ).EQ.0 ) )       &
     &   IN( N ) = N                                                    
!                                                                       
      RETURN 
!                                                                       
!     End of SLAGTF                                                     
!                                                                       
      END                                           
!> \brief \b SLAGTS solves the system of equations (T-I)x = y or (T-
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLAGTS + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SLAGTS( JOB, N, A, B, C, D, IN, Y, TOL, INFO )       
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            INFO, JOB, N                                 
!       REAL               TOL                                          
!       ..                                                              
!       .. Array Arguments ..                                           
!       INTEGER            IN( * )                                      
!       REAL               A( * ), B( * ), C( * ), D( * ), Y( * )       
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SLAGTS may be used to solve one of the systems of equations          
!>                                                                      
!>    (T - lambda*I)*x = y   or   (T - lambda*I)**T*x = y,              
!>                                                                      
!> where T is an n by n tridiagonal matrix, for x, following the        
!> factorization of (T - lambda*I) as                                   
!>                                                                      
!>    (T - lambda*I) = P*L*U ,                                          
!>                                                                      
!> by routine SLAGTF. The choice of equation to be solved is            
!> controlled by the argument JOB, and in each case there is an option  
!> to perturb zero or very small diagonal elements of U, this option    
!> being intended for use in applications such as inverse iteration.    
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] JOB                                                       
!> \verbatim                                                            
!>          JOB is INTEGER                                              
!>          Specifies the job to be performed by SLAGTS as follows:     
!>          =  1: The equations  (T - lambda*I)x = y  are to be solved, 
!>                but diagonal elements of U are not to be perturbed.   
!>          = -1: The equations  (T - lambda*I)x = y  are to be solved  
!>                and, if overflow would otherwise occur, the diagonal  
!>                elements of U are to be perturbed. See argument TOL   
!>                below.                                                
!>          =  2: The equations  (T - lambda*I)**Tx = y  are to be solve
!>                but diagonal elements of U are not to be perturbed.   
!>          = -2: The equations  (T - lambda*I)**Tx = y  are to be solve
!>                and, if overflow would otherwise occur, the diagonal  
!>                elements of U are to be perturbed. See argument TOL   
!>                below.                                                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix T.                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is REAL array, dimension (N)                              
!>          On entry, A must contain the diagonal elements of U as      
!>          returned from SLAGTF.                                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] B                                                         
!> \verbatim                                                            
!>          B is REAL array, dimension (N-1)                            
!>          On entry, B must contain the first super-diagonal elements o
!>          U as returned from SLAGTF.                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] C                                                         
!> \verbatim                                                            
!>          C is REAL array, dimension (N-1)                            
!>          On entry, C must contain the sub-diagonal elements of L as  
!>          returned from SLAGTF.                                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] D                                                         
!> \verbatim                                                            
!>          D is REAL array, dimension (N-2)                            
!>          On entry, D must contain the second super-diagonal elements 
!>          of U as returned from SLAGTF.                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IN                                                        
!> \verbatim                                                            
!>          IN is INTEGER array, dimension (N)                          
!>          On entry, IN must contain details of the matrix P as returne
!>          from SLAGTF.                                                
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] Y                                                     
!> \verbatim                                                            
!>          Y is REAL array, dimension (N)                              
!>          On entry, the right hand side vector y.                     
!>          On exit, Y is overwritten by the solution vector x.         
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] TOL                                                   
!> \verbatim                                                            
!>          TOL is REAL                                                 
!>          On entry, with  JOB < 0, TOL should be the minimum          
!>          perturbation to be made to very small diagonal elements of U
!>          TOL should normally be chosen as about eps*norm(U), where ep
!>          is the relative machine precision, but if TOL is supplied as
!>          non-positive, then it is reset to eps*max( abs( u(i,j) ) ). 
!>          If  JOB > 0  then TOL is not referenced.                    
!>                                                                      
!>          On exit, TOL is changed as described above, only if TOL is  
!>          non-positive on entry. Otherwise TOL is unchanged.          
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0: successful exit                                        
!>          < 0: if INFO = -i, the i-th argument had an illegal value   
!>          > 0: overflow would occur when computing the INFO(th)       
!>               element of the solution vector x. This can only occur  
!>               when JOB is supplied as positive and either means      
!>               that a diagonal element of U is very small, or that    
!>               the elements of the right-hand side vector y are very  
!>               large.                                                 
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!  =====================================================================
      SUBROUTINE SLAGTS( JOB, N, A, B, C, D, IN, Y, TOL, INFO ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            INFO, JOB, N 
      REAL               TOL 
!     ..                                                                
!     .. Array Arguments ..                                             
      INTEGER            IN( * ) 
      REAL               A( * ), B( * ), C( * ), D( * ), Y( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ONE, ZERO 
      PARAMETER          ( ONE = 1.0E+0, ZERO = 0.0E+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            K 
      REAL               ABSAK, AK, BIGNUM, EPS, PERT, SFMIN, TEMP 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, MAX, SIGN 
!     ..                                                                
!     .. External Functions ..                                          
      REAL               SLAMCH 
      EXTERNAL           SLAMCH 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           XERBLA 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      INFO = 0 
      IF( ( ABS( JOB ).GT.2 ) .OR. ( JOB.EQ.0 ) ) THEN 
         INFO = -1 
      ELSE IF( N.LT.0 ) THEN 
         INFO = -2 
      END IF 
      IF( INFO.NE.0 ) THEN 
         CALL XERBLA( 'SLAGTS', -INFO ) 
         RETURN 
      END IF 
!                                                                       
      IF( N.EQ.0 )                                                      &
     &   RETURN                                                         
!                                                                       
      EPS = SLAMCH( 'Epsilon' ) 
      SFMIN = SLAMCH( 'Safe minimum' ) 
      BIGNUM = ONE / SFMIN 
!                                                                       
      IF( JOB.LT.0 ) THEN 
         IF( TOL.LE.ZERO ) THEN 
            TOL = ABS( A( 1 ) ) 
            IF( N.GT.1 )                                                &
     &         TOL = MAX( TOL, ABS( A( 2 ) ), ABS( B( 1 ) ) )           
            DO 10 K = 3, N 
               TOL = MAX( TOL, ABS( A( K ) ), ABS( B( K-1 ) ),          &
     &               ABS( D( K-2 ) ) )                                  
   10       CONTINUE 
            TOL = TOL*EPS 
            IF( TOL.EQ.ZERO )                                           &
     &         TOL = EPS                                                
         END IF 
      END IF 
!                                                                       
      IF( ABS( JOB ).EQ.1 ) THEN 
         DO 20 K = 2, N 
            IF( IN( K-1 ).EQ.0 ) THEN 
               Y( K ) = Y( K ) - C( K-1 )*Y( K-1 ) 
            ELSE 
               TEMP = Y( K-1 ) 
               Y( K-1 ) = Y( K ) 
               Y( K ) = TEMP - C( K-1 )*Y( K ) 
            END IF 
   20    CONTINUE 
         IF( JOB.EQ.1 ) THEN 
            DO 30 K = N, 1, -1 
               IF( K.LE.N-2 ) THEN 
                  TEMP = Y( K ) - B( K )*Y( K+1 ) - D( K )*Y( K+2 ) 
               ELSE IF( K.EQ.N-1 ) THEN 
                  TEMP = Y( K ) - B( K )*Y( K+1 ) 
               ELSE 
                  TEMP = Y( K ) 
               END IF 
               AK = A( K ) 
               ABSAK = ABS( AK ) 
               IF( ABSAK.LT.ONE ) THEN 
                  IF( ABSAK.LT.SFMIN ) THEN 
                     IF( ABSAK.EQ.ZERO .OR. ABS( TEMP )*SFMIN.GT.ABSAK )&
     &                    THEN                                          
                        INFO = K 
                        RETURN 
                     ELSE 
                        TEMP = TEMP*BIGNUM 
                        AK = AK*BIGNUM 
                     END IF 
                  ELSE IF( ABS( TEMP ).GT.ABSAK*BIGNUM ) THEN 
                     INFO = K 
                     RETURN 
                  END IF 
               END IF 
               Y( K ) = TEMP / AK 
   30       CONTINUE 
         ELSE 
            DO 50 K = N, 1, -1 
               IF( K.LE.N-2 ) THEN 
                  TEMP = Y( K ) - B( K )*Y( K+1 ) - D( K )*Y( K+2 ) 
               ELSE IF( K.EQ.N-1 ) THEN 
                  TEMP = Y( K ) - B( K )*Y( K+1 ) 
               ELSE 
                  TEMP = Y( K ) 
               END IF 
               AK = A( K ) 
               PERT = SIGN( TOL, AK ) 
   40          CONTINUE 
               ABSAK = ABS( AK ) 
               IF( ABSAK.LT.ONE ) THEN 
                  IF( ABSAK.LT.SFMIN ) THEN 
                     IF( ABSAK.EQ.ZERO .OR. ABS( TEMP )*SFMIN.GT.ABSAK )&
     &                    THEN                                          
                        AK = AK + PERT 
                        PERT = 2*PERT 
                        GO TO 40 
                     ELSE 
                        TEMP = TEMP*BIGNUM 
                        AK = AK*BIGNUM 
                     END IF 
                  ELSE IF( ABS( TEMP ).GT.ABSAK*BIGNUM ) THEN 
                     AK = AK + PERT 
                     PERT = 2*PERT 
                     GO TO 40 
                  END IF 
               END IF 
               Y( K ) = TEMP / AK 
   50       CONTINUE 
         END IF 
      ELSE 
!                                                                       
!        Come to here if  JOB = 2 or -2                                 
!                                                                       
         IF( JOB.EQ.2 ) THEN 
            DO 60 K = 1, N 
               IF( K.GE.3 ) THEN 
                  TEMP = Y( K ) - B( K-1 )*Y( K-1 ) - D( K-2 )*Y( K-2 ) 
               ELSE IF( K.EQ.2 ) THEN 
                  TEMP = Y( K ) - B( K-1 )*Y( K-1 ) 
               ELSE 
                  TEMP = Y( K ) 
               END IF 
               AK = A( K ) 
               ABSAK = ABS( AK ) 
               IF( ABSAK.LT.ONE ) THEN 
                  IF( ABSAK.LT.SFMIN ) THEN 
                     IF( ABSAK.EQ.ZERO .OR. ABS( TEMP )*SFMIN.GT.ABSAK )&
     &                    THEN                                          
                        INFO = K 
                        RETURN 
                     ELSE 
                        TEMP = TEMP*BIGNUM 
                        AK = AK*BIGNUM 
                     END IF 
                  ELSE IF( ABS( TEMP ).GT.ABSAK*BIGNUM ) THEN 
                     INFO = K 
                     RETURN 
                  END IF 
               END IF 
               Y( K ) = TEMP / AK 
   60       CONTINUE 
         ELSE 
            DO 80 K = 1, N 
               IF( K.GE.3 ) THEN 
                  TEMP = Y( K ) - B( K-1 )*Y( K-1 ) - D( K-2 )*Y( K-2 ) 
               ELSE IF( K.EQ.2 ) THEN 
                  TEMP = Y( K ) - B( K-1 )*Y( K-1 ) 
               ELSE 
                  TEMP = Y( K ) 
               END IF 
               AK = A( K ) 
               PERT = SIGN( TOL, AK ) 
   70          CONTINUE 
               ABSAK = ABS( AK ) 
               IF( ABSAK.LT.ONE ) THEN 
                  IF( ABSAK.LT.SFMIN ) THEN 
                     IF( ABSAK.EQ.ZERO .OR. ABS( TEMP )*SFMIN.GT.ABSAK )&
     &                    THEN                                          
                        AK = AK + PERT 
                        PERT = 2*PERT 
                        GO TO 70 
                     ELSE 
                        TEMP = TEMP*BIGNUM 
                        AK = AK*BIGNUM 
                     END IF 
                  ELSE IF( ABS( TEMP ).GT.ABSAK*BIGNUM ) THEN 
                     AK = AK + PERT 
                     PERT = 2*PERT 
                     GO TO 70 
                  END IF 
               END IF 
               Y( K ) = TEMP / AK 
   80       CONTINUE 
         END IF 
!                                                                       
         DO 90 K = N, 2, -1 
            IF( IN( K-1 ).EQ.0 ) THEN 
               Y( K-1 ) = Y( K-1 ) - C( K-1 )*Y( K ) 
            ELSE 
               TEMP = Y( K-1 ) 
               Y( K-1 ) = Y( K ) 
               Y( K ) = TEMP - C( K-1 )*Y( K ) 
            END IF 
   90    CONTINUE 
      END IF 
!                                                                       
!     End of SLAGTS                                                     
!                                                                       
      END                                           
!> \brief \b SLAISNAN tests input for NaN by comparing two arguments for
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLAISNAN + dependencies                                     
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       LOGICAL FUNCTION SLAISNAN( SIN1, SIN2 )                         
!                                                                       
!       .. Scalar Arguments ..                                          
!       REAL, INTENT(IN) :: SIN1, SIN2                                  
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> This routine is not for general use.  It exists solely to avoid      
!> over-optimization in SISNAN.                                         
!>                                                                      
!> SLAISNAN checks for NaNs by comparing its two arguments for          
!> inequality.  NaN is the only floating-point value where NaN != NaN   
!> returns .TRUE.  To check for NaNs, pass the same variable as both    
!> arguments.                                                           
!>                                                                      
!> A compiler must assume that the two arguments are                    
!> not the same variable, and the test will not be optimized away.      
!> Interprocedural or whole-program optimization may delete this        
!> test.  The ISNAN functions will be replaced by the correct           
!> Fortran 03 intrinsic once the intrinsic is widely available.         
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] SIN1                                                      
!> \verbatim                                                            
!>          SIN1 is REAL                                                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] SIN2                                                      
!> \verbatim                                                            
!>          SIN2 is REAL                                                
!>          Two numbers to compare for inequality.                      
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2017                                                      
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!  =====================================================================
      LOGICAL FUNCTION SLAISNAN( SIN1, SIN2 ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.1) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2017                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      REAL, INTENT(IN) :: SIN1, SIN2 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!  .. Executable Statements ..                                          
      SLAISNAN = (SIN1.NE.SIN2) 
      RETURN 
      END                                           
!> \brief \b SLANEG computes the Sturm count.                           
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLANEG + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       INTEGER FUNCTION SLANEG( N, D, LLD, SIGMA, PIVMIN, R )          
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            N, R                                         
!       REAL               PIVMIN, SIGMA                                
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL               D( * ), LLD( * )                             
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SLANEG computes the Sturm count, the number of negative pivots       
!> encountered while factoring tridiagonal T - sigma I = L D L^T.       
!> This implementation works directly on the factors without forming    
!> the tridiagonal matrix T.  The Sturm count is also the number of     
!> eigenvalues of T less than sigma.                                    
!>                                                                      
!> This routine is called from SLARRB.                                  
!>                                                                      
!> The current routine does not use the PIVMIN parameter but rather     
!> requires IEEE-754 propagation of Infinities and NaNs.  This          
!> routine also has no input range restrictions but does require        
!> default exception handling such that x/0 produces Inf when x is      
!> non-zero, and Inf/Inf produces NaN.  For more information, see:      
!>                                                                      
!>   Marques, Riedy, and Voemel, "Benefits of IEEE-754 Features in      
!>   Modern Symmetric Tridiagonal Eigensolvers," SIAM Journal on        
!>   Scientific Computing, v28, n5, 2006.  DOI 10.1137/050641624        
!>   (Tech report version in LAWN 172 with the same title.)             
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix.                                    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] D                                                         
!> \verbatim                                                            
!>          D is REAL array, dimension (N)                              
!>          The N diagonal elements of the diagonal matrix D.           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LLD                                                       
!> \verbatim                                                            
!>          LLD is REAL array, dimension (N-1)                          
!>          The (N-1) elements L(i)*L(i)*D(i).                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] SIGMA                                                     
!> \verbatim                                                            
!>          SIGMA is REAL                                               
!>          Shift amount in T - sigma I = L D L^T.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] PIVMIN                                                    
!> \verbatim                                                            
!>          PIVMIN is REAL                                              
!>          The minimum pivot in the Sturm sequence.  May be used       
!>          when zero pivots are encountered on non-IEEE-754            
!>          architectures.                                              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] R                                                         
!> \verbatim                                                            
!>          R is INTEGER                                                
!>          The twist index for the twisted factorization that is used  
!>          for the negcount.                                           
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!> \par Contributors:                                                   
!  ==================                                                   
!>                                                                      
!>     Osni Marques, LBNL/NERSC, USA \n                                 
!>     Christof Voemel, University of California, Berkeley, USA \n      
!>     Jason Riedy, University of California, Berkeley, USA \n          
!>                                                                      
!  =====================================================================
      INTEGER FUNCTION SLANEG( N, D, LLD, SIGMA, PIVMIN, R ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            N, R 
      REAL               PIVMIN, SIGMA 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               D( * ), LLD( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ZERO, ONE 
      PARAMETER        ( ZERO = 0.0E0, ONE = 1.0E0 ) 
!     Some architectures propagate Infinities and NaNs very slowly, so  
!     the code computes counts in BLKLEN chunks.  Then a NaN can        
!     propagate at most BLKLEN columns before being detected.  This is  
!     not a general tuning parameter; it needs only to be just large    
!     enough that the overhead is tiny in common cases.                 
      INTEGER BLKLEN 
      PARAMETER ( BLKLEN = 128 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            BJ, J, NEG1, NEG2, NEGCNT 
      REAL               BSAV, DMINUS, DPLUS, GAMMA, P, T, TMP 
      LOGICAL SAWNAN 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC MIN, MAX 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL SISNAN 
      EXTERNAL SISNAN 
!     ..                                                                
!     .. Executable Statements ..                                       
                                                                        
      NEGCNT = 0 
                                                                        
!     I) upper part: L D L^T - SIGMA I = L+ D+ L+^T                     
      T = -SIGMA 
      DO 210 BJ = 1, R-1, BLKLEN 
         NEG1 = 0 
         BSAV = T 
         DO 21 J = BJ, MIN(BJ+BLKLEN-1, R-1) 
            DPLUS = D( J ) + T 
            IF( DPLUS.LT.ZERO ) NEG1 = NEG1 + 1 
            TMP = T / DPLUS 
            T = TMP * LLD( J ) - SIGMA 
   21    CONTINUE 
         SAWNAN = SISNAN( T ) 
!     Run a slower version of the above loop if a NaN is detected.      
!     A NaN should occur only with a zero pivot after an infinite       
!     pivot.  In that case, substituting 1 for T/DPLUS is the           
!     correct limit.                                                    
         IF( SAWNAN ) THEN 
            NEG1 = 0 
            T = BSAV 
            DO 22 J = BJ, MIN(BJ+BLKLEN-1, R-1) 
               DPLUS = D( J ) + T 
               IF( DPLUS.LT.ZERO ) NEG1 = NEG1 + 1 
               TMP = T / DPLUS 
               IF (SISNAN(TMP)) TMP = ONE 
               T = TMP * LLD(J) - SIGMA 
   22       CONTINUE 
         END IF 
         NEGCNT = NEGCNT + NEG1 
  210 END DO 
!                                                                       
!     II) lower part: L D L^T - SIGMA I = U- D- U-^T                    
      P = D( N ) - SIGMA 
      DO 230 BJ = N-1, R, -BLKLEN 
         NEG2 = 0 
         BSAV = P 
         DO 23 J = BJ, MAX(BJ-BLKLEN+1, R), -1 
            DMINUS = LLD( J ) + P 
            IF( DMINUS.LT.ZERO ) NEG2 = NEG2 + 1 
            TMP = P / DMINUS 
            P = TMP * D( J ) - SIGMA 
   23    CONTINUE 
         SAWNAN = SISNAN( P ) 
!     As above, run a slower version that substitutes 1 for Inf/Inf.    
!                                                                       
         IF( SAWNAN ) THEN 
            NEG2 = 0 
            P = BSAV 
            DO 24 J = BJ, MAX(BJ-BLKLEN+1, R), -1 
               DMINUS = LLD( J ) + P 
               IF( DMINUS.LT.ZERO ) NEG2 = NEG2 + 1 
               TMP = P / DMINUS 
               IF (SISNAN(TMP)) TMP = ONE 
               P = TMP * D(J) - SIGMA 
   24       CONTINUE 
         END IF 
         NEGCNT = NEGCNT + NEG2 
  230 END DO 
!                                                                       
!     III) Twist index                                                  
!       T was shifted by SIGMA initially.                               
      GAMMA = (T + SIGMA) + P 
      IF( GAMMA.LT.ZERO ) NEGCNT = NEGCNT+1 
                                                                        
      SLANEG = NEGCNT 
      END                                           
!> \brief \b SLANST returns the value of the 1-norm, or the Frobenius no
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLANST + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       REAL             FUNCTION SLANST( NORM, N, D, E )               
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          NORM                                         
!       INTEGER            N                                            
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL               D( * ), E( * )                               
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SLANST  returns the value of the one norm,  or the Frobenius norm, or
!> the  infinity norm,  or the  element of  largest absolute value  of a
!> real symmetric tridiagonal matrix A.                                 
!> \endverbatim                                                         
!>                                                                      
!> \return SLANST                                                       
!> \verbatim                                                            
!>                                                                      
!>    SLANST = ( max(abs(A(i,j))), NORM = 'M' or 'm'                    
!>             (                                                        
!>             ( norm1(A),         NORM = '1', 'O' or 'o'               
!>             (                                                        
!>             ( normI(A),         NORM = 'I' or 'i'                    
!>             (                                                        
!>             ( normF(A),         NORM = 'F', 'f', 'E' or 'e'          
!>                                                                      
!> where  norm1  denotes the  one norm of a matrix (maximum column sum),
!> normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
!> normF  denotes the  Frobenius norm of a matrix (square root of sum of
!> squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix no
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] NORM                                                      
!> \verbatim                                                            
!>          NORM is CHARACTER*1                                         
!>          Specifies the value to be returned in SLANST as described   
!>          above.                                                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix A.  N >= 0.  When N = 0, SLANST is  
!>          set to zero.                                                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] D                                                         
!> \verbatim                                                            
!>          D is REAL array, dimension (N)                              
!>          The diagonal elements of A.                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] E                                                         
!> \verbatim                                                            
!>          E is REAL array, dimension (N-1)                            
!>          The (n-1) sub-diagonal or super-diagonal elements of A.     
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!  =====================================================================
      REAL             FUNCTION SLANST( NORM, N, D, E ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          NORM 
      INTEGER            N 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               D( * ), E( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ONE, ZERO 
      PARAMETER          ( ONE = 1.0E+0, ZERO = 0.0E+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I 
      REAL               ANORM, SCALE, SUM 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME, SISNAN 
      EXTERNAL           LSAME, SISNAN 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           SLASSQ 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, SQRT 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      IF( N.LE.0 ) THEN 
         ANORM = ZERO 
      ELSE IF( LSAME( NORM, 'M' ) ) THEN 
!                                                                       
!        Find max(abs(A(i,j))).                                         
!                                                                       
         ANORM = ABS( D( N ) ) 
         DO 10 I = 1, N - 1 
            SUM = ABS( D( I ) ) 
            IF( ANORM .LT. SUM .OR. SISNAN( SUM ) ) ANORM = SUM 
            SUM = ABS( E( I ) ) 
            IF( ANORM .LT. SUM .OR. SISNAN( SUM ) ) ANORM = SUM 
   10    CONTINUE 
      ELSE IF( LSAME( NORM, 'O' ) .OR. NORM.EQ.'1' .OR.                 &
     &         LSAME( NORM, 'I' ) ) THEN                                
!                                                                       
!        Find norm1(A).                                                 
!                                                                       
         IF( N.EQ.1 ) THEN 
            ANORM = ABS( D( 1 ) ) 
         ELSE 
            ANORM = ABS( D( 1 ) )+ABS( E( 1 ) ) 
            SUM = ABS( E( N-1 ) )+ABS( D( N ) ) 
            IF( ANORM .LT. SUM .OR. SISNAN( SUM ) ) ANORM = SUM 
            DO 20 I = 2, N - 1 
               SUM = ABS( D( I ) )+ABS( E( I ) )+ABS( E( I-1 ) ) 
               IF( ANORM .LT. SUM .OR. SISNAN( SUM ) ) ANORM = SUM 
   20       CONTINUE 
         END IF 
      ELSE IF( ( LSAME( NORM, 'F' ) ) .OR. ( LSAME( NORM, 'E' ) ) ) THEN 
!                                                                       
!        Find normF(A).                                                 
!                                                                       
         SCALE = ZERO 
         SUM = ONE 
         IF( N.GT.1 ) THEN 
            CALL SLASSQ( N-1, E, 1, SCALE, SUM ) 
            SUM = 2*SUM 
         END IF 
         CALL SLASSQ( N, D, 1, SCALE, SUM ) 
         ANORM = SCALE*SQRT( SUM ) 
      END IF 
!                                                                       
      SLANST = ANORM 
      RETURN 
!                                                                       
!     End of SLANST                                                     
!                                                                       
      END                                           
!> \brief \b SLANSY returns the value of the 1-norm, or the Frobenius no
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLANSY + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       REAL             FUNCTION SLANSY( NORM, UPLO, N, A, LDA, WORK ) 
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          NORM, UPLO                                   
!       INTEGER            LDA, N                                       
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL               A( LDA, * ), WORK( * )                       
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SLANSY  returns the value of the one norm,  or the Frobenius norm, or
!> the  infinity norm,  or the  element of  largest absolute value  of a
!> real symmetric matrix A.                                             
!> \endverbatim                                                         
!>                                                                      
!> \return SLANSY                                                       
!> \verbatim                                                            
!>                                                                      
!>    SLANSY = ( max(abs(A(i,j))), NORM = 'M' or 'm'                    
!>             (                                                        
!>             ( norm1(A),         NORM = '1', 'O' or 'o'               
!>             (                                                        
!>             ( normI(A),         NORM = 'I' or 'i'                    
!>             (                                                        
!>             ( normF(A),         NORM = 'F', 'f', 'E' or 'e'          
!>                                                                      
!> where  norm1  denotes the  one norm of a matrix (maximum column sum),
!> normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
!> normF  denotes the  Frobenius norm of a matrix (square root of sum of
!> squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix no
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] NORM                                                      
!> \verbatim                                                            
!>          NORM is CHARACTER*1                                         
!>          Specifies the value to be returned in SLANSY as described   
!>          above.                                                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] UPLO                                                      
!> \verbatim                                                            
!>          UPLO is CHARACTER*1                                         
!>          Specifies whether the upper or lower triangular part of the 
!>          symmetric matrix A is to be referenced.                     
!>          = 'U':  Upper triangular part of A is referenced            
!>          = 'L':  Lower triangular part of A is referenced            
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix A.  N >= 0.  When N = 0, SLANSY is  
!>          set to zero.                                                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is REAL array, dimension (LDA,N)                          
!>          The symmetric matrix A.  If UPLO = 'U', the leading n by n  
!>          upper triangular part of A contains the upper triangular par
!>          of the matrix A, and the strictly lower triangular part of A
!>          is not referenced.  If UPLO = 'L', the leading n by n lower 
!>          triangular part of A contains the lower triangular part of  
!>          the matrix A, and the strictly upper triangular part of A is
!>          not referenced.                                             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>          The leading dimension of the array A.  LDA >= max(N,1).     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is REAL array, dimension (MAX(1,LWORK)),               
!>          where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,  
!>          WORK is not referenced.                                     
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup realSYauxiliary                                             
!                                                                       
!  =====================================================================
      REAL             FUNCTION SLANSY( NORM, UPLO, N, A, LDA, WORK ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
      IMPLICIT NONE 
!     .. Scalar Arguments ..                                            
      CHARACTER          NORM, UPLO 
      INTEGER            LDA, N 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               A( LDA, * ), WORK( * ) 
!     ..                                                                
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Parameters ..                                                  
      REAL               ONE, ZERO 
      PARAMETER          ( ONE = 1.0E+0, ZERO = 0.0E+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I, J 
      REAL               ABSA, SUM, VALUE 
!     ..                                                                
!     .. Local Arrays ..                                                
      REAL               SSQ( 2 ), COLSSQ( 2 ) 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME, SISNAN 
      EXTERNAL           LSAME, SISNAN 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           SLASSQ, SCOMBSSQ 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, SQRT 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      IF( N.EQ.0 ) THEN 
         VALUE = ZERO 
      ELSE IF( LSAME( NORM, 'M' ) ) THEN 
!                                                                       
!        Find max(abs(A(i,j))).                                         
!                                                                       
         VALUE = ZERO 
         IF( LSAME( UPLO, 'U' ) ) THEN 
            DO 20 J = 1, N 
               DO 10 I = 1, J 
                  SUM = ABS( A( I, J ) ) 
                  IF( VALUE .LT. SUM .OR. SISNAN( SUM ) ) VALUE = SUM 
   10          CONTINUE 
   20       CONTINUE 
         ELSE 
            DO 40 J = 1, N 
               DO 30 I = J, N 
                  SUM = ABS( A( I, J ) ) 
                  IF( VALUE .LT. SUM .OR. SISNAN( SUM ) ) VALUE = SUM 
   30          CONTINUE 
   40       CONTINUE 
         END IF 
      ELSE IF( ( LSAME( NORM, 'I' ) ) .OR. ( LSAME( NORM, 'O' ) ) .OR.  &
     &         ( NORM.EQ.'1' ) ) THEN                                   
!                                                                       
!        Find normI(A) ( = norm1(A), since A is symmetric).             
!                                                                       
         VALUE = ZERO 
         IF( LSAME( UPLO, 'U' ) ) THEN 
            DO 60 J = 1, N 
               SUM = ZERO 
               DO 50 I = 1, J - 1 
                  ABSA = ABS( A( I, J ) ) 
                  SUM = SUM + ABSA 
                  WORK( I ) = WORK( I ) + ABSA 
   50          CONTINUE 
               WORK( J ) = SUM + ABS( A( J, J ) ) 
   60       CONTINUE 
            DO 70 I = 1, N 
               SUM = WORK( I ) 
               IF( VALUE .LT. SUM .OR. SISNAN( SUM ) ) VALUE = SUM 
   70       CONTINUE 
         ELSE 
            DO 80 I = 1, N 
               WORK( I ) = ZERO 
   80       CONTINUE 
            DO 100 J = 1, N 
               SUM = WORK( J ) + ABS( A( J, J ) ) 
               DO 90 I = J + 1, N 
                  ABSA = ABS( A( I, J ) ) 
                  SUM = SUM + ABSA 
                  WORK( I ) = WORK( I ) + ABSA 
   90          CONTINUE 
               IF( VALUE .LT. SUM .OR. SISNAN( SUM ) ) VALUE = SUM 
  100       CONTINUE 
         END IF 
      ELSE IF( ( LSAME( NORM, 'F' ) ) .OR. ( LSAME( NORM, 'E' ) ) ) THEN 
!                                                                       
!        Find normF(A).                                                 
!        SSQ(1) is scale                                                
!        SSQ(2) is sum-of-squares                                       
!        For better accuracy, sum each column separately.               
!                                                                       
         SSQ( 1 ) = ZERO 
         SSQ( 2 ) = ONE 
!                                                                       
!        Sum off-diagonals                                              
!                                                                       
         IF( LSAME( UPLO, 'U' ) ) THEN 
            DO 110 J = 2, N 
               COLSSQ( 1 ) = ZERO 
               COLSSQ( 2 ) = ONE 
               CALL SLASSQ( J-1, A( 1, J ), 1, COLSSQ(1), COLSSQ(2) ) 
               CALL SCOMBSSQ( SSQ, COLSSQ ) 
  110       CONTINUE 
         ELSE 
            DO 120 J = 1, N - 1 
               COLSSQ( 1 ) = ZERO 
               COLSSQ( 2 ) = ONE 
               CALL SLASSQ( N-J, A( J+1, J ), 1, COLSSQ(1), COLSSQ(2) ) 
               CALL SCOMBSSQ( SSQ, COLSSQ ) 
  120       CONTINUE 
         END IF 
         SSQ( 2 ) = 2*SSQ( 2 ) 
!                                                                       
!        Sum diagonal                                                   
!                                                                       
         COLSSQ( 1 ) = ZERO 
         COLSSQ( 2 ) = ONE 
         CALL SLASSQ( N, A, LDA+1, COLSSQ( 1 ), COLSSQ( 2 ) ) 
         CALL SCOMBSSQ( SSQ, COLSSQ ) 
         VALUE = SSQ( 1 )*SQRT( SSQ( 2 ) ) 
      END IF 
!                                                                       
      SLANSY = VALUE 
      RETURN 
!                                                                       
!     End of SLANSY                                                     
!                                                                       
      END                                           
!> \brief \b SLAPY2 returns sqrt(x2+y2).                                
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLAPY2 + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       REAL             FUNCTION SLAPY2( X, Y )                        
!                                                                       
!       .. Scalar Arguments ..                                          
!       REAL               X, Y                                         
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SLAPY2 returns sqrt(x**2+y**2), taking care not to cause unnecessary 
!> overflow.                                                            
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] X                                                         
!> \verbatim                                                            
!>          X is REAL                                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] Y                                                         
!> \verbatim                                                            
!>          Y is REAL                                                   
!>          X and Y specify the values x and y.                         
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2017                                                      
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!  =====================================================================
      REAL             FUNCTION SLAPY2( X, Y ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.1) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2017                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      REAL               X, Y 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ZERO 
      PARAMETER          ( ZERO = 0.0E0 ) 
      REAL               ONE 
      PARAMETER          ( ONE = 1.0E0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      REAL               W, XABS, YABS, Z 
      LOGICAL            X_IS_NAN, Y_IS_NAN 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            SISNAN 
      EXTERNAL           SISNAN 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, MAX, MIN, SQRT 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      X_IS_NAN = SISNAN( X ) 
      Y_IS_NAN = SISNAN( Y ) 
      IF ( X_IS_NAN ) SLAPY2 = X 
      IF ( Y_IS_NAN ) SLAPY2 = Y 
!                                                                       
      IF ( .NOT.( X_IS_NAN.OR.Y_IS_NAN ) ) THEN 
         XABS = ABS( X ) 
         YABS = ABS( Y ) 
         W = MAX( XABS, YABS ) 
         Z = MIN( XABS, YABS ) 
         IF( Z.EQ.ZERO ) THEN 
            SLAPY2 = W 
         ELSE 
            SLAPY2 = W*SQRT( ONE+( Z / W )**2 ) 
         END IF 
      END IF 
      RETURN 
!                                                                       
!     End of SLAPY2                                                     
!                                                                       
!> \brief \b SLAR1V computes the (scaled) r-th column of the inverse of 
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLAR1V + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SLAR1V( N, B1, BN, LAMBDA, D, L, LD, LLD,            
!                  PIVMIN, GAPTOL, Z, WANTNC, NEGCNT, ZTZ, MINGMA,      
!                  R, ISUPPZ, NRMINV, RESID, RQCORR, WORK )             
!                                                                       
!       .. Scalar Arguments ..                                          
!       LOGICAL            WANTNC                                       
!       INTEGER   B1, BN, N, NEGCNT, R                                  
!       REAL               GAPTOL, LAMBDA, MINGMA, NRMINV, PIVMIN, RESID
!      $                   RQCORR, ZTZ                                  
!       ..                                                              
!       .. Array Arguments ..                                           
!       INTEGER            ISUPPZ( * )                                  
!       REAL               D( * ), L( * ), LD( * ), LLD( * ),           
!      $                  WORK( * )                                     
!       REAL             Z( * )                                         
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SLAR1V computes the (scaled) r-th column of the inverse of           
!> the sumbmatrix in rows B1 through BN of the tridiagonal matrix       
!> L D L**T - sigma I. When sigma is close to an eigenvalue, the        
!> computed vector is an accurate eigenvector. Usually, r corresponds   
!> to the index where the eigenvector is largest in magnitude.          
!> The following steps accomplish this computation :                    
!> (a) Stationary qd transform,  L D L**T - sigma I = L(+) D(+) L(+)**T,
!> (b) Progressive qd transform, L D L**T - sigma I = U(-) D(-) U(-)**T,
!> (c) Computation of the diagonal elements of the inverse of           
!>     L D L**T - sigma I by combining the above transforms, and choosin
!>     r as the index where the diagonal of the inverse is (one of the) 
!>     largest in magnitude.                                            
!> (d) Computation of the (scaled) r-th column of the inverse using the 
!>     twisted factorization obtained by combining the top part of the  
!>     the stationary and the bottom part of the progressive transform. 
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>           The order of the matrix L D L**T.                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] B1                                                        
!> \verbatim                                                            
!>          B1 is INTEGER                                               
!>           First index of the submatrix of L D L**T.                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] BN                                                        
!> \verbatim                                                            
!>          BN is INTEGER                                               
!>           Last index of the submatrix of L D L**T.                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LAMBDA                                                    
!> \verbatim                                                            
!>          LAMBDA is REAL                                              
!>           The shift. In order to compute an accurate eigenvector,    
!>           LAMBDA should be a good approximation to an eigenvalue     
!>           of L D L**T.                                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] L                                                         
!> \verbatim                                                            
!>          L is REAL array, dimension (N-1)                            
!>           The (n-1) subdiagonal elements of the unit bidiagonal matri
!>           L, in elements 1 to N-1.                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] D                                                         
!> \verbatim                                                            
!>          D is REAL array, dimension (N)                              
!>           The n diagonal elements of the diagonal matrix D.          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LD                                                        
!> \verbatim                                                            
!>          LD is REAL array, dimension (N-1)                           
!>           The n-1 elements L(i)*D(i).                                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LLD                                                       
!> \verbatim                                                            
!>          LLD is REAL array, dimension (N-1)                          
!>           The n-1 elements L(i)*L(i)*D(i).                           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] PIVMIN                                                    
!> \verbatim                                                            
!>          PIVMIN is REAL                                              
!>           The minimum pivot in the Sturm sequence.                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] GAPTOL                                                    
!> \verbatim                                                            
!>          GAPTOL is REAL                                              
!>           Tolerance that indicates when eigenvector entries are negli
!>           w.r.t. their contribution to the residual.                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] Z                                                     
!> \verbatim                                                            
!>          Z is REAL array, dimension (N)                              
!>           On input, all entries of Z must be set to 0.               
!>           On output, Z contains the (scaled) r-th column of the      
!>           inverse. The scaling is such that Z(R) equals 1.           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] WANTNC                                                    
!> \verbatim                                                            
!>          WANTNC is LOGICAL                                           
!>           Specifies whether NEGCNT has to be computed.               
!> \endverbatim                                                         
!>                                                                      
!> \param[out] NEGCNT                                                   
!> \verbatim                                                            
!>          NEGCNT is INTEGER                                           
!>           If WANTNC is .TRUE. then NEGCNT = the number of pivots < pi
!>           in the  matrix factorization L D L**T, and NEGCNT = -1 othe
!> \endverbatim                                                         
!>                                                                      
!> \param[out] ZTZ                                                      
!> \verbatim                                                            
!>          ZTZ is REAL                                                 
!>           The square of the 2-norm of Z.                             
!> \endverbatim                                                         
!>                                                                      
!> \param[out] MINGMA                                                   
!> \verbatim                                                            
!>          MINGMA is REAL                                              
!>           The reciprocal of the largest (in magnitude) diagonal      
!>           element of the inverse of L D L**T - sigma I.              
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] R                                                     
!> \verbatim                                                            
!>          R is INTEGER                                                
!>           The twist index for the twisted factorization used to      
!>           compute Z.                                                 
!>           On input, 0 <= R <= N. If R is input as 0, R is set to     
!>           the index where (L D L**T - sigma I)^{-1} is largest       
!>           in magnitude. If 1 <= R <= N, R is unchanged.              
!>           On output, R contains the twist index used to compute Z.   
!>           Ideally, R designates the position of the maximum entry in 
!>           eigenvector.                                               
!> \endverbatim                                                         
!>                                                                      
!> \param[out] ISUPPZ                                                   
!> \verbatim                                                            
!>          ISUPPZ is INTEGER array, dimension (2)                      
!>           The support of the vector in Z, i.e., the vector Z is      
!>           nonzero only in elements ISUPPZ(1) through ISUPPZ( 2 ).    
!> \endverbatim                                                         
!>                                                                      
!> \param[out] NRMINV                                                   
!> \verbatim                                                            
!>          NRMINV is REAL                                              
!>           NRMINV = 1/SQRT( ZTZ )                                     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] RESID                                                    
!> \verbatim                                                            
!>          RESID is REAL                                               
!>           The residual of the FP vector.                             
!>           RESID = ABS( MINGMA )/SQRT( ZTZ )                          
!> \endverbatim                                                         
!>                                                                      
!> \param[out] RQCORR                                                   
!> \verbatim                                                            
!>          RQCORR is REAL                                              
!>           The Rayleigh Quotient correction to LAMBDA.                
!>           RQCORR = MINGMA*TMP                                        
!> \endverbatim                                                         
!>                                                                      
      END                                           
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is REAL array, dimension (4*N)                         
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup realOTHERauxiliary                                          
!                                                                       
!> \par Contributors:                                                   
!  ==================                                                   
!>                                                                      
!> Beresford Parlett, University of California, Berkeley, USA \n        
!> Jim Demmel, University of California, Berkeley, USA \n               
!> Inderjit Dhillon, University of Texas, Austin, USA \n                
!> Osni Marques, LBNL/NERSC, USA \n                                     
!> Christof Voemel, University of California, Berkeley, USA             
!                                                                       
!  =====================================================================
      SUBROUTINE SLAR1V( N, B1, BN, LAMBDA, D, L, LD, LLD,              &
     &           PIVMIN, GAPTOL, Z, WANTNC, NEGCNT, ZTZ, MINGMA,        &
     &           R, ISUPPZ, NRMINV, RESID, RQCORR, WORK )               
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      LOGICAL            WANTNC 
      INTEGER   B1, BN, N, NEGCNT, R 
      REAL               GAPTOL, LAMBDA, MINGMA, NRMINV, PIVMIN, RESID, &
     &                   RQCORR, ZTZ                                    
!     ..                                                                
!     .. Array Arguments ..                                             
      INTEGER            ISUPPZ( * ) 
      REAL               D( * ), L( * ), LD( * ), LLD( * ),             &
     &                  WORK( * )                                       
      REAL             Z( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ZERO, ONE 
      PARAMETER          ( ZERO = 0.0E0, ONE = 1.0E0 ) 
                                                                        
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            SAWNAN1, SAWNAN2 
      INTEGER            I, INDLPL, INDP, INDS, INDUMN, NEG1, NEG2, R1, &
     &                   R2                                             
      REAL               DMINUS, DPLUS, EPS, S, TMP 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL SISNAN 
      REAL               SLAMCH 
      EXTERNAL           SISNAN, SLAMCH 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      EPS = SLAMCH( 'Precision' ) 
                                                                        
                                                                        
      IF( R.EQ.0 ) THEN 
         R1 = B1 
         R2 = BN 
      ELSE 
         R1 = R 
         R2 = R 
      END IF 
                                                                        
!     Storage for LPLUS                                                 
      INDLPL = 0 
!     Storage for UMINUS                                                
      INDUMN = N 
      INDS = 2*N + 1 
      INDP = 3*N + 1 
                                                                        
      IF( B1.EQ.1 ) THEN 
         WORK( INDS ) = ZERO 
      ELSE 
         WORK( INDS+B1-1 ) = LLD( B1-1 ) 
      END IF 
                                                                        
!                                                                       
!     Compute the stationary transform (using the differential form)    
!     until the index R2.                                               
!                                                                       
      SAWNAN1 = .FALSE. 
      NEG1 = 0 
      S = WORK( INDS+B1-1 ) - LAMBDA 
      DO 50 I = B1, R1 - 1 
         DPLUS = D( I ) + S 
         WORK( INDLPL+I ) = LD( I ) / DPLUS 
         IF(DPLUS.LT.ZERO) NEG1 = NEG1 + 1 
         WORK( INDS+I ) = S*WORK( INDLPL+I )*L( I ) 
         S = WORK( INDS+I ) - LAMBDA 
   50 END DO 
      SAWNAN1 = SISNAN( S ) 
      IF( SAWNAN1 ) GOTO 60 
      DO 51 I = R1, R2 - 1 
         DPLUS = D( I ) + S 
         WORK( INDLPL+I ) = LD( I ) / DPLUS 
         WORK( INDS+I ) = S*WORK( INDLPL+I )*L( I ) 
         S = WORK( INDS+I ) - LAMBDA 
   51 END DO 
      SAWNAN1 = SISNAN( S ) 
!                                                                       
   60 CONTINUE 
      IF( SAWNAN1 ) THEN 
!        Runs a slower version of the above loop if a NaN is detected   
         NEG1 = 0 
         S = WORK( INDS+B1-1 ) - LAMBDA 
         DO 70 I = B1, R1 - 1 
            DPLUS = D( I ) + S 
            IF(ABS(DPLUS).LT.PIVMIN) DPLUS = -PIVMIN 
            WORK( INDLPL+I ) = LD( I ) / DPLUS 
            IF(DPLUS.LT.ZERO) NEG1 = NEG1 + 1 
            WORK( INDS+I ) = S*WORK( INDLPL+I )*L( I ) 
            IF( WORK( INDLPL+I ).EQ.ZERO )                              &
     &                      WORK( INDS+I ) = LLD( I )                   
            S = WORK( INDS+I ) - LAMBDA 
   70    CONTINUE 
         DO 71 I = R1, R2 - 1 
            DPLUS = D( I ) + S 
            IF(ABS(DPLUS).LT.PIVMIN) DPLUS = -PIVMIN 
            WORK( INDLPL+I ) = LD( I ) / DPLUS 
            WORK( INDS+I ) = S*WORK( INDLPL+I )*L( I ) 
            IF( WORK( INDLPL+I ).EQ.ZERO )                              &
     &                      WORK( INDS+I ) = LLD( I )                   
            S = WORK( INDS+I ) - LAMBDA 
   71    CONTINUE 
      END IF 
!                                                                       
!     Compute the progressive transform (using the differential form)   
!     until the index R1                                                
!                                                                       
      SAWNAN2 = .FALSE. 
      NEG2 = 0 
      WORK( INDP+BN-1 ) = D( BN ) - LAMBDA 
      DO 80 I = BN - 1, R1, -1 
         DMINUS = LLD( I ) + WORK( INDP+I ) 
         TMP = D( I ) / DMINUS 
         IF(DMINUS.LT.ZERO) NEG2 = NEG2 + 1 
         WORK( INDUMN+I ) = L( I )*TMP 
         WORK( INDP+I-1 ) = WORK( INDP+I )*TMP - LAMBDA 
   80 END DO 
      TMP = WORK( INDP+R1-1 ) 
      SAWNAN2 = SISNAN( TMP ) 
                                                                        
      IF( SAWNAN2 ) THEN 
!        Runs a slower version of the above loop if a NaN is detected   
         NEG2 = 0 
         DO 100 I = BN-1, R1, -1 
            DMINUS = LLD( I ) + WORK( INDP+I ) 
            IF(ABS(DMINUS).LT.PIVMIN) DMINUS = -PIVMIN 
            TMP = D( I ) / DMINUS 
            IF(DMINUS.LT.ZERO) NEG2 = NEG2 + 1 
            WORK( INDUMN+I ) = L( I )*TMP 
            WORK( INDP+I-1 ) = WORK( INDP+I )*TMP - LAMBDA 
            IF( TMP.EQ.ZERO )                                           &
     &          WORK( INDP+I-1 ) = D( I ) - LAMBDA                      
  100    CONTINUE 
      END IF 
!                                                                       
!     Find the index (from R1 to R2) of the largest (in magnitude)      
!     diagonal element of the inverse                                   
!                                                                       
      MINGMA = WORK( INDS+R1-1 ) + WORK( INDP+R1-1 ) 
      IF( MINGMA.LT.ZERO ) NEG1 = NEG1 + 1 
      IF( WANTNC ) THEN 
         NEGCNT = NEG1 + NEG2 
      ELSE 
         NEGCNT = -1 
      ENDIF 
      IF( ABS(MINGMA).EQ.ZERO )                                         &
     &   MINGMA = EPS*WORK( INDS+R1-1 )                                 
      R = R1 
      DO 110 I = R1, R2 - 1 
         TMP = WORK( INDS+I ) + WORK( INDP+I ) 
         IF( TMP.EQ.ZERO )                                              &
     &      TMP = EPS*WORK( INDS+I )                                    
         IF( ABS( TMP ).LE.ABS( MINGMA ) ) THEN 
            MINGMA = TMP 
            R = I + 1 
         END IF 
  110 END DO 
!                                                                       
!     Compute the FP vector: solve N^T v = e_r                          
!                                                                       
      ISUPPZ( 1 ) = B1 
      ISUPPZ( 2 ) = BN 
      Z( R ) = ONE 
      ZTZ = ONE 
!                                                                       
!     Compute the FP vector upwards from R                              
!                                                                       
      IF( .NOT.SAWNAN1 .AND. .NOT.SAWNAN2 ) THEN 
         DO 210 I = R-1, B1, -1 
            Z( I ) = -( WORK( INDLPL+I )*Z( I+1 ) ) 
            IF( (ABS(Z(I))+ABS(Z(I+1)))* ABS(LD(I)).LT.GAPTOL )         &
     &           THEN                                                   
               Z( I ) = ZERO 
               ISUPPZ( 1 ) = I + 1 
               GOTO 220 
            ENDIF 
            ZTZ = ZTZ + Z( I )*Z( I ) 
  210    CONTINUE 
  220    CONTINUE 
      ELSE 
!        Run slower loop if NaN occurred.                               
         DO 230 I = R - 1, B1, -1 
            IF( Z( I+1 ).EQ.ZERO ) THEN 
               Z( I ) = -( LD( I+1 ) / LD( I ) )*Z( I+2 ) 
            ELSE 
               Z( I ) = -( WORK( INDLPL+I )*Z( I+1 ) ) 
            END IF 
            IF( (ABS(Z(I))+ABS(Z(I+1)))* ABS(LD(I)).LT.GAPTOL )         &
     &           THEN                                                   
               Z( I ) = ZERO 
               ISUPPZ( 1 ) = I + 1 
               GO TO 240 
            END IF 
            ZTZ = ZTZ + Z( I )*Z( I ) 
  230    CONTINUE 
  240    CONTINUE 
      ENDIF 
                                                                        
!     Compute the FP vector downwards from R in blocks of size BLKSIZ   
      IF( .NOT.SAWNAN1 .AND. .NOT.SAWNAN2 ) THEN 
         DO 250 I = R, BN-1 
            Z( I+1 ) = -( WORK( INDUMN+I )*Z( I ) ) 
            IF( (ABS(Z(I))+ABS(Z(I+1)))* ABS(LD(I)).LT.GAPTOL )         &
     &         THEN                                                     
               Z( I+1 ) = ZERO 
               ISUPPZ( 2 ) = I 
               GO TO 260 
            END IF 
            ZTZ = ZTZ + Z( I+1 )*Z( I+1 ) 
  250    CONTINUE 
  260    CONTINUE 
      ELSE 
!        Run slower loop if NaN occurred.                               
         DO 270 I = R, BN - 1 
            IF( Z( I ).EQ.ZERO ) THEN 
               Z( I+1 ) = -( LD( I-1 ) / LD( I ) )*Z( I-1 ) 
            ELSE 
               Z( I+1 ) = -( WORK( INDUMN+I )*Z( I ) ) 
            END IF 
            IF( (ABS(Z(I))+ABS(Z(I+1)))* ABS(LD(I)).LT.GAPTOL )         &
     &           THEN                                                   
               Z( I+1 ) = ZERO 
               ISUPPZ( 2 ) = I 
               GO TO 280 
            END IF 
            ZTZ = ZTZ + Z( I+1 )*Z( I+1 ) 
  270    CONTINUE 
  280    CONTINUE 
      END IF 
!                                                                       
!     Compute quantities for convergence test                           
!                                                                       
      TMP = ONE / ZTZ 
      NRMINV = SQRT( TMP ) 
      RESID = ABS( MINGMA )*NRMINV 
      RQCORR = MINGMA*TMP 
!                                                                       
!                                                                       
      RETURN 
!                                                                       
!     End of SLAR1V                                                     
!                                                                       
      END                                           
!> \brief \b SLARF applies an elementary reflector to a general rectangu
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLARF + dependencies                                        
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SLARF( SIDE, M, N, V, INCV, TAU, C, LDC, WORK )      
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          SIDE                                         
!       INTEGER            INCV, LDC, M, N                              
!       REAL               TAU                                          
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL               C( LDC, * ), V( * ), WORK( * )               
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SLARF applies a real elementary reflector H to a real m by n matrix  
!> C, from either the left or the right. H is represented in the form   
!>                                                                      
!>       H = I - tau * v * v**T                                         
!>                                                                      
!> where tau is a real scalar and v is a real vector.                   
!>                                                                      
!> If tau = 0, then H is taken to be the unit matrix.                   
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] SIDE                                                      
!> \verbatim                                                            
!>          SIDE is CHARACTER*1                                         
!>          = 'L': form  H * C                                          
!>          = 'R': form  C * H                                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The number of rows of the matrix C.                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The number of columns of the matrix C.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] V                                                         
!> \verbatim                                                            
!>          V is REAL array, dimension                                  
!>                     (1 + (M-1)*abs(INCV)) if SIDE = 'L'              
!>                  or (1 + (N-1)*abs(INCV)) if SIDE = 'R'              
!>          The vector v in the representation of H. V is not used if   
!>          TAU = 0.                                                    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCV                                                      
!> \verbatim                                                            
!>          INCV is INTEGER                                             
!>          The increment between elements of v. INCV <> 0.             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TAU                                                       
!> \verbatim                                                            
!>          TAU is REAL                                                 
!>          The value tau in the representation of H.                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] C                                                     
!> \verbatim                                                            
!>          C is REAL array, dimension (LDC,N)                          
!>          On entry, the m by n matrix C.                              
!>          On exit, C is overwritten by the matrix H * C if SIDE = 'L',
!>          or C * H if SIDE = 'R'.                                     
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDC                                                       
!> \verbatim                                                            
!>          LDC is INTEGER                                              
!>          The leading dimension of the array C. LDC >= max(1,M).      
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is REAL array, dimension                               
!>                         (N) if SIDE = 'L'                            
!>                      or (M) if SIDE = 'R'                            
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup realOTHERauxiliary                                          
!                                                                       
!  =====================================================================
      SUBROUTINE SLARF( SIDE, M, N, V, INCV, TAU, C, LDC, WORK ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          SIDE 
      INTEGER            INCV, LDC, M, N 
      REAL               TAU 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               C( LDC, * ), V( * ), WORK( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ONE, ZERO 
      PARAMETER          ( ONE = 1.0E+0, ZERO = 0.0E+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            APPLYLEFT 
      INTEGER            I, LASTV, LASTC 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           SGEMV, SGER 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      INTEGER            ILASLR, ILASLC 
      EXTERNAL           LSAME, ILASLR, ILASLC 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      APPLYLEFT = LSAME( SIDE, 'L' ) 
      LASTV = 0 
      LASTC = 0 
      IF( TAU.NE.ZERO ) THEN 
!     Set up variables for scanning V.  LASTV begins pointing to the end
!     of V.                                                             
         IF( APPLYLEFT ) THEN 
            LASTV = M 
         ELSE 
            LASTV = N 
         END IF 
         IF( INCV.GT.0 ) THEN 
            I = 1 + (LASTV-1) * INCV 
         ELSE 
            I = 1 
         END IF 
!     Look for the last non-zero row in V.                              
         DO WHILE( LASTV.GT.0 .AND. V( I ).EQ.ZERO ) 
            LASTV = LASTV - 1 
            I = I - INCV 
         END DO 
         IF( APPLYLEFT ) THEN 
!     Scan for the last non-zero column in C(1:lastv,:).                
            LASTC = ILASLC(LASTV, N, C, LDC) 
         ELSE 
!     Scan for the last non-zero row in C(:,1:lastv).                   
            LASTC = ILASLR(M, LASTV, C, LDC) 
         END IF 
      END IF 
!     Note that lastc.eq.0 renders the BLAS operations null; no special 
!     case is needed at this level.                                     
      IF( APPLYLEFT ) THEN 
!                                                                       
!        Form  H * C                                                    
!                                                                       
         IF( LASTV.GT.0 ) THEN 
!                                                                       
!           w(1:lastc,1) := C(1:lastv,1:lastc)**T * v(1:lastv,1)        
!                                                                       
            CALL SGEMV( 'Transpose', LASTV, LASTC, ONE, C, LDC, V, INCV,&
     &           ZERO, WORK, 1 )                                        
!                                                                       
!           C(1:lastv,1:lastc) := C(...) - v(1:lastv,1) * w(1:lastc,1)**
!                                                                       
            CALL SGER( LASTV, LASTC, -TAU, V, INCV, WORK, 1, C, LDC ) 
         END IF 
      ELSE 
!                                                                       
!        Form  C * H                                                    
!                                                                       
         IF( LASTV.GT.0 ) THEN 
!                                                                       
!           w(1:lastc,1) := C(1:lastc,1:lastv) * v(1:lastv,1)           
!                                                                       
            CALL SGEMV( 'No transpose', LASTC, LASTV, ONE, C, LDC,      &
     &           V, INCV, ZERO, WORK, 1 )                               
!                                                                       
!           C(1:lastc,1:lastv) := C(...) - w(1:lastc,1) * v(1:lastv,1)**
!                                                                       
            CALL SGER( LASTC, LASTV, -TAU, WORK, 1, V, INCV, C, LDC ) 
         END IF 
      END IF 
      RETURN 
!                                                                       
!     End of SLARF                                                      
!                                                                       
      END                                           
!> \brief \b SLARFB applies a block reflector or its transpose to a gene
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLARFB + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SLARFB( SIDE, TRANS, DIRECT, STOREV, M, N, K, V, LDV,
!                          T, LDT, C, LDC, WORK, LDWORK )               
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          DIRECT, SIDE, STOREV, TRANS                  
!       INTEGER            K, LDC, LDT, LDV, LDWORK, M, N               
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL               C( LDC, * ), T( LDT, * ), V( LDV, * ),       
!      $                   WORK( LDWORK, * )                            
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SLARFB applies a real block reflector H or its transpose H**T to a   
!> real m by n matrix C, from either the left or the right.             
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] SIDE                                                      
!> \verbatim                                                            
!>          SIDE is CHARACTER*1                                         
!>          = 'L': apply H or H**T from the Left                        
!>          = 'R': apply H or H**T from the Right                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TRANS                                                     
!> \verbatim                                                            
!>          TRANS is CHARACTER*1                                        
!>          = 'N': apply H (No transpose)                               
!>          = 'T': apply H**T (Transpose)                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] DIRECT                                                    
!> \verbatim                                                            
!>          DIRECT is CHARACTER*1                                       
!>          Indicates how H is formed from a product of elementary      
!>          reflectors                                                  
!>          = 'F': H = H(1) H(2) . . . H(k) (Forward)                   
!>          = 'B': H = H(k) . . . H(2) H(1) (Backward)                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] STOREV                                                    
!> \verbatim                                                            
!>          STOREV is CHARACTER*1                                       
!>          Indicates how the vectors which define the elementary       
!>          reflectors are stored:                                      
!>          = 'C': Columnwise                                           
!>          = 'R': Rowwise                                              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The number of rows of the matrix C.                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The number of columns of the matrix C.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] K                                                         
!> \verbatim                                                            
!>          K is INTEGER                                                
!>          The order of the matrix T (= the number of elementary       
!>          reflectors whose product defines the block reflector).      
!>          If SIDE = 'L', M >= K >= 0;                                 
!>          if SIDE = 'R', N >= K >= 0.                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] V                                                         
!> \verbatim                                                            
!>          V is REAL array, dimension                                  
!>                                (LDV,K) if STOREV = 'C'               
!>                                (LDV,M) if STOREV = 'R' and SIDE = 'L'
!>                                (LDV,N) if STOREV = 'R' and SIDE = 'R'
!>          The matrix V. See Further Details.                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDV                                                       
!> \verbatim                                                            
!>          LDV is INTEGER                                              
!>          The leading dimension of the array V.                       
!>          If STOREV = 'C' and SIDE = 'L', LDV >= max(1,M);            
!>          if STOREV = 'C' and SIDE = 'R', LDV >= max(1,N);            
!>          if STOREV = 'R', LDV >= K.                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] T                                                         
!> \verbatim                                                            
!>          T is REAL array, dimension (LDT,K)                          
!>          The triangular k by k matrix T in the representation of the 
!>          block reflector.                                            
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDT                                                       
!> \verbatim                                                            
!>          LDT is INTEGER                                              
!>          The leading dimension of the array T. LDT >= K.             
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] C                                                     
!> \verbatim                                                            
!>          C is REAL array, dimension (LDC,N)                          
!>          On entry, the m by n matrix C.                              
!>          On exit, C is overwritten by H*C or H**T*C or C*H or C*H**T.
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDC                                                       
!> \verbatim                                                            
!>          LDC is INTEGER                                              
!>          The leading dimension of the array C. LDC >= max(1,M).      
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is REAL array, dimension (LDWORK,K)                    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDWORK                                                    
!> \verbatim                                                            
!>          LDWORK is INTEGER                                           
!>          The leading dimension of the array WORK.                    
!>          If SIDE = 'L', LDWORK >= max(1,N);                          
!>          if SIDE = 'R', LDWORK >= max(1,M).                          
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2013                                                      
!                                                                       
!> \ingroup realOTHERauxiliary                                          
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  The shape of the matrix V and the storage of the vectors which defin
!>  the H(i) is best illustrated by the following example with n = 5 and
!>  k = 3. The elements equal to 1 are not stored; the corresponding    
!>  array elements are modified but restored on exit. The rest of the   
!>  array is not used.                                                  
!>                                                                      
!>  DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R'
!>                                                                      
!>               V = (  1       )                 V = (  1 v1 v1 v1 v1 )
!>                   ( v1  1    )                     (     1 v2 v2 v2 )
!>                   ( v1 v2  1 )                     (        1 v3 v3 )
!>                   ( v1 v2 v3 )                                       
!>                   ( v1 v2 v3 )                                       
!>                                                                      
!>  DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R'
!>                                                                      
!>               V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
!>                   ( v1 v2 v3 )                     ( v2 v2 v2  1    )
!>                   (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
!>                   (     1 v3 )                                       
!>                   (        1 )                                       
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE SLARFB( SIDE, TRANS, DIRECT, STOREV, M, N, K, V, LDV,  &
     &                   T, LDT, C, LDC, WORK, LDWORK )                 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2013                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          DIRECT, SIDE, STOREV, TRANS 
      INTEGER            K, LDC, LDT, LDV, LDWORK, M, N 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               C( LDC, * ), T( LDT, * ), V( LDV, * ),         &
     &                   WORK( LDWORK, * )                              
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ONE 
      PARAMETER          ( ONE = 1.0E+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      CHARACTER          TRANST 
      INTEGER            I, J 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      EXTERNAL           LSAME 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           SCOPY, SGEMM, STRMM 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( M.LE.0 .OR. N.LE.0 )                                          &
     &   RETURN                                                         
!                                                                       
      IF( LSAME( TRANS, 'N' ) ) THEN 
         TRANST = 'T' 
      ELSE 
         TRANST = 'N' 
      END IF 
!                                                                       
      IF( LSAME( STOREV, 'C' ) ) THEN 
!                                                                       
         IF( LSAME( DIRECT, 'F' ) ) THEN 
!                                                                       
!           Let  V =  ( V1 )    (first K rows)                          
!                     ( V2 )                                            
!           where  V1  is unit lower triangular.                        
!                                                                       
            IF( LSAME( SIDE, 'L' ) ) THEN 
!                                                                       
!              Form  H * C  or  H**T * C  where  C = ( C1 )             
!                                                    ( C2 )             
!                                                                       
!              W := C**T * V  =  (C1**T * V1 + C2**T * V2)  (stored in W
!                                                                       
!              W := C1**T                                               
!                                                                       
               DO 10 J = 1, K 
                  CALL SCOPY( N, C( J, 1 ), LDC, WORK( 1, J ), 1 ) 
   10          CONTINUE 
!                                                                       
!              W := W * V1                                              
!                                                                       
               CALL STRMM( 'Right', 'Lower', 'No transpose', 'Unit', N, &
     &                     K, ONE, V, LDV, WORK, LDWORK )               
               IF( M.GT.K ) THEN 
!                                                                       
!                 W := W + C2**T * V2                                   
!                                                                       
                  CALL SGEMM( 'Transpose', 'No transpose', N, K, M-K,   &
     &                        ONE, C( K+1, 1 ), LDC, V( K+1, 1 ), LDV,  &
     &                        ONE, WORK, LDWORK )                       
               END IF 
!                                                                       
!              W := W * T**T  or  W * T                                 
!                                                                       
               CALL STRMM( 'Right', 'Upper', TRANST, 'Non-unit', N, K,  &
     &                     ONE, T, LDT, WORK, LDWORK )                  
!                                                                       
!              C := C - V * W**T                                        
!                                                                       
               IF( M.GT.K ) THEN 
!                                                                       
!                 C2 := C2 - V2 * W**T                                  
!                                                                       
                  CALL SGEMM( 'No transpose', 'Transpose', M-K, N, K,   &
     &                        -ONE, V( K+1, 1 ), LDV, WORK, LDWORK, ONE,&
     &                        C( K+1, 1 ), LDC )                        
               END IF 
!                                                                       
!              W := W * V1**T                                           
!                                                                       
               CALL STRMM( 'Right', 'Lower', 'Transpose', 'Unit', N, K, &
     &                     ONE, V, LDV, WORK, LDWORK )                  
!                                                                       
!              C1 := C1 - W**T                                          
!                                                                       
               DO 30 J = 1, K 
                  DO 20 I = 1, N 
                     C( J, I ) = C( J, I ) - WORK( I, J ) 
   20             CONTINUE 
   30          CONTINUE 
!                                                                       
            ELSE IF( LSAME( SIDE, 'R' ) ) THEN 
!                                                                       
!              Form  C * H  or  C * H**T  where  C = ( C1  C2 )         
!                                                                       
!              W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK)         
!                                                                       
!              W := C1                                                  
!                                                                       
               DO 40 J = 1, K 
                  CALL SCOPY( M, C( 1, J ), 1, WORK( 1, J ), 1 ) 
   40          CONTINUE 
!                                                                       
!              W := W * V1                                              
!                                                                       
               CALL STRMM( 'Right', 'Lower', 'No transpose', 'Unit', M, &
     &                     K, ONE, V, LDV, WORK, LDWORK )               
               IF( N.GT.K ) THEN 
!                                                                       
!                 W := W + C2 * V2                                      
!                                                                       
                  CALL SGEMM( 'No transpose', 'No transpose', M, K, N-K,&
     &                        ONE, C( 1, K+1 ), LDC, V( K+1, 1 ), LDV,  &
     &                        ONE, WORK, LDWORK )                       
               END IF 
!                                                                       
!              W := W * T  or  W * T**T                                 
!                                                                       
               CALL STRMM( 'Right', 'Upper', TRANS, 'Non-unit', M, K,   &
     &                     ONE, T, LDT, WORK, LDWORK )                  
!                                                                       
!              C := C - W * V**T                                        
!                                                                       
               IF( N.GT.K ) THEN 
!                                                                       
!                 C2 := C2 - W * V2**T                                  
!                                                                       
                  CALL SGEMM( 'No transpose', 'Transpose', M, N-K, K,   &
     &                        -ONE, WORK, LDWORK, V( K+1, 1 ), LDV, ONE,&
     &                        C( 1, K+1 ), LDC )                        
               END IF 
!                                                                       
!              W := W * V1**T                                           
!                                                                       
               CALL STRMM( 'Right', 'Lower', 'Transpose', 'Unit', M, K, &
     &                     ONE, V, LDV, WORK, LDWORK )                  
!                                                                       
!              C1 := C1 - W                                             
!                                                                       
               DO 60 J = 1, K 
                  DO 50 I = 1, M 
                     C( I, J ) = C( I, J ) - WORK( I, J ) 
   50             CONTINUE 
   60          CONTINUE 
            END IF 
!                                                                       
         ELSE 
!                                                                       
!           Let  V =  ( V1 )                                            
!                     ( V2 )    (last K rows)                           
!           where  V2  is unit upper triangular.                        
!                                                                       
            IF( LSAME( SIDE, 'L' ) ) THEN 
!                                                                       
!              Form  H * C  or  H**T * C  where  C = ( C1 )             
!                                                    ( C2 )             
!                                                                       
!              W := C**T * V  =  (C1**T * V1 + C2**T * V2)  (stored in W
!                                                                       
!              W := C2**T                                               
!                                                                       
               DO 70 J = 1, K 
                  CALL SCOPY( N, C( M-K+J, 1 ), LDC, WORK( 1, J ), 1 ) 
   70          CONTINUE 
!                                                                       
!              W := W * V2                                              
!                                                                       
               CALL STRMM( 'Right', 'Upper', 'No transpose', 'Unit', N, &
     &                     K, ONE, V( M-K+1, 1 ), LDV, WORK, LDWORK )   
               IF( M.GT.K ) THEN 
!                                                                       
!                 W := W + C1**T * V1                                   
!                                                                       
                  CALL SGEMM( 'Transpose', 'No transpose', N, K, M-K,   &
     &                        ONE, C, LDC, V, LDV, ONE, WORK, LDWORK )  
               END IF 
!                                                                       
!              W := W * T**T  or  W * T                                 
!                                                                       
               CALL STRMM( 'Right', 'Lower', TRANST, 'Non-unit', N, K,  &
     &                     ONE, T, LDT, WORK, LDWORK )                  
!                                                                       
!              C := C - V * W**T                                        
!                                                                       
               IF( M.GT.K ) THEN 
!                                                                       
!                 C1 := C1 - V1 * W**T                                  
!                                                                       
                  CALL SGEMM( 'No transpose', 'Transpose', M-K, N, K,   &
     &                        -ONE, V, LDV, WORK, LDWORK, ONE, C, LDC ) 
               END IF 
!                                                                       
!              W := W * V2**T                                           
!                                                                       
               CALL STRMM( 'Right', 'Upper', 'Transpose', 'Unit', N, K, &
     &                     ONE, V( M-K+1, 1 ), LDV, WORK, LDWORK )      
!                                                                       
!              C2 := C2 - W**T                                          
!                                                                       
               DO 90 J = 1, K 
                  DO 80 I = 1, N 
                     C( M-K+J, I ) = C( M-K+J, I ) - WORK( I, J ) 
   80             CONTINUE 
   90          CONTINUE 
!                                                                       
            ELSE IF( LSAME( SIDE, 'R' ) ) THEN 
!                                                                       
!              Form  C * H  or  C * H'  where  C = ( C1  C2 )           
!                                                                       
!              W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK)         
!                                                                       
!              W := C2                                                  
!                                                                       
               DO 100 J = 1, K 
                  CALL SCOPY( M, C( 1, N-K+J ), 1, WORK( 1, J ), 1 ) 
  100          CONTINUE 
!                                                                       
!              W := W * V2                                              
!                                                                       
               CALL STRMM( 'Right', 'Upper', 'No transpose', 'Unit', M, &
     &                     K, ONE, V( N-K+1, 1 ), LDV, WORK, LDWORK )   
               IF( N.GT.K ) THEN 
!                                                                       
!                 W := W + C1 * V1                                      
!                                                                       
                  CALL SGEMM( 'No transpose', 'No transpose', M, K, N-K,&
     &                        ONE, C, LDC, V, LDV, ONE, WORK, LDWORK )  
               END IF 
!                                                                       
!              W := W * T  or  W * T**T                                 
!                                                                       
               CALL STRMM( 'Right', 'Lower', TRANS, 'Non-unit', M, K,   &
     &                     ONE, T, LDT, WORK, LDWORK )                  
!                                                                       
!              C := C - W * V**T                                        
!                                                                       
               IF( N.GT.K ) THEN 
!                                                                       
!                 C1 := C1 - W * V1**T                                  
!                                                                       
                  CALL SGEMM( 'No transpose', 'Transpose', M, N-K, K,   &
     &                        -ONE, WORK, LDWORK, V, LDV, ONE, C, LDC ) 
               END IF 
!                                                                       
!              W := W * V2**T                                           
!                                                                       
               CALL STRMM( 'Right', 'Upper', 'Transpose', 'Unit', M, K, &
     &                     ONE, V( N-K+1, 1 ), LDV, WORK, LDWORK )      
!                                                                       
!              C2 := C2 - W                                             
!                                                                       
               DO 120 J = 1, K 
                  DO 110 I = 1, M 
                     C( I, N-K+J ) = C( I, N-K+J ) - WORK( I, J ) 
  110             CONTINUE 
  120          CONTINUE 
            END IF 
         END IF 
!                                                                       
      ELSE IF( LSAME( STOREV, 'R' ) ) THEN 
!                                                                       
         IF( LSAME( DIRECT, 'F' ) ) THEN 
!                                                                       
!           Let  V =  ( V1  V2 )    (V1: first K columns)               
!           where  V1  is unit upper triangular.                        
!                                                                       
            IF( LSAME( SIDE, 'L' ) ) THEN 
!                                                                       
!              Form  H * C  or  H**T * C  where  C = ( C1 )             
!                                                    ( C2 )             
!                                                                       
!              W := C**T * V**T  =  (C1**T * V1**T + C2**T * V2**T) (sto
!                                                                       
!              W := C1**T                                               
!                                                                       
               DO 130 J = 1, K 
                  CALL SCOPY( N, C( J, 1 ), LDC, WORK( 1, J ), 1 ) 
  130          CONTINUE 
!                                                                       
!              W := W * V1**T                                           
!                                                                       
               CALL STRMM( 'Right', 'Upper', 'Transpose', 'Unit', N, K, &
     &                     ONE, V, LDV, WORK, LDWORK )                  
               IF( M.GT.K ) THEN 
!                                                                       
!                 W := W + C2**T * V2**T                                
!                                                                       
                  CALL SGEMM( 'Transpose', 'Transpose', N, K, M-K, ONE, &
     &                        C( K+1, 1 ), LDC, V( 1, K+1 ), LDV, ONE,  &
     &                        WORK, LDWORK )                            
               END IF 
!                                                                       
!              W := W * T**T  or  W * T                                 
!                                                                       
               CALL STRMM( 'Right', 'Upper', TRANST, 'Non-unit', N, K,  &
     &                     ONE, T, LDT, WORK, LDWORK )                  
!                                                                       
!              C := C - V**T * W**T                                     
!                                                                       
               IF( M.GT.K ) THEN 
!                                                                       
!                 C2 := C2 - V2**T * W**T                               
!                                                                       
                  CALL SGEMM( 'Transpose', 'Transpose', M-K, N, K, -ONE,&
     &                        V( 1, K+1 ), LDV, WORK, LDWORK, ONE,      &
     &                        C( K+1, 1 ), LDC )                        
               END IF 
!                                                                       
!              W := W * V1                                              
!                                                                       
               CALL STRMM( 'Right', 'Upper', 'No transpose', 'Unit', N, &
     &                     K, ONE, V, LDV, WORK, LDWORK )               
!                                                                       
!              C1 := C1 - W**T                                          
!                                                                       
               DO 150 J = 1, K 
                  DO 140 I = 1, N 
                     C( J, I ) = C( J, I ) - WORK( I, J ) 
  140             CONTINUE 
  150          CONTINUE 
!                                                                       
            ELSE IF( LSAME( SIDE, 'R' ) ) THEN 
!                                                                       
!              Form  C * H  or  C * H**T  where  C = ( C1  C2 )         
!                                                                       
!              W := C * V**T  =  (C1*V1**T + C2*V2**T)  (stored in WORK)
!                                                                       
!              W := C1                                                  
!                                                                       
               DO 160 J = 1, K 
                  CALL SCOPY( M, C( 1, J ), 1, WORK( 1, J ), 1 ) 
  160          CONTINUE 
!                                                                       
!              W := W * V1**T                                           
!                                                                       
               CALL STRMM( 'Right', 'Upper', 'Transpose', 'Unit', M, K, &
     &                     ONE, V, LDV, WORK, LDWORK )                  
               IF( N.GT.K ) THEN 
!                                                                       
!                 W := W + C2 * V2**T                                   
!                                                                       
                  CALL SGEMM( 'No transpose', 'Transpose', M, K, N-K,   &
     &                        ONE, C( 1, K+1 ), LDC, V( 1, K+1 ), LDV,  &
     &                        ONE, WORK, LDWORK )                       
               END IF 
!                                                                       
!              W := W * T  or  W * T**T                                 
!                                                                       
               CALL STRMM( 'Right', 'Upper', TRANS, 'Non-unit', M, K,   &
     &                     ONE, T, LDT, WORK, LDWORK )                  
!                                                                       
!              C := C - W * V                                           
!                                                                       
               IF( N.GT.K ) THEN 
!                                                                       
!                 C2 := C2 - W * V2                                     
!                                                                       
                  CALL SGEMM( 'No transpose', 'No transpose', M, N-K, K,&
     &                        -ONE, WORK, LDWORK, V( 1, K+1 ), LDV, ONE,&
     &                        C( 1, K+1 ), LDC )                        
               END IF 
!                                                                       
!              W := W * V1                                              
!                                                                       
               CALL STRMM( 'Right', 'Upper', 'No transpose', 'Unit', M, &
     &                     K, ONE, V, LDV, WORK, LDWORK )               
!                                                                       
!              C1 := C1 - W                                             
!                                                                       
               DO 180 J = 1, K 
                  DO 170 I = 1, M 
                     C( I, J ) = C( I, J ) - WORK( I, J ) 
  170             CONTINUE 
  180          CONTINUE 
!                                                                       
            END IF 
!                                                                       
         ELSE 
!                                                                       
!           Let  V =  ( V1  V2 )    (V2: last K columns)                
!           where  V2  is unit lower triangular.                        
!                                                                       
            IF( LSAME( SIDE, 'L' ) ) THEN 
!                                                                       
!              Form  H * C  or  H**T * C  where  C = ( C1 )             
!                                                    ( C2 )             
!                                                                       
!              W := C**T * V**T  =  (C1**T * V1**T + C2**T * V2**T) (sto
!                                                                       
!              W := C2**T                                               
!                                                                       
               DO 190 J = 1, K 
                  CALL SCOPY( N, C( M-K+J, 1 ), LDC, WORK( 1, J ), 1 ) 
  190          CONTINUE 
!                                                                       
!              W := W * V2**T                                           
!                                                                       
               CALL STRMM( 'Right', 'Lower', 'Transpose', 'Unit', N, K, &
     &                     ONE, V( 1, M-K+1 ), LDV, WORK, LDWORK )      
               IF( M.GT.K ) THEN 
!                                                                       
!                 W := W + C1**T * V1**T                                
!                                                                       
                  CALL SGEMM( 'Transpose', 'Transpose', N, K, M-K, ONE, &
     &                        C, LDC, V, LDV, ONE, WORK, LDWORK )       
               END IF 
!                                                                       
!              W := W * T**T  or  W * T                                 
!                                                                       
               CALL STRMM( 'Right', 'Lower', TRANST, 'Non-unit', N, K,  &
     &                     ONE, T, LDT, WORK, LDWORK )                  
!                                                                       
!              C := C - V**T * W**T                                     
!                                                                       
               IF( M.GT.K ) THEN 
!                                                                       
!                 C1 := C1 - V1**T * W**T                               
!                                                                       
                  CALL SGEMM( 'Transpose', 'Transpose', M-K, N, K, -ONE,&
     &                        V, LDV, WORK, LDWORK, ONE, C, LDC )       
               END IF 
!                                                                       
!              W := W * V2                                              
!                                                                       
               CALL STRMM( 'Right', 'Lower', 'No transpose', 'Unit', N, &
     &                     K, ONE, V( 1, M-K+1 ), LDV, WORK, LDWORK )   
!                                                                       
!              C2 := C2 - W**T                                          
!                                                                       
               DO 210 J = 1, K 
                  DO 200 I = 1, N 
                     C( M-K+J, I ) = C( M-K+J, I ) - WORK( I, J ) 
  200             CONTINUE 
  210          CONTINUE 
!                                                                       
            ELSE IF( LSAME( SIDE, 'R' ) ) THEN 
!                                                                       
!              Form  C * H  or  C * H**T  where  C = ( C1  C2 )         
!                                                                       
!              W := C * V**T  =  (C1*V1**T + C2*V2**T)  (stored in WORK)
!                                                                       
!              W := C2                                                  
!                                                                       
               DO 220 J = 1, K 
                  CALL SCOPY( M, C( 1, N-K+J ), 1, WORK( 1, J ), 1 ) 
  220          CONTINUE 
!                                                                       
!              W := W * V2**T                                           
!                                                                       
               CALL STRMM( 'Right', 'Lower', 'Transpose', 'Unit', M, K, &
     &                     ONE, V( 1, N-K+1 ), LDV, WORK, LDWORK )      
               IF( N.GT.K ) THEN 
!                                                                       
!                 W := W + C1 * V1**T                                   
!                                                                       
                  CALL SGEMM( 'No transpose', 'Transpose', M, K, N-K,   &
     &                        ONE, C, LDC, V, LDV, ONE, WORK, LDWORK )  
               END IF 
!                                                                       
!              W := W * T  or  W * T**T                                 
!                                                                       
               CALL STRMM( 'Right', 'Lower', TRANS, 'Non-unit', M, K,   &
     &                     ONE, T, LDT, WORK, LDWORK )                  
!                                                                       
!              C := C - W * V                                           
!                                                                       
               IF( N.GT.K ) THEN 
!                                                                       
!                 C1 := C1 - W * V1                                     
!                                                                       
                  CALL SGEMM( 'No transpose', 'No transpose', M, N-K, K,&
     &                        -ONE, WORK, LDWORK, V, LDV, ONE, C, LDC ) 
               END IF 
!                                                                       
!              W := W * V2                                              
!                                                                       
               CALL STRMM( 'Right', 'Lower', 'No transpose', 'Unit', M, &
     &                     K, ONE, V( 1, N-K+1 ), LDV, WORK, LDWORK )   
!                                                                       
!              C1 := C1 - W                                             
!                                                                       
               DO 240 J = 1, K 
                  DO 230 I = 1, M 
                     C( I, N-K+J ) = C( I, N-K+J ) - WORK( I, J ) 
  230             CONTINUE 
  240          CONTINUE 
!                                                                       
            END IF 
!                                                                       
         END IF 
      END IF 
!                                                                       
      RETURN 
!                                                                       
!     End of SLARFB                                                     
!                                                                       
      END                                           
!> \brief \b SLARFG generates an elementary reflector (Householder matri
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLARFG + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SLARFG( N, ALPHA, X, INCX, TAU )                     
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            INCX, N                                      
!       REAL               ALPHA, TAU                                   
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL               X( * )                                       
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SLARFG generates a real elementary reflector H of order n, such      
!> that                                                                 
!>                                                                      
!>       H * ( alpha ) = ( beta ),   H**T * H = I.                      
!>           (   x   )   (   0  )                                       
!>                                                                      
!> where alpha and beta are scalars, and x is an (n-1)-element real     
!> vector. H is represented in the form                                 
!>                                                                      
!>       H = I - tau * ( 1 ) * ( 1 v**T ) ,                             
!>                     ( v )                                            
!>                                                                      
!> where tau is a real scalar and v is a real (n-1)-element             
!> vector.                                                              
!>                                                                      
!> If the elements of x are all zero, then tau = 0 and H is taken to be 
!> the unit matrix.                                                     
!>                                                                      
!> Otherwise  1 <= tau <= 2.                                            
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the elementary reflector.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] ALPHA                                                 
!> \verbatim                                                            
!>          ALPHA is REAL                                               
!>          On entry, the value alpha.                                  
!>          On exit, it is overwritten with the value beta.             
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] X                                                     
!> \verbatim                                                            
!>          X is REAL array, dimension                                  
!>                         (1+(N-2)*abs(INCX))                          
!>          On entry, the vector x.                                     
!>          On exit, it is overwritten with the vector v.               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCX                                                      
!> \verbatim                                                            
!>          INCX is INTEGER                                             
!>          The increment between elements of X. INCX > 0.              
!> \endverbatim                                                         
!>                                                                      
!> \param[out] TAU                                                      
!> \verbatim                                                            
!>          TAU is REAL                                                 
!>          The value tau.                                              
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date November 2017                                                  
!                                                                       
!> \ingroup realOTHERauxiliary                                          
!                                                                       
!  =====================================================================
      SUBROUTINE SLARFG( N, ALPHA, X, INCX, TAU ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.8.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     November 2017                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            INCX, N 
      REAL               ALPHA, TAU 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               X( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ONE, ZERO 
      PARAMETER          ( ONE = 1.0E+0, ZERO = 0.0E+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            J, KNT 
      REAL               BETA, RSAFMN, SAFMIN, XNORM 
!     ..                                                                
!     .. External Functions ..                                          
      REAL               SLAMCH, SLAPY2, SNRM2 
      EXTERNAL           SLAMCH, SLAPY2, SNRM2 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, SIGN 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           SSCAL 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      IF( N.LE.1 ) THEN 
         TAU = ZERO 
         RETURN 
      END IF 
!                                                                       
      XNORM = SNRM2( N-1, X, INCX ) 
!                                                                       
      IF( XNORM.EQ.ZERO ) THEN 
!                                                                       
!        H  =  I                                                        
!                                                                       
         TAU = ZERO 
      ELSE 
!                                                                       
!        general case                                                   
!                                                                       
         BETA = -SIGN( SLAPY2( ALPHA, XNORM ), ALPHA ) 
         SAFMIN = SLAMCH( 'S' ) / SLAMCH( 'E' ) 
         KNT = 0 
         IF( ABS( BETA ).LT.SAFMIN ) THEN 
!                                                                       
!           XNORM, BETA may be inaccurate; scale X and recompute them   
!                                                                       
            RSAFMN = ONE / SAFMIN 
   10       CONTINUE 
            KNT = KNT + 1 
            CALL SSCAL( N-1, RSAFMN, X, INCX ) 
            BETA = BETA*RSAFMN 
            ALPHA = ALPHA*RSAFMN 
            IF( (ABS( BETA ).LT.SAFMIN) .AND. (KNT .LT. 20) )           &
     &         GO TO 10                                                 
!                                                                       
!           New BETA is at most 1, at least SAFMIN                      
!                                                                       
            XNORM = SNRM2( N-1, X, INCX ) 
            BETA = -SIGN( SLAPY2( ALPHA, XNORM ), ALPHA ) 
         END IF 
         TAU = ( BETA-ALPHA ) / BETA 
         CALL SSCAL( N-1, ONE / ( ALPHA-BETA ), X, INCX ) 
!                                                                       
!        If ALPHA is subnormal, it may lose relative accuracy           
!                                                                       
         DO 20 J = 1, KNT 
            BETA = BETA*SAFMIN 
   20    CONTINUE 
         ALPHA = BETA 
      END IF 
!                                                                       
      RETURN 
!                                                                       
!     End of SLARFG                                                     
!                                                                       
      END                                           
!> \brief \b SLARFT forms the triangular factor T of a block reflector H
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLARFT + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SLARFT( DIRECT, STOREV, N, K, V, LDV, TAU, T, LDT )  
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          DIRECT, STOREV                               
!       INTEGER            K, LDT, LDV, N                               
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL               T( LDT, * ), TAU( * ), V( LDV, * )           
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SLARFT forms the triangular factor T of a real block reflector H     
!> of order n, which is defined as a product of k elementary reflectors.
!>                                                                      
!> If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular; 
!>                                                                      
!> If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular. 
!>                                                                      
!> If STOREV = 'C', the vector which defines the elementary reflector   
!> H(i) is stored in the i-th column of the array V, and                
!>                                                                      
!>    H  =  I - V * T * V**T                                            
!>                                                                      
!> If STOREV = 'R', the vector which defines the elementary reflector   
!> H(i) is stored in the i-th row of the array V, and                   
!>                                                                      
!>    H  =  I - V**T * T * V                                            
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] DIRECT                                                    
!> \verbatim                                                            
!>          DIRECT is CHARACTER*1                                       
!>          Specifies the order in which the elementary reflectors are  
!>          multiplied to form the block reflector:                     
!>          = 'F': H = H(1) H(2) . . . H(k) (Forward)                   
!>          = 'B': H = H(k) . . . H(2) H(1) (Backward)                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] STOREV                                                    
!> \verbatim                                                            
!>          STOREV is CHARACTER*1                                       
!>          Specifies how the vectors which define the elementary       
!>          reflectors are stored (see also Further Details):           
!>          = 'C': columnwise                                           
!>          = 'R': rowwise                                              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the block reflector H. N >= 0.                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] K                                                         
!> \verbatim                                                            
!>          K is INTEGER                                                
!>          The order of the triangular factor T (= the number of       
!>          elementary reflectors). K >= 1.                             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] V                                                         
!> \verbatim                                                            
!>          V is REAL array, dimension                                  
!>                               (LDV,K) if STOREV = 'C'                
!>                               (LDV,N) if STOREV = 'R'                
!>          The matrix V. See further details.                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDV                                                       
!> \verbatim                                                            
!>          LDV is INTEGER                                              
!>          The leading dimension of the array V.                       
!>          If STOREV = 'C', LDV >= max(1,N); if STOREV = 'R', LDV >= K.
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TAU                                                       
!> \verbatim                                                            
!>          TAU is REAL array, dimension (K)                            
!>          TAU(i) must contain the scalar factor of the elementary     
!>          reflector H(i).                                             
!> \endverbatim                                                         
!>                                                                      
!> \param[out] T                                                        
!> \verbatim                                                            
!>          T is REAL array, dimension (LDT,K)                          
!>          The k by k triangular factor T of the block reflector.      
!>          If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T i
!>          lower triangular. The rest of the array is not used.        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDT                                                       
!> \verbatim                                                            
!>          LDT is INTEGER                                              
!>          The leading dimension of the array T. LDT >= K.             
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup realOTHERauxiliary                                          
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  The shape of the matrix V and the storage of the vectors which defin
!>  the H(i) is best illustrated by the following example with n = 5 and
!>  k = 3. The elements equal to 1 are not stored.                      
!>                                                                      
!>  DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R'
!>                                                                      
!>               V = (  1       )                 V = (  1 v1 v1 v1 v1 )
!>                   ( v1  1    )                     (     1 v2 v2 v2 )
!>                   ( v1 v2  1 )                     (        1 v3 v3 )
!>                   ( v1 v2 v3 )                                       
!>                   ( v1 v2 v3 )                                       
!>                                                                      
!>  DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R'
!>                                                                      
!>               V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
!>                   ( v1 v2 v3 )                     ( v2 v2 v2  1    )
!>                   (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
!>                   (     1 v3 )                                       
!>                   (        1 )                                       
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE SLARFT( DIRECT, STOREV, N, K, V, LDV, TAU, T, LDT ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          DIRECT, STOREV 
      INTEGER            K, LDT, LDV, N 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               T( LDT, * ), TAU( * ), V( LDV, * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ONE, ZERO 
      PARAMETER          ( ONE = 1.0E+0, ZERO = 0.0E+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I, J, PREVLASTV, LASTV 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           SGEMV, STRMV 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      EXTERNAL           LSAME 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.EQ.0 )                                                      &
     &   RETURN                                                         
!                                                                       
      IF( LSAME( DIRECT, 'F' ) ) THEN 
         PREVLASTV = N 
         DO I = 1, K 
            PREVLASTV = MAX( I, PREVLASTV ) 
            IF( TAU( I ).EQ.ZERO ) THEN 
!                                                                       
!              H(i)  =  I                                               
!                                                                       
               DO J = 1, I 
                  T( J, I ) = ZERO 
               END DO 
            ELSE 
!                                                                       
!              general case                                             
!                                                                       
               IF( LSAME( STOREV, 'C' ) ) THEN 
!                 Skip any trailing zeros.                              
                  DO LASTV = N, I+1, -1 
                     IF( V( LASTV, I ).NE.ZERO ) EXIT 
                  END DO 
                  DO J = 1, I-1 
                     T( J, I ) = -TAU( I ) * V( I , J ) 
                  END DO 
                  J = MIN( LASTV, PREVLASTV ) 
!                                                                       
!                 T(1:i-1,i) := - tau(i) * V(i:j,1:i-1)**T * V(i:j,i)   
!                                                                       
                  CALL SGEMV( 'Transpose', J-I, I-1, -TAU( I ),         &
     &                        V( I+1, 1 ), LDV, V( I+1, I ), 1, ONE,    &
     &                        T( 1, I ), 1 )                            
               ELSE 
!                 Skip any trailing zeros.                              
                  DO LASTV = N, I+1, -1 
                     IF( V( I, LASTV ).NE.ZERO ) EXIT 
                  END DO 
                  DO J = 1, I-1 
                     T( J, I ) = -TAU( I ) * V( J , I ) 
                  END DO 
                  J = MIN( LASTV, PREVLASTV ) 
!                                                                       
!                 T(1:i-1,i) := - tau(i) * V(1:i-1,i:j) * V(i,i:j)**T   
!                                                                       
                  CALL SGEMV( 'No transpose', I-1, J-I, -TAU( I ),      &
     &                        V( 1, I+1 ), LDV, V( I, I+1 ), LDV,       &
     &                        ONE, T( 1, I ), 1 )                       
               END IF 
!                                                                       
!              T(1:i-1,i) := T(1:i-1,1:i-1) * T(1:i-1,i)                
!                                                                       
               CALL STRMV( 'Upper', 'No transpose', 'Non-unit', I-1, T, &
     &                     LDT, T( 1, I ), 1 )                          
               T( I, I ) = TAU( I ) 
               IF( I.GT.1 ) THEN 
                  PREVLASTV = MAX( PREVLASTV, LASTV ) 
               ELSE 
                  PREVLASTV = LASTV 
               END IF 
            END IF 
         END DO 
      ELSE 
         PREVLASTV = 1 
         DO I = K, 1, -1 
            IF( TAU( I ).EQ.ZERO ) THEN 
!                                                                       
!              H(i)  =  I                                               
!                                                                       
               DO J = I, K 
                  T( J, I ) = ZERO 
               END DO 
            ELSE 
!                                                                       
!              general case                                             
!                                                                       
               IF( I.LT.K ) THEN 
                  IF( LSAME( STOREV, 'C' ) ) THEN 
!                    Skip any leading zeros.                            
                     DO LASTV = 1, I-1 
                        IF( V( LASTV, I ).NE.ZERO ) EXIT 
                     END DO 
                     DO J = I+1, K 
                        T( J, I ) = -TAU( I ) * V( N-K+I , J ) 
                     END DO 
                     J = MAX( LASTV, PREVLASTV ) 
!                                                                       
!                    T(i+1:k,i) = -tau(i) * V(j:n-k+i,i+1:k)**T * V(j:n-
!                                                                       
                     CALL SGEMV( 'Transpose', N-K+I-J, K-I, -TAU( I ),  &
     &                           V( J, I+1 ), LDV, V( J, I ), 1, ONE,   &
     &                           T( I+1, I ), 1 )                       
                  ELSE 
!                    Skip any leading zeros.                            
                     DO LASTV = 1, I-1 
                        IF( V( I, LASTV ).NE.ZERO ) EXIT 
                     END DO 
                     DO J = I+1, K 
                        T( J, I ) = -TAU( I ) * V( J, N-K+I ) 
                     END DO 
                     J = MAX( LASTV, PREVLASTV ) 
!                                                                       
!                    T(i+1:k,i) = -tau(i) * V(i+1:k,j:n-k+i) * V(i,j:n-k
!                                                                       
                     CALL SGEMV( 'No transpose', K-I, N-K+I-J,          &
     &                    -TAU( I ), V( I+1, J ), LDV, V( I, J ), LDV,  &
     &                    ONE, T( I+1, I ), 1 )                         
                  END IF 
!                                                                       
!                 T(i+1:k,i) := T(i+1:k,i+1:k) * T(i+1:k,i)             
!                                                                       
                  CALL STRMV( 'Lower', 'No transpose', 'Non-unit', K-I, &
     &                        T( I+1, I+1 ), LDT, T( I+1, I ), 1 )      
                  IF( I.GT.1 ) THEN 
                     PREVLASTV = MIN( PREVLASTV, LASTV ) 
                  ELSE 
                     PREVLASTV = LASTV 
                  END IF 
               END IF 
               T( I, I ) = TAU( I ) 
            END IF 
         END DO 
      END IF 
      RETURN 
!                                                                       
!     End of SLARFT                                                     
!                                                                       
      END                                           
!> \brief \b SLARNV returns a vector of random numbers from a uniform or
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLARNV + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SLARNV( IDIST, ISEED, N, X )                         
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            IDIST, N                                     
!       ..                                                              
!       .. Array Arguments ..                                           
!       INTEGER            ISEED( 4 )                                   
!       REAL               X( * )                                       
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SLARNV returns a vector of n random real numbers from a uniform or   
!> normal distribution.                                                 
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] IDIST                                                     
!> \verbatim                                                            
!>          IDIST is INTEGER                                            
!>          Specifies the distribution of the random numbers:           
!>          = 1:  uniform (0,1)                                         
!>          = 2:  uniform (-1,1)                                        
!>          = 3:  normal (0,1)                                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] ISEED                                                 
!> \verbatim                                                            
!>          ISEED is INTEGER array, dimension (4)                       
!>          On entry, the seed of the random number generator; the array
!>          elements must be between 0 and 4095, and ISEED(4) must be   
!>          odd.                                                        
!>          On exit, the seed is updated.                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The number of random numbers to be generated.               
!> \endverbatim                                                         
!>                                                                      
!> \param[out] X                                                        
!> \verbatim                                                            
!>          X is REAL array, dimension (N)                              
!>          The generated random numbers.                               
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  This routine calls the auxiliary routine SLARUV to generate random  
!>  real numbers from a uniform (0,1) distribution, in batches of up to 
!>  128 using vectorisable code. The Box-Muller method is used to       
!>  transform numbers from a uniform to a normal distribution.          
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE SLARNV( IDIST, ISEED, N, X ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            IDIST, N 
!     ..                                                                
!     .. Array Arguments ..                                             
      INTEGER            ISEED( 4 ) 
      REAL               X( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ONE, TWO 
      PARAMETER          ( ONE = 1.0E+0, TWO = 2.0E+0 ) 
      INTEGER            LV 
      PARAMETER          ( LV = 128 ) 
      REAL               TWOPI 
      PARAMETER          ( TWOPI = 6.2831853071795864769252867663E+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I, IL, IL2, IV 
!     ..                                                                
!     .. Local Arrays ..                                                
      REAL               U( LV ) 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          COS, LOG, MIN, SQRT 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           SLARUV 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      DO 40 IV = 1, N, LV / 2 
         IL = MIN( LV / 2, N-IV+1 ) 
         IF( IDIST.EQ.3 ) THEN 
            IL2 = 2*IL 
         ELSE 
            IL2 = IL 
         END IF 
!                                                                       
!        Call SLARUV to generate IL2 numbers from a uniform (0,1)       
!        distribution (IL2 <= LV)                                       
!                                                                       
         CALL SLARUV( ISEED, IL2, U ) 
!                                                                       
         IF( IDIST.EQ.1 ) THEN 
!                                                                       
!           Copy generated numbers                                      
!                                                                       
            DO 10 I = 1, IL 
               X( IV+I-1 ) = U( I ) 
   10       CONTINUE 
         ELSE IF( IDIST.EQ.2 ) THEN 
!                                                                       
!           Convert generated numbers to uniform (-1,1) distribution    
!                                                                       
            DO 20 I = 1, IL 
               X( IV+I-1 ) = TWO*U( I ) - ONE 
   20       CONTINUE 
         ELSE IF( IDIST.EQ.3 ) THEN 
!                                                                       
!           Convert generated numbers to normal (0,1) distribution      
!                                                                       
            DO 30 I = 1, IL 
               X( IV+I-1 ) = SQRT( -TWO*LOG( U( 2*I-1 ) ) )*            &
     &                       COS( TWOPI*U( 2*I ) )                      
   30       CONTINUE 
         END IF 
   40 END DO 
      RETURN 
!                                                                       
!     End of SLARNV                                                     
!                                                                       
      END                                           
!> \brief \b SLARRA computes the splitting points with the specified thr
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLARRA + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SLARRA( N, D, E, E2, SPLTOL, TNRM,                   
!                           NSPLIT, ISPLIT, INFO )                      
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            INFO, N, NSPLIT                              
!       REAL                SPLTOL, TNRM                                
!       ..                                                              
!       .. Array Arguments ..                                           
!       INTEGER            ISPLIT( * )                                  
!       REAL               D( * ), E( * ), E2( * )                      
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> Compute the splitting points with threshold SPLTOL.                  
!> SLARRA sets any "small" off-diagonal elements to zero.               
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix. N > 0.                             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] D                                                         
!> \verbatim                                                            
!>          D is REAL array, dimension (N)                              
!>          On entry, the N diagonal elements of the tridiagonal        
!>          matrix T.                                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] E                                                     
!> \verbatim                                                            
!>          E is REAL array, dimension (N)                              
!>          On entry, the first (N-1) entries contain the subdiagonal   
!>          elements of the tridiagonal matrix T; E(N) need not be set. 
!>          On exit, the entries E( ISPLIT( I ) ), 1 <= I <= NSPLIT,    
!>          are set to zero, the other entries of E are untouched.      
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] E2                                                    
!> \verbatim                                                            
!>          E2 is REAL array, dimension (N)                             
!>          On entry, the first (N-1) entries contain the SQUARES of the
!>          subdiagonal elements of the tridiagonal matrix T;           
!>          E2(N) need not be set.                                      
!>          On exit, the entries E2( ISPLIT( I ) ),                     
!>          1 <= I <= NSPLIT, have been set to zero                     
!> \endverbatim                                                         
!>                                                                      
!> \param[in] SPLTOL                                                    
!> \verbatim                                                            
!>          SPLTOL is REAL                                              
!>          The threshold for splitting. Two criteria can be used:      
!>          SPLTOL<0 : criterion based on absolute off-diagonal value   
!>          SPLTOL>0 : criterion that preserves relative accuracy       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TNRM                                                      
!> \verbatim                                                            
!>          TNRM is REAL                                                
!>          The norm of the matrix.                                     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] NSPLIT                                                   
!> \verbatim                                                            
!>          NSPLIT is INTEGER                                           
!>          The number of blocks T splits into. 1 <= NSPLIT <= N.       
!> \endverbatim                                                         
!>                                                                      
!> \param[out] ISPLIT                                                   
!> \verbatim                                                            
!>          ISPLIT is INTEGER array, dimension (N)                      
!>          The splitting points, at which T breaks up into blocks.     
!>          The first block consists of rows/columns 1 to ISPLIT(1),    
!>          the second of rows/columns ISPLIT(1)+1 through ISPLIT(2),   
!>          etc., and the NSPLIT-th consists of rows/columns            
!>          ISPLIT(NSPLIT-1)+1 through ISPLIT(NSPLIT)=N.                
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0:  successful exit                                       
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2017                                                      
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!> \par Contributors:                                                   
!  ==================                                                   
!>                                                                      
!> Beresford Parlett, University of California, Berkeley, USA \n        
!> Jim Demmel, University of California, Berkeley, USA \n               
!> Inderjit Dhillon, University of Texas, Austin, USA \n                
!> Osni Marques, LBNL/NERSC, USA \n                                     
!> Christof Voemel, University of California, Berkeley, USA             
!                                                                       
!  =====================================================================
      SUBROUTINE SLARRA( N, D, E, E2, SPLTOL, TNRM,                     &
     &                    NSPLIT, ISPLIT, INFO )                        
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.1) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2017                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            INFO, N, NSPLIT 
      REAL                SPLTOL, TNRM 
!     ..                                                                
!     .. Array Arguments ..                                             
      INTEGER            ISPLIT( * ) 
      REAL               D( * ), E( * ), E2( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ZERO 
      PARAMETER          ( ZERO = 0.0E0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I 
      REAL               EABS, TMP1 
                                                                        
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      INFO = 0 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.LE.0 ) THEN 
         RETURN 
      END IF 
!                                                                       
!     Compute splitting points                                          
      NSPLIT = 1 
      IF(SPLTOL.LT.ZERO) THEN 
!        Criterion based on absolute off-diagonal value                 
         TMP1 = ABS(SPLTOL)* TNRM 
         DO 9 I = 1, N-1 
            EABS = ABS( E(I) ) 
            IF( EABS .LE. TMP1) THEN 
               E(I) = ZERO 
               E2(I) = ZERO 
               ISPLIT( NSPLIT ) = I 
               NSPLIT = NSPLIT + 1 
            END IF 
    9    CONTINUE 
      ELSE 
!        Criterion that guarantees relative accuracy                    
         DO 10 I = 1, N-1 
            EABS = ABS( E(I) ) 
            IF( EABS .LE. SPLTOL * SQRT(ABS(D(I)))*SQRT(ABS(D(I+1))) )  &
     &      THEN                                                        
               E(I) = ZERO 
               E2(I) = ZERO 
               ISPLIT( NSPLIT ) = I 
               NSPLIT = NSPLIT + 1 
            END IF 
   10    CONTINUE 
      ENDIF 
      ISPLIT( NSPLIT ) = N 
                                                                        
      RETURN 
!                                                                       
!     End of SLARRA                                                     
!                                                                       
      END                                           
!> \brief \b SLARRB provides limited bisection to locate eigenvalues for
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLARRB + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SLARRB( N, D, LLD, IFIRST, ILAST, RTOL1,             
!                          RTOL2, OFFSET, W, WGAP, WERR, WORK, IWORK,   
!                          PIVMIN, SPDIAM, TWIST, INFO )                
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            IFIRST, ILAST, INFO, N, OFFSET, TWIST        
!       REAL               PIVMIN, RTOL1, RTOL2, SPDIAM                 
!       ..                                                              
!       .. Array Arguments ..                                           
!       INTEGER            IWORK( * )                                   
!       REAL               D( * ), LLD( * ), W( * ),                    
!      $                   WERR( * ), WGAP( * ), WORK( * )              
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> Given the relatively robust representation(RRR) L D L^T, SLARRB      
!> does "limited" bisection to refine the eigenvalues of L D L^T,       
!> W( IFIRST-OFFSET ) through W( ILAST-OFFSET ), to more accuracy. Initi
!> guesses for these eigenvalues are input in W, the corresponding estim
!> of the error in these guesses and their gaps are input in WERR       
!> and WGAP, respectively. During bisection, intervals                  
!> [left, right] are maintained by storing their mid-points and         
!> semi-widths in the arrays W and WERR respectively.                   
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix.                                    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] D                                                         
!> \verbatim                                                            
!>          D is REAL array, dimension (N)                              
!>          The N diagonal elements of the diagonal matrix D.           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LLD                                                       
!> \verbatim                                                            
!>          LLD is REAL array, dimension (N-1)                          
!>          The (N-1) elements L(i)*L(i)*D(i).                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IFIRST                                                    
!> \verbatim                                                            
!>          IFIRST is INTEGER                                           
!>          The index of the first eigenvalue to be computed.           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ILAST                                                     
!> \verbatim                                                            
!>          ILAST is INTEGER                                            
!>          The index of the last eigenvalue to be computed.            
!> \endverbatim                                                         
!>                                                                      
!> \param[in] RTOL1                                                     
!> \verbatim                                                            
!>          RTOL1 is REAL                                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] RTOL2                                                     
!> \verbatim                                                            
!>          RTOL2 is REAL                                               
!>          Tolerance for the convergence of the bisection intervals.   
!>          An interval [LEFT,RIGHT] has converged if                   
!>          RIGHT-LEFT < MAX( RTOL1*GAP, RTOL2*MAX(|LEFT|,|RIGHT|) )    
!>          where GAP is the (estimated) distance to the nearest        
!>          eigenvalue.                                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] OFFSET                                                    
!> \verbatim                                                            
!>          OFFSET is INTEGER                                           
!>          Offset for the arrays W, WGAP and WERR, i.e., the IFIRST-OFF
!>          through ILAST-OFFSET elements of these arrays are to be used
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] W                                                     
!> \verbatim                                                            
!>          W is REAL array, dimension (N)                              
!>          On input, W( IFIRST-OFFSET ) through W( ILAST-OFFSET ) are  
!>          estimates of the eigenvalues of L D L^T indexed IFIRST throu
!>          ILAST.                                                      
!>          On output, these estimates are refined.                     
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] WGAP                                                  
!> \verbatim                                                            
!>          WGAP is REAL array, dimension (N-1)                         
!>          On input, the (estimated) gaps between consecutive          
!>          eigenvalues of L D L^T, i.e., WGAP(I-OFFSET) is the gap betw
!>          eigenvalues I and I+1. Note that if IFIRST = ILAST          
!>          then WGAP(IFIRST-OFFSET) must be set to ZERO.               
!>          On output, these gaps are refined.                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] WERR                                                  
!> \verbatim                                                            
!>          WERR is REAL array, dimension (N)                           
!>          On input, WERR( IFIRST-OFFSET ) through WERR( ILAST-OFFSET )
!>          the errors in the estimates of the corresponding elements in
!>          On output, these errors are refined.                        
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is REAL array, dimension (2*N)                         
!>          Workspace.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[out] IWORK                                                    
!> \verbatim                                                            
!>          IWORK is INTEGER array, dimension (2*N)                     
!>          Workspace.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] PIVMIN                                                    
!> \verbatim                                                            
!>          PIVMIN is REAL                                              
!>          The minimum pivot in the Sturm sequence.                    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] SPDIAM                                                    
!> \verbatim                                                            
!>          SPDIAM is REAL                                              
!>          The spectral diameter of the matrix.                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TWIST                                                     
!> \verbatim                                                            
!>          TWIST is INTEGER                                            
!>          The twist index for the twisted factorization that is used  
!>          for the negcount.                                           
!>          TWIST = N: Compute negcount from L D L^T - LAMBDA I = L+ D+ 
!>          TWIST = 1: Compute negcount from L D L^T - LAMBDA I = U- D- 
!>          TWIST = R: Compute negcount from L D L^T - LAMBDA I = N(r) D
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          Error flag.                                                 
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2017                                                      
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!> \par Contributors:                                                   
!  ==================                                                   
!>                                                                      
!> Beresford Parlett, University of California, Berkeley, USA \n        
!> Jim Demmel, University of California, Berkeley, USA \n               
!> Inderjit Dhillon, University of Texas, Austin, USA \n                
!> Osni Marques, LBNL/NERSC, USA \n                                     
!> Christof Voemel, University of California, Berkeley, USA             
!                                                                       
!  =====================================================================
      SUBROUTINE SLARRB( N, D, LLD, IFIRST, ILAST, RTOL1,               &
     &                   RTOL2, OFFSET, W, WGAP, WERR, WORK, IWORK,     &
     &                   PIVMIN, SPDIAM, TWIST, INFO )                  
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.1) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2017                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            IFIRST, ILAST, INFO, N, OFFSET, TWIST 
      REAL               PIVMIN, RTOL1, RTOL2, SPDIAM 
!     ..                                                                
!     .. Array Arguments ..                                             
      INTEGER            IWORK( * ) 
      REAL               D( * ), LLD( * ), W( * ),                      &
     &                   WERR( * ), WGAP( * ), WORK( * )                
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ZERO, TWO, HALF 
      PARAMETER        ( ZERO = 0.0E0, TWO = 2.0E0,                     &
     &                   HALF = 0.5E0 )                                 
      INTEGER   MAXITR 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I, I1, II, IP, ITER, K, NEGCNT, NEXT, NINT,    &
     &                   OLNINT, PREV, R                                
      REAL               BACK, CVRGD, GAP, LEFT, LGAP, MID, MNWDTH,     &
     &                   RGAP, RIGHT, TMP, WIDTH                        
!     ..                                                                
!     .. External Functions ..                                          
      INTEGER            SLANEG 
      EXTERNAL           SLANEG 
!                                                                       
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, MAX, MIN 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      INFO = 0 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.LE.0 ) THEN 
         RETURN 
      END IF 
!                                                                       
      MAXITR = INT( ( LOG( SPDIAM+PIVMIN )-LOG( PIVMIN ) ) /            &
     &           LOG( TWO ) ) + 2                                       
      MNWDTH = TWO * PIVMIN 
!                                                                       
      R = TWIST 
      IF((R.LT.1).OR.(R.GT.N)) R = N 
!                                                                       
!     Initialize unconverged intervals in [ WORK(2*I-1), WORK(2*I) ].   
!     The Sturm Count, Count( WORK(2*I-1) ) is arranged to be I-1, while
!     Count( WORK(2*I) ) is stored in IWORK( 2*I ). The integer IWORK( 2
!     for an unconverged interval is set to the index of the next unconv
!     interval, and is -1 or 0 for a converged interval. Thus a linked  
!     list of unconverged intervals is set up.                          
!                                                                       
      I1 = IFIRST 
!     The number of unconverged intervals                               
      NINT = 0 
!     The last unconverged interval found                               
      PREV = 0 
                                                                        
      RGAP = WGAP( I1-OFFSET ) 
      DO 75 I = I1, ILAST 
         K = 2*I 
         II = I - OFFSET 
         LEFT = W( II ) - WERR( II ) 
         RIGHT = W( II ) + WERR( II ) 
         LGAP = RGAP 
         RGAP = WGAP( II ) 
         GAP = MIN( LGAP, RGAP ) 
                                                                        
!        Make sure that [LEFT,RIGHT] contains the desired eigenvalue    
!        Compute negcount from dstqds facto L+D+L+^T = L D L^T - LEFT   
!                                                                       
!        Do while( NEGCNT(LEFT).GT.I-1 )                                
!                                                                       
         BACK = WERR( II ) 
   20    CONTINUE 
         NEGCNT = SLANEG( N, D, LLD, LEFT, PIVMIN, R ) 
         IF( NEGCNT.GT.I-1 ) THEN 
            LEFT = LEFT - BACK 
            BACK = TWO*BACK 
            GO TO 20 
         END IF 
!                                                                       
!        Do while( NEGCNT(RIGHT).LT.I )                                 
!        Compute negcount from dstqds facto L+D+L+^T = L D L^T - RIGHT  
!                                                                       
         BACK = WERR( II ) 
   50    CONTINUE 
                                                                        
         NEGCNT = SLANEG( N, D, LLD, RIGHT, PIVMIN, R ) 
          IF( NEGCNT.LT.I ) THEN 
             RIGHT = RIGHT + BACK 
             BACK = TWO*BACK 
             GO TO 50 
          END IF 
         WIDTH = HALF*ABS( LEFT - RIGHT ) 
         TMP = MAX( ABS( LEFT ), ABS( RIGHT ) ) 
         CVRGD = MAX(RTOL1*GAP,RTOL2*TMP) 
         IF( WIDTH.LE.CVRGD .OR. WIDTH.LE.MNWDTH ) THEN 
!           This interval has already converged and does not need refine
!           (Note that the gaps might change through refining the       
!            eigenvalues, however, they can only get bigger.)           
!           Remove it from the list.                                    
            IWORK( K-1 ) = -1 
!           Make sure that I1 always points to the first unconverged int
            IF((I.EQ.I1).AND.(I.LT.ILAST)) I1 = I + 1 
            IF((PREV.GE.I1).AND.(I.LE.ILAST)) IWORK( 2*PREV-1 ) = I + 1 
         ELSE 
!           unconverged interval found                                  
            PREV = I 
            NINT = NINT + 1 
            IWORK( K-1 ) = I + 1 
            IWORK( K ) = NEGCNT 
         END IF 
         WORK( K-1 ) = LEFT 
         WORK( K ) = RIGHT 
   75 END DO 
                                                                        
!                                                                       
!     Do while( NINT.GT.0 ), i.e. there are still unconverged intervals 
!     and while (ITER.LT.MAXITR)                                        
!                                                                       
      ITER = 0 
   80 CONTINUE 
      PREV = I1 - 1 
      I = I1 
      OLNINT = NINT 
                                                                        
      DO 100 IP = 1, OLNINT 
         K = 2*I 
         II = I - OFFSET 
         RGAP = WGAP( II ) 
         LGAP = RGAP 
         IF(II.GT.1) LGAP = WGAP( II-1 ) 
         GAP = MIN( LGAP, RGAP ) 
         NEXT = IWORK( K-1 ) 
         LEFT = WORK( K-1 ) 
         RIGHT = WORK( K ) 
         MID = HALF*( LEFT + RIGHT ) 
                                                                        
!        semiwidth of interval                                          
         WIDTH = RIGHT - MID 
         TMP = MAX( ABS( LEFT ), ABS( RIGHT ) ) 
         CVRGD = MAX(RTOL1*GAP,RTOL2*TMP) 
         IF( ( WIDTH.LE.CVRGD ) .OR. ( WIDTH.LE.MNWDTH ).OR.            &
     &       ( ITER.EQ.MAXITR ) )THEN                                   
!           reduce number of unconverged intervals                      
            NINT = NINT - 1 
!           Mark interval as converged.                                 
            IWORK( K-1 ) = 0 
            IF( I1.EQ.I ) THEN 
               I1 = NEXT 
            ELSE 
!              Prev holds the last unconverged interval previously exami
               IF(PREV.GE.I1) IWORK( 2*PREV-1 ) = NEXT 
            END IF 
            I = NEXT 
            GO TO 100 
         END IF 
         PREV = I 
!                                                                       
!        Perform one bisection step                                     
!                                                                       
         NEGCNT = SLANEG( N, D, LLD, MID, PIVMIN, R ) 
         IF( NEGCNT.LE.I-1 ) THEN 
            WORK( K-1 ) = MID 
         ELSE 
            WORK( K ) = MID 
         END IF 
         I = NEXT 
  100 END DO 
      ITER = ITER + 1 
!     do another loop if there are still unconverged intervals          
!     However, in the last iteration, all intervals are accepted        
!     since this is the best we can do.                                 
      IF( ( NINT.GT.0 ).AND.(ITER.LE.MAXITR) ) GO TO 80 
!                                                                       
!                                                                       
!     At this point, all the intervals have converged                   
      DO 110 I = IFIRST, ILAST 
         K = 2*I 
         II = I - OFFSET 
!        All intervals marked by '0' have been refined.                 
         IF( IWORK( K-1 ).EQ.0 ) THEN 
            W( II ) = HALF*( WORK( K-1 )+WORK( K ) ) 
            WERR( II ) = WORK( K ) - W( II ) 
         END IF 
  110 END DO 
!                                                                       
      DO 111 I = IFIRST+1, ILAST 
         K = 2*I 
         II = I - OFFSET 
         WGAP( II-1 ) = MAX( ZERO,                                      &
     &                     W(II) - WERR (II) - W( II-1 ) - WERR( II-1 ))
  111 END DO 
                                                                        
      RETURN 
!                                                                       
!     End of SLARRB                                                     
!                                                                       
      END                                           
!> \brief \b SLARRC computes the number of eigenvalues of the symmetric 
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLARRC + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SLARRC( JOBT, N, VL, VU, D, E, PIVMIN,               
!                                   EIGCNT, LCNT, RCNT, INFO )          
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          JOBT                                         
!       INTEGER            EIGCNT, INFO, LCNT, N, RCNT                  
!       REAL               PIVMIN, VL, VU                               
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL               D( * ), E( * )                               
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> Find the number of eigenvalues of the symmetric tridiagonal matrix T 
!> that are in the interval (VL,VU] if JOBT = 'T', and of L D L^T       
!> if JOBT = 'L'.                                                       
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] JOBT                                                      
!> \verbatim                                                            
!>          JOBT is CHARACTER*1                                         
!>          = 'T':  Compute Sturm count for matrix T.                   
!>          = 'L':  Compute Sturm count for matrix L D L^T.             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix. N > 0.                             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] VL                                                        
!> \verbatim                                                            
!>          VL is REAL                                                  
!>          The lower bound for the eigenvalues.                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] VU                                                        
!> \verbatim                                                            
!>          VU is REAL                                                  
!>          The upper bound for the eigenvalues.                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] D                                                         
!> \verbatim                                                            
!>          D is REAL array, dimension (N)                              
!>          JOBT = 'T': The N diagonal elements of the tridiagonal matri
!>          JOBT = 'L': The N diagonal elements of the diagonal matrix D
!> \endverbatim                                                         
!>                                                                      
!> \param[in] E                                                         
!> \verbatim                                                            
!>          E is REAL array, dimension (N)                              
!>          JOBT = 'T': The N-1 offdiagonal elements of the matrix T.   
!>          JOBT = 'L': The N-1 offdiagonal elements of the matrix L.   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] PIVMIN                                                    
!> \verbatim                                                            
!>          PIVMIN is REAL                                              
!>          The minimum pivot in the Sturm sequence for T.              
!> \endverbatim                                                         
!>                                                                      
!> \param[out] EIGCNT                                                   
!> \verbatim                                                            
!>          EIGCNT is INTEGER                                           
!>          The number of eigenvalues of the symmetric tridiagonal matri
!>          that are in the interval (VL,VU]                            
!> \endverbatim                                                         
!>                                                                      
!> \param[out] LCNT                                                     
!> \verbatim                                                            
!>          LCNT is INTEGER                                             
!> \endverbatim                                                         
!>                                                                      
!> \param[out] RCNT                                                     
!> \verbatim                                                            
!>          RCNT is INTEGER                                             
!>          The left and right negcounts of the interval.               
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2016                                                      
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!> \par Contributors:                                                   
!  ==================                                                   
!>                                                                      
!> Beresford Parlett, University of California, Berkeley, USA \n        
!> Jim Demmel, University of California, Berkeley, USA \n               
!> Inderjit Dhillon, University of Texas, Austin, USA \n                
!> Osni Marques, LBNL/NERSC, USA \n                                     
!> Christof Voemel, University of California, Berkeley, USA             
!                                                                       
!  =====================================================================
      SUBROUTINE SLARRC( JOBT, N, VL, VU, D, E, PIVMIN,                 &
     &                            EIGCNT, LCNT, RCNT, INFO )            
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.1) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2016                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          JOBT 
      INTEGER            EIGCNT, INFO, LCNT, N, RCNT 
      REAL               PIVMIN, VL, VU 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               D( * ), E( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ZERO 
      PARAMETER          ( ZERO = 0.0E0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I 
      LOGICAL            MATT 
      REAL               LPIVOT, RPIVOT, SL, SU, TMP, TMP2 
                                                                        
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      EXTERNAL           LSAME 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      INFO = 0 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.LE.0 ) THEN 
         RETURN 
      END IF 
!                                                                       
      LCNT = 0 
      RCNT = 0 
      EIGCNT = 0 
      MATT = LSAME( JOBT, 'T' ) 
                                                                        
                                                                        
      IF (MATT) THEN 
!        Sturm sequence count on T                                      
         LPIVOT = D( 1 ) - VL 
         RPIVOT = D( 1 ) - VU 
         IF( LPIVOT.LE.ZERO ) THEN 
            LCNT = LCNT + 1 
         ENDIF 
         IF( RPIVOT.LE.ZERO ) THEN 
            RCNT = RCNT + 1 
         ENDIF 
         DO 10 I = 1, N-1 
            TMP = E(I)**2 
            LPIVOT = ( D( I+1 )-VL ) - TMP/LPIVOT 
            RPIVOT = ( D( I+1 )-VU ) - TMP/RPIVOT 
            IF( LPIVOT.LE.ZERO ) THEN 
               LCNT = LCNT + 1 
            ENDIF 
            IF( RPIVOT.LE.ZERO ) THEN 
               RCNT = RCNT + 1 
            ENDIF 
   10    CONTINUE 
      ELSE 
!        Sturm sequence count on L D L^T                                
         SL = -VL 
         SU = -VU 
         DO 20 I = 1, N - 1 
            LPIVOT = D( I ) + SL 
            RPIVOT = D( I ) + SU 
            IF( LPIVOT.LE.ZERO ) THEN 
               LCNT = LCNT + 1 
            ENDIF 
            IF( RPIVOT.LE.ZERO ) THEN 
               RCNT = RCNT + 1 
            ENDIF 
            TMP = E(I) * D(I) * E(I) 
!                                                                       
            TMP2 = TMP / LPIVOT 
            IF( TMP2.EQ.ZERO ) THEN 
               SL =  TMP - VL 
            ELSE 
               SL = SL*TMP2 - VL 
            END IF 
!                                                                       
            TMP2 = TMP / RPIVOT 
            IF( TMP2.EQ.ZERO ) THEN 
               SU =  TMP - VU 
            ELSE 
               SU = SU*TMP2 - VU 
            END IF 
   20    CONTINUE 
         LPIVOT = D( N ) + SL 
         RPIVOT = D( N ) + SU 
         IF( LPIVOT.LE.ZERO ) THEN 
            LCNT = LCNT + 1 
         ENDIF 
         IF( RPIVOT.LE.ZERO ) THEN 
            RCNT = RCNT + 1 
         ENDIF 
      ENDIF 
      EIGCNT = RCNT - LCNT 
                                                                        
      RETURN 
!                                                                       
!     end of SLARRC                                                     
!                                                                       
!> \brief \b SLARRD computes the eigenvalues of a symmetric tridiagonal 
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLARRD + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SLARRD( RANGE, ORDER, N, VL, VU, IL, IU, GERS,       
!                           RELTOL, D, E, E2, PIVMIN, NSPLIT, ISPLIT,   
!                           M, W, WERR, WL, WU, IBLOCK, INDEXW,         
!                           WORK, IWORK, INFO )                         
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          ORDER, RANGE                                 
!       INTEGER            IL, INFO, IU, M, N, NSPLIT                   
!       REAL                PIVMIN, RELTOL, VL, VU, WL, WU              
!       ..                                                              
!       .. Array Arguments ..                                           
!       INTEGER            IBLOCK( * ), INDEXW( * ),                    
!      $                   ISPLIT( * ), IWORK( * )                      
!       REAL               D( * ), E( * ), E2( * ),                     
!      $                   GERS( * ), W( * ), WERR( * ), WORK( * )      
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SLARRD computes the eigenvalues of a symmetric tridiagonal           
!> matrix T to suitable accuracy. This is an auxiliary code to be       
!> called from SSTEMR.                                                  
!> The user may ask for all eigenvalues, all eigenvalues                
!> in the half-open interval (VL, VU], or the IL-th through IU-th       
!> eigenvalues.                                                         
!>                                                                      
!> To avoid overflow, the matrix must be scaled so that its             
!> largest element is no greater than overflow**(1/2) * underflow**(1/4)
!> accuracy, it should not be much smaller than that.                   
!>                                                                      
!> See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal        
!> Matrix", Report CS41, Computer Science Dept., Stanford               
!> University, July 21, 1966.                                           
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] RANGE                                                     
!> \verbatim                                                            
!>          RANGE is CHARACTER*1                                        
!>          = 'A': ("All")   all eigenvalues will be found.             
!>          = 'V': ("Value") all eigenvalues in the half-open interval  
!>                           (VL, VU] will be found.                    
!>          = 'I': ("Index") the IL-th through IU-th eigenvalues (of the
!>                           entire matrix) will be found.              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ORDER                                                     
!> \verbatim                                                            
!>          ORDER is CHARACTER*1                                        
!>          = 'B': ("By Block") the eigenvalues will be grouped by      
!>                              split-off block (see IBLOCK, ISPLIT) and
!>                              ordered from smallest to largest within 
!>                              the block.                              
!>          = 'E': ("Entire matrix")                                    
!>                              the eigenvalues for the entire matrix   
!>                              will be ordered from smallest to        
!>                              largest.                                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the tridiagonal matrix T.  N >= 0.             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] VL                                                        
!> \verbatim                                                            
!>          VL is REAL                                                  
!>          If RANGE='V', the lower bound of the interval to            
!>          be searched for eigenvalues.  Eigenvalues less than or equal
!>          to VL, or greater than VU, will not be returned.  VL < VU.  
!>          Not referenced if RANGE = 'A' or 'I'.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] VU                                                        
!> \verbatim                                                            
!>          VU is REAL                                                  
!>          If RANGE='V', the upper bound of the interval to            
!>          be searched for eigenvalues.  Eigenvalues less than or equal
!>          to VL, or greater than VU, will not be returned.  VL < VU.  
!>          Not referenced if RANGE = 'A' or 'I'.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IL                                                        
!> \verbatim                                                            
!>          IL is INTEGER                                               
!>          If RANGE='I', the index of the                              
!>          smallest eigenvalue to be returned.                         
!>          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.   
!>          Not referenced if RANGE = 'A' or 'V'.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IU                                                        
!> \verbatim                                                            
!>          IU is INTEGER                                               
!>          If RANGE='I', the index of the                              
!>          largest eigenvalue to be returned.                          
!>          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.   
!>          Not referenced if RANGE = 'A' or 'V'.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] GERS                                                      
!> \verbatim                                                            
!>          GERS is REAL array, dimension (2*N)                         
!>          The N Gerschgorin intervals (the i-th Gerschgorin interval  
!>          is (GERS(2*i-1), GERS(2*i)).                                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] RELTOL                                                    
!> \verbatim                                                            
!>          RELTOL is REAL                                              
!>          The minimum relative width of an interval.  When an interval
!>          is narrower than RELTOL times the larger (in                
!>          magnitude) endpoint, then it is considered to be            
!>          sufficiently small, i.e., converged.  Note: this should     
!>          always be at least radix*machine epsilon.                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] D                                                         
!> \verbatim                                                            
!>          D is REAL array, dimension (N)                              
!>          The n diagonal elements of the tridiagonal matrix T.        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] E                                                         
!> \verbatim                                                            
!>          E is REAL array, dimension (N-1)                            
!>          The (n-1) off-diagonal elements of the tridiagonal matrix T.
!> \endverbatim                                                         
!>                                                                      
!> \param[in] E2                                                        
!> \verbatim                                                            
!>          E2 is REAL array, dimension (N-1)                           
!>          The (n-1) squared off-diagonal elements of the tridiagonal m
!> \endverbatim                                                         
!>                                                                      
!> \param[in] PIVMIN                                                    
!> \verbatim                                                            
!>          PIVMIN is REAL                                              
!>          The minimum pivot allowed in the Sturm sequence for T.      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] NSPLIT                                                    
!> \verbatim                                                            
!>          NSPLIT is INTEGER                                           
!>          The number of diagonal blocks in the matrix T.              
!>          1 <= NSPLIT <= N.                                           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ISPLIT                                                    
!> \verbatim                                                            
!>          ISPLIT is INTEGER array, dimension (N)                      
!>          The splitting points, at which T breaks up into submatrices.
!>          The first submatrix consists of rows/columns 1 to ISPLIT(1),
!>          the second of rows/columns ISPLIT(1)+1 through ISPLIT(2),   
!>          etc., and the NSPLIT-th consists of rows/columns            
!>          ISPLIT(NSPLIT-1)+1 through ISPLIT(NSPLIT)=N.                
!>          (Only the first NSPLIT elements will actually be used, but  
!>          since the user cannot know a priori what value NSPLIT will  
!>          have, N words must be reserved for ISPLIT.)                 
!> \endverbatim                                                         
!>                                                                      
!> \param[out] M                                                        
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The actual number of eigenvalues found. 0 <= M <= N.        
!>          (See also the description of INFO=2,3.)                     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] W                                                        
!> \verbatim                                                            
!>          W is REAL array, dimension (N)                              
!>          On exit, the first M elements of W will contain the         
!>          eigenvalue approximations. SLARRD computes an interval      
!>          I_j = (a_j, b_j] that includes eigenvalue j. The eigenvalue 
      END                                           
!>          approximation is given as the interval midpoint             
!>          W(j)= ( a_j + b_j)/2. The corresponding error is bounded by 
!>          WERR(j) = abs( a_j - b_j)/2                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WERR                                                     
!> \verbatim                                                            
!>          WERR is REAL array, dimension (N)                           
!>          The error bound on the corresponding eigenvalue approximatio
!>          in W.                                                       
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WL                                                       
!> \verbatim                                                            
!>          WL is REAL                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WU                                                       
!> \verbatim                                                            
!>          WU is REAL                                                  
!>          The interval (WL, WU] contains all the wanted eigenvalues.  
!>          If RANGE='V', then WL=VL and WU=VU.                         
!>          If RANGE='A', then WL and WU are the global Gerschgorin boun
!>                        on the spectrum.                              
!>          If RANGE='I', then WL and WU are computed by SLAEBZ from the
!>                        index range specified.                        
!> \endverbatim                                                         
!>                                                                      
!> \param[out] IBLOCK                                                   
!> \verbatim                                                            
!>          IBLOCK is INTEGER array, dimension (N)                      
!>          At each row/column j where E(j) is zero or small, the       
!>          matrix T is considered to split into a block diagonal       
!>          matrix.  On exit, if INFO = 0, IBLOCK(i) specifies to which 
!>          block (from 1 to the number of blocks) the eigenvalue W(i)  
!>          belongs.  (SLARRD may use the remaining N-M elements as     
!>          workspace.)                                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INDEXW                                                   
!> \verbatim                                                            
!>          INDEXW is INTEGER array, dimension (N)                      
!>          The indices of the eigenvalues within each block (submatrix)
!>          for example, INDEXW(i)= j and IBLOCK(i)=k imply that the    
!>          i-th eigenvalue W(i) is the j-th eigenvalue in block k.     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is REAL array, dimension (4*N)                         
!> \endverbatim                                                         
!>                                                                      
!> \param[out] IWORK                                                    
!> \verbatim                                                            
!>          IWORK is INTEGER array, dimension (3*N)                     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0:  successful exit                                       
!>          < 0:  if INFO = -i, the i-th argument had an illegal value  
!>          > 0:  some or all of the eigenvalues failed to converge or  
!>                were not computed:                                    
!>                =1 or 3: Bisection failed to converge for some        
!>                        eigenvalues; these eigenvalues are flagged by 
!>                        negative block number.  The effect is that the
!>                        eigenvalues may not be as accurate as the     
!>                        absolute and relative tolerances.  This is    
!>                        generally caused by unexpectedly inaccurate   
!>                        arithmetic.                                   
!>                =2 or 3: RANGE='I' only: Not all of the eigenvalues   
!>                        IL:IU were found.                             
!>                        Effect: M < IU+1-IL                           
!>                        Cause:  non-monotonic arithmetic, causing the 
!>                                Sturm sequence to be non-monotonic.   
!>                        Cure:   recalculate, using RANGE='A', and pick
!>                                out eigenvalues IL:IU.  In some cases,
!>                                increasing the PARAMETER "FUDGE" may  
!>                                make things work.                     
!>                = 4:    RANGE='I', and the Gershgorin interval        
!>                        initially used was too small.  No eigenvalues 
!>                        were computed.                                
!>                        Probable cause: your machine has sloppy       
!>                                        floating-point arithmetic.    
!>                        Cure: Increase the PARAMETER "FUDGE",         
!>                              recompile, and try again.               
!> \endverbatim                                                         
!                                                                       
!> \par Internal Parameters:                                            
!  =========================                                            
!>                                                                      
!> \verbatim                                                            
!>  FUDGE   REAL, default = 2                                           
!>          A "fudge factor" to widen the Gershgorin intervals.  Ideally
!>          a value of 1 should work, but on machines with sloppy       
!>          arithmetic, this needs to be larger.  The default for       
!>          publicly released versions should be large enough to handle 
!>          the worst machine around.  Note that this has no effect     
!>          on accuracy of the solution.                                
!> \endverbatim                                                         
!>                                                                      
!> \par Contributors:                                                   
!  ==================                                                   
!>                                                                      
!>     W. Kahan, University of California, Berkeley, USA \n             
!>     Beresford Parlett, University of California, Berkeley, USA \n    
!>     Jim Demmel, University of California, Berkeley, USA \n           
!>     Inderjit Dhillon, University of Texas, Austin, USA \n            
!>     Osni Marques, LBNL/NERSC, USA \n                                 
!>     Christof Voemel, University of California, Berkeley, USA \n      
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2016                                                      
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!  =====================================================================
      SUBROUTINE SLARRD( RANGE, ORDER, N, VL, VU, IL, IU, GERS,         &
     &                    RELTOL, D, E, E2, PIVMIN, NSPLIT, ISPLIT,     &
     &                    M, W, WERR, WL, WU, IBLOCK, INDEXW,           &
     &                    WORK, IWORK, INFO )                           
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.1) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2016                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          ORDER, RANGE 
      INTEGER            IL, INFO, IU, M, N, NSPLIT 
      REAL                PIVMIN, RELTOL, VL, VU, WL, WU 
!     ..                                                                
!     .. Array Arguments ..                                             
      INTEGER            IBLOCK( * ), INDEXW( * ),                      &
     &                   ISPLIT( * ), IWORK( * )                        
      REAL               D( * ), E( * ), E2( * ),                       &
     &                   GERS( * ), W( * ), WERR( * ), WORK( * )        
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ZERO, ONE, TWO, HALF, FUDGE 
      PARAMETER          ( ZERO = 0.0E0, ONE = 1.0E0,                   &
     &                     TWO = 2.0E0, HALF = ONE/TWO,                 &
     &                     FUDGE = TWO )                                
      INTEGER   ALLRNG, VALRNG, INDRNG 
      PARAMETER ( ALLRNG = 1, VALRNG = 2, INDRNG = 3 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            NCNVRG, TOOFEW 
      INTEGER            I, IB, IBEGIN, IDISCL, IDISCU, IE, IEND, IINFO,&
     &                   IM, IN, IOFF, IOUT, IRANGE, ITMAX, ITMP1,      &
     &                   ITMP2, IW, IWOFF, J, JBLK, JDISC, JE, JEE, NB, &
     &                   NWL, NWU                                       
      REAL               ATOLI, EPS, GL, GU, RTOLI, TMP1, TMP2,         &
     &                   TNORM, UFLOW, WKILL, WLU, WUL                  
                                                                        
!     ..                                                                
!     .. Local Arrays ..                                                
      INTEGER            IDUMMA( 1 ) 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      INTEGER            ILAENV 
      REAL               SLAMCH 
      EXTERNAL           LSAME, ILAENV, SLAMCH 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           SLAEBZ 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, INT, LOG, MAX, MIN 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      INFO = 0 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.LE.0 ) THEN 
         RETURN 
      END IF 
!                                                                       
!     Decode RANGE                                                      
!                                                                       
      IF( LSAME( RANGE, 'A' ) ) THEN 
         IRANGE = ALLRNG 
      ELSE IF( LSAME( RANGE, 'V' ) ) THEN 
         IRANGE = VALRNG 
      ELSE IF( LSAME( RANGE, 'I' ) ) THEN 
         IRANGE = INDRNG 
      ELSE 
         IRANGE = 0 
      END IF 
!                                                                       
!     Check for Errors                                                  
!                                                                       
      IF( IRANGE.LE.0 ) THEN 
         INFO = -1 
      ELSE IF( .NOT.(LSAME(ORDER,'B').OR.LSAME(ORDER,'E')) ) THEN 
         INFO = -2 
      ELSE IF( N.LT.0 ) THEN 
         INFO = -3 
      ELSE IF( IRANGE.EQ.VALRNG ) THEN 
         IF( VL.GE.VU )                                                 &
     &      INFO = -5                                                   
      ELSE IF( IRANGE.EQ.INDRNG .AND.                                   &
     &        ( IL.LT.1 .OR. IL.GT.MAX( 1, N ) ) ) THEN                 
         INFO = -6 
      ELSE IF( IRANGE.EQ.INDRNG .AND.                                   &
     &        ( IU.LT.MIN( N, IL ) .OR. IU.GT.N ) ) THEN                
         INFO = -7 
      END IF 
!                                                                       
      IF( INFO.NE.0 ) THEN 
         RETURN 
      END IF 
                                                                        
!     Initialize error flags                                            
      INFO = 0 
      NCNVRG = .FALSE. 
      TOOFEW = .FALSE. 
                                                                        
!     Quick return if possible                                          
      M = 0 
      IF( N.EQ.0 ) RETURN 
                                                                        
!     Simplification:                                                   
      IF( IRANGE.EQ.INDRNG .AND. IL.EQ.1 .AND. IU.EQ.N ) IRANGE = 1 
                                                                        
!     Get machine constants                                             
      EPS = SLAMCH( 'P' ) 
      UFLOW = SLAMCH( 'U' ) 
                                                                        
                                                                        
!     Special Case when N=1                                             
!     Treat case of 1x1 matrix for quick return                         
      IF( N.EQ.1 ) THEN 
         IF( (IRANGE.EQ.ALLRNG).OR.                                     &
     &       ((IRANGE.EQ.VALRNG).AND.(D(1).GT.VL).AND.(D(1).LE.VU)).OR. &
     &       ((IRANGE.EQ.INDRNG).AND.(IL.EQ.1).AND.(IU.EQ.1)) ) THEN    
            M = 1 
            W(1) = D(1) 
!           The computation error of the eigenvalue is zero             
            WERR(1) = ZERO 
            IBLOCK( 1 ) = 1 
            INDEXW( 1 ) = 1 
         ENDIF 
         RETURN 
      END IF 
                                                                        
!     NB is the minimum vector length for vector bisection, or 0        
!     if only scalar is to be done.                                     
      NB = ILAENV( 1, 'SSTEBZ', ' ', N, -1, -1, -1 ) 
      IF( NB.LE.1 ) NB = 0 
                                                                        
!     Find global spectral radius                                       
      GL = D(1) 
      GU = D(1) 
      DO 5 I = 1,N 
         GL =  MIN( GL, GERS( 2*I - 1)) 
         GU = MAX( GU, GERS(2*I) ) 
    5 END DO 
!     Compute global Gerschgorin bounds and spectral diameter           
      TNORM = MAX( ABS( GL ), ABS( GU ) ) 
      GL = GL - FUDGE*TNORM*EPS*N - FUDGE*TWO*PIVMIN 
      GU = GU + FUDGE*TNORM*EPS*N + FUDGE*TWO*PIVMIN 
!     [JAN/28/2009] remove the line below since SPDIAM variable not use 
!     SPDIAM = GU - GL                                                  
!     Input arguments for SLAEBZ:                                       
!     The relative tolerance.  An interval (a,b] lies within            
!     "relative tolerance" if  b-a < RELTOL*max(|a|,|b|),               
      RTOLI = RELTOL 
!     Set the absolute tolerance for interval convergence to zero to for
!     interval convergence based on relative size of the interval.      
!     This is dangerous because intervals might not converge when RELTOL
!     small. But at least a very small number should be selected so that
!     strongly graded matrices, the code can get relatively accurate    
!     eigenvalues.                                                      
      ATOLI = FUDGE*TWO*UFLOW + FUDGE*TWO*PIVMIN 
                                                                        
      IF( IRANGE.EQ.INDRNG ) THEN 
                                                                        
!        RANGE='I': Compute an interval containing eigenvalues          
!        IL through IU. The initial interval [GL,GU] from the global    
!        Gerschgorin bounds GL and GU is refined by SLAEBZ.             
         ITMAX = INT( ( LOG( TNORM+PIVMIN )-LOG( PIVMIN ) ) /           &
     &           LOG( TWO ) ) + 2                                       
         WORK( N+1 ) = GL 
         WORK( N+2 ) = GL 
         WORK( N+3 ) = GU 
         WORK( N+4 ) = GU 
         WORK( N+5 ) = GL 
         WORK( N+6 ) = GU 
         IWORK( 1 ) = -1 
         IWORK( 2 ) = -1 
         IWORK( 3 ) = N + 1 
         IWORK( 4 ) = N + 1 
         IWORK( 5 ) = IL - 1 
         IWORK( 6 ) = IU 
!                                                                       
         CALL SLAEBZ( 3, ITMAX, N, 2, 2, NB, ATOLI, RTOLI, PIVMIN,      &
     &         D, E, E2, IWORK( 5 ), WORK( N+1 ), WORK( N+5 ), IOUT,    &
     &                IWORK, W, IBLOCK, IINFO )                         
         IF( IINFO .NE. 0 ) THEN 
            INFO = IINFO 
            RETURN 
         END IF 
!        On exit, output intervals may not be ordered by ascending negco
         IF( IWORK( 6 ).EQ.IU ) THEN 
            WL = WORK( N+1 ) 
            WLU = WORK( N+3 ) 
            NWL = IWORK( 1 ) 
            WU = WORK( N+4 ) 
            WUL = WORK( N+2 ) 
            NWU = IWORK( 4 ) 
         ELSE 
            WL = WORK( N+2 ) 
            WLU = WORK( N+4 ) 
            NWL = IWORK( 2 ) 
            WU = WORK( N+3 ) 
            WUL = WORK( N+1 ) 
            NWU = IWORK( 3 ) 
         END IF 
!        On exit, the interval [WL, WLU] contains a value with negcount 
!        and [WUL, WU] contains a value with negcount NWU.              
         IF( NWL.LT.0 .OR. NWL.GE.N .OR. NWU.LT.1 .OR. NWU.GT.N ) THEN 
            INFO = 4 
            RETURN 
         END IF 
                                                                        
      ELSEIF( IRANGE.EQ.VALRNG ) THEN 
         WL = VL 
         WU = VU 
                                                                        
      ELSEIF( IRANGE.EQ.ALLRNG ) THEN 
         WL = GL 
         WU = GU 
      ENDIF 
                                                                        
                                                                        
                                                                        
!     Find Eigenvalues -- Loop Over blocks and recompute NWL and NWU.   
!     NWL accumulates the number of eigenvalues .le. WL,                
!     NWU accumulates the number of eigenvalues .le. WU                 
      M = 0 
      IEND = 0 
      INFO = 0 
      NWL = 0 
      NWU = 0 
!                                                                       
      DO 70 JBLK = 1, NSPLIT 
         IOFF = IEND 
         IBEGIN = IOFF + 1 
         IEND = ISPLIT( JBLK ) 
         IN = IEND - IOFF 
!                                                                       
         IF( IN.EQ.1 ) THEN 
!           1x1 block                                                   
            IF( WL.GE.D( IBEGIN )-PIVMIN )                              &
     &         NWL = NWL + 1                                            
            IF( WU.GE.D( IBEGIN )-PIVMIN )                              &
     &         NWU = NWU + 1                                            
            IF( IRANGE.EQ.ALLRNG .OR.                                   &
     &           ( WL.LT.D( IBEGIN )-PIVMIN                             &
     &             .AND. WU.GE. D( IBEGIN )-PIVMIN ) ) THEN             
               M = M + 1 
               W( M ) = D( IBEGIN ) 
               WERR(M) = ZERO 
!              The gap for a single block doesn't matter for the later  
!              algorithm and is assigned an arbitrary large value       
               IBLOCK( M ) = JBLK 
               INDEXW( M ) = 1 
            END IF 
                                                                        
!        Disabled 2x2 case because of a failure on the following matrix 
!        RANGE = 'I', IL = IU = 4                                       
!          Original Tridiagonal, d = [                                  
!           -0.150102010615740E+00                                      
!           -0.849897989384260E+00                                      
!           -0.128208148052635E-15                                      
!            0.128257718286320E-15                                      
!          ];                                                           
!          e = [                                                        
!           -0.357171383266986E+00                                      
!           -0.180411241501588E-15                                      
!           -0.175152352710251E-15                                      
!          ];                                                           
!                                                                       
!         ELSE IF( IN.EQ.2 ) THEN                                       
!*           2x2 block                                                  
!            DISC = SQRT( (HALF*(D(IBEGIN)-D(IEND)))**2 + E(IBEGIN)**2 )
!            TMP1 = HALF*(D(IBEGIN)+D(IEND))                            
!            L1 = TMP1 - DISC                                           
!            IF( WL.GE. L1-PIVMIN )                                     
!     $         NWL = NWL + 1                                           
!            IF( WU.GE. L1-PIVMIN )                                     
!     $         NWU = NWU + 1                                           
!            IF( IRANGE.EQ.ALLRNG .OR. ( WL.LT.L1-PIVMIN .AND. WU.GE.   
!     $          L1-PIVMIN ) ) THEN                                     
!               M = M + 1                                               
!               W( M ) = L1                                             
!*              The uncertainty of eigenvalues of a 2x2 matrix is very s
!               WERR( M ) = EPS * ABS( W( M ) ) * TWO                   
!               IBLOCK( M ) = JBLK                                      
!               INDEXW( M ) = 1                                         
!            ENDIF                                                      
!            L2 = TMP1 + DISC                                           
!            IF( WL.GE. L2-PIVMIN )                                     
!     $         NWL = NWL + 1                                           
!            IF( WU.GE. L2-PIVMIN )                                     
!     $         NWU = NWU + 1                                           
!            IF( IRANGE.EQ.ALLRNG .OR. ( WL.LT.L2-PIVMIN .AND. WU.GE.   
!     $          L2-PIVMIN ) ) THEN                                     
!               M = M + 1                                               
!               W( M ) = L2                                             
!*              The uncertainty of eigenvalues of a 2x2 matrix is very s
!               WERR( M ) = EPS * ABS( W( M ) ) * TWO                   
!               IBLOCK( M ) = JBLK                                      
!               INDEXW( M ) = 2                                         
!            ENDIF                                                      
         ELSE 
!           General Case - block of size IN >= 2                        
!           Compute local Gerschgorin interval and use it as the initial
!           interval for SLAEBZ                                         
            GU = D( IBEGIN ) 
            GL = D( IBEGIN ) 
            TMP1 = ZERO 
                                                                        
            DO 40 J = IBEGIN, IEND 
               GL =  MIN( GL, GERS( 2*J - 1)) 
               GU = MAX( GU, GERS(2*J) ) 
   40       CONTINUE 
!           [JAN/28/2009]                                               
!           change SPDIAM by TNORM in lines 2 and 3 thereafter          
!           line 1: remove computation of SPDIAM (not useful anymore)   
!           SPDIAM = GU - GL                                            
!           GL = GL - FUDGE*SPDIAM*EPS*IN - FUDGE*PIVMIN                
!           GU = GU + FUDGE*SPDIAM*EPS*IN + FUDGE*PIVMIN                
            GL = GL - FUDGE*TNORM*EPS*IN - FUDGE*PIVMIN 
            GU = GU + FUDGE*TNORM*EPS*IN + FUDGE*PIVMIN 
!                                                                       
            IF( IRANGE.GT.1 ) THEN 
               IF( GU.LT.WL ) THEN 
!                 the local block contains none of the wanted eigenvalue
                  NWL = NWL + IN 
                  NWU = NWU + IN 
                  GO TO 70 
               END IF 
!              refine search interval if possible, only range (WL,WU] ma
               GL = MAX( GL, WL ) 
               GU = MIN( GU, WU ) 
               IF( GL.GE.GU )                                           &
     &            GO TO 70                                              
            END IF 
                                                                        
!           Find negcount of initial interval boundaries GL and GU      
            WORK( N+1 ) = GL 
            WORK( N+IN+1 ) = GU 
            CALL SLAEBZ( 1, 0, IN, IN, 1, NB, ATOLI, RTOLI, PIVMIN,     &
     &                   D( IBEGIN ), E( IBEGIN ), E2( IBEGIN ),        &
     &                   IDUMMA, WORK( N+1 ), WORK( N+2*IN+1 ), IM,     &
     &                   IWORK, W( M+1 ), IBLOCK( M+1 ), IINFO )        
            IF( IINFO .NE. 0 ) THEN 
               INFO = IINFO 
               RETURN 
            END IF 
!                                                                       
            NWL = NWL + IWORK( 1 ) 
            NWU = NWU + IWORK( IN+1 ) 
            IWOFF = M - IWORK( 1 ) 
                                                                        
!           Compute Eigenvalues                                         
            ITMAX = INT( ( LOG( GU-GL+PIVMIN )-LOG( PIVMIN ) ) /        &
     &              LOG( TWO ) ) + 2                                    
            CALL SLAEBZ( 2, ITMAX, IN, IN, 1, NB, ATOLI, RTOLI, PIVMIN, &
     &                   D( IBEGIN ), E( IBEGIN ), E2( IBEGIN ),        &
     &                   IDUMMA, WORK( N+1 ), WORK( N+2*IN+1 ), IOUT,   &
     &                   IWORK, W( M+1 ), IBLOCK( M+1 ), IINFO )        
            IF( IINFO .NE. 0 ) THEN 
               INFO = IINFO 
               RETURN 
            END IF 
!                                                                       
!           Copy eigenvalues into W and IBLOCK                          
!           Use -JBLK for block number for unconverged eigenvalues.     
!           Loop over the number of output intervals from SLAEBZ        
            DO 60 J = 1, IOUT 
!              eigenvalue approximation is middle point of interval     
               TMP1 = HALF*( WORK( J+N )+WORK( J+IN+N ) ) 
!              semi length of error interval                            
               TMP2 = HALF*ABS( WORK( J+N )-WORK( J+IN+N ) ) 
               IF( J.GT.IOUT-IINFO ) THEN 
!                 Flag non-convergence.                                 
                  NCNVRG = .TRUE. 
                  IB = -JBLK 
               ELSE 
                  IB = JBLK 
               END IF 
               DO 50 JE = IWORK( J ) + 1 + IWOFF,                       &
     &                 IWORK( J+IN ) + IWOFF                            
                  W( JE ) = TMP1 
                  WERR( JE ) = TMP2 
                  INDEXW( JE ) = JE - IWOFF 
                  IBLOCK( JE ) = IB 
   50          CONTINUE 
   60       CONTINUE 
!                                                                       
            M = M + IM 
         END IF 
   70 END DO 
                                                                        
!     If RANGE='I', then (WL,WU) contains eigenvalues NWL+1,...,NWU     
!     If NWL+1 < IL or NWU > IU, discard extra eigenvalues.             
      IF( IRANGE.EQ.INDRNG ) THEN 
         IDISCL = IL - 1 - NWL 
         IDISCU = NWU - IU 
!                                                                       
         IF( IDISCL.GT.0 ) THEN 
            IM = 0 
            DO 80 JE = 1, M 
!              Remove some of the smallest eigenvalues from the left so 
!              at the end IDISCL =0. Move all eigenvalues up to the left
               IF( W( JE ).LE.WLU .AND. IDISCL.GT.0 ) THEN 
                  IDISCL = IDISCL - 1 
               ELSE 
                  IM = IM + 1 
                  W( IM ) = W( JE ) 
                  WERR( IM ) = WERR( JE ) 
                  INDEXW( IM ) = INDEXW( JE ) 
                  IBLOCK( IM ) = IBLOCK( JE ) 
               END IF 
   80       CONTINUE 
            M = IM 
         END IF 
         IF( IDISCU.GT.0 ) THEN 
!           Remove some of the largest eigenvalues from the right so tha
!           at the end IDISCU =0. Move all eigenvalues up to the left.  
            IM=M+1 
            DO 81 JE = M, 1, -1 
               IF( W( JE ).GE.WUL .AND. IDISCU.GT.0 ) THEN 
                  IDISCU = IDISCU - 1 
               ELSE 
                  IM = IM - 1 
                  W( IM ) = W( JE ) 
                  WERR( IM ) = WERR( JE ) 
                  INDEXW( IM ) = INDEXW( JE ) 
                  IBLOCK( IM ) = IBLOCK( JE ) 
               END IF 
   81       CONTINUE 
            JEE = 0 
            DO 82 JE = IM, M 
               JEE = JEE + 1 
               W( JEE ) = W( JE ) 
               WERR( JEE ) = WERR( JE ) 
               INDEXW( JEE ) = INDEXW( JE ) 
               IBLOCK( JEE ) = IBLOCK( JE ) 
   82       CONTINUE 
            M = M-IM+1 
         END IF 
                                                                        
         IF( IDISCL.GT.0 .OR. IDISCU.GT.0 ) THEN 
!           Code to deal with effects of bad arithmetic. (If N(w) is    
!           monotone non-decreasing, this should never happen.)         
!           Some low eigenvalues to be discarded are not in (WL,WLU],   
!           or high eigenvalues to be discarded are not in (WUL,WU]     
!           so just kill off the smallest IDISCL/largest IDISCU         
!           eigenvalues, by marking the corresponding IBLOCK = 0        
            IF( IDISCL.GT.0 ) THEN 
               WKILL = WU 
               DO 100 JDISC = 1, IDISCL 
                  IW = 0 
                  DO 90 JE = 1, M 
                     IF( IBLOCK( JE ).NE.0 .AND.                        &
     &                    ( W( JE ).LT.WKILL .OR. IW.EQ.0 ) ) THEN      
                        IW = JE 
                        WKILL = W( JE ) 
                     END IF 
   90             CONTINUE 
                  IBLOCK( IW ) = 0 
  100          CONTINUE 
            END IF 
            IF( IDISCU.GT.0 ) THEN 
               WKILL = WL 
               DO 120 JDISC = 1, IDISCU 
                  IW = 0 
                  DO 110 JE = 1, M 
                     IF( IBLOCK( JE ).NE.0 .AND.                        &
     &                    ( W( JE ).GE.WKILL .OR. IW.EQ.0 ) ) THEN      
                        IW = JE 
                        WKILL = W( JE ) 
                     END IF 
  110             CONTINUE 
                  IBLOCK( IW ) = 0 
  120          CONTINUE 
            END IF 
!           Now erase all eigenvalues with IBLOCK set to zero           
            IM = 0 
            DO 130 JE = 1, M 
               IF( IBLOCK( JE ).NE.0 ) THEN 
                  IM = IM + 1 
                  W( IM ) = W( JE ) 
                  WERR( IM ) = WERR( JE ) 
                  INDEXW( IM ) = INDEXW( JE ) 
                  IBLOCK( IM ) = IBLOCK( JE ) 
               END IF 
  130       CONTINUE 
            M = IM 
         END IF 
         IF( IDISCL.LT.0 .OR. IDISCU.LT.0 ) THEN 
            TOOFEW = .TRUE. 
         END IF 
      END IF 
!                                                                       
      IF(( IRANGE.EQ.ALLRNG .AND. M.NE.N ).OR.                          &
     &   ( IRANGE.EQ.INDRNG .AND. M.NE.IU-IL+1 ) ) THEN                 
         TOOFEW = .TRUE. 
      END IF 
                                                                        
!     If ORDER='B', do nothing the eigenvalues are already sorted by    
!        block.                                                         
!     If ORDER='E', sort the eigenvalues from smallest to largest       
                                                                        
      IF( LSAME(ORDER,'E') .AND. NSPLIT.GT.1 ) THEN 
         DO 150 JE = 1, M - 1 
            IE = 0 
            TMP1 = W( JE ) 
            DO 140 J = JE + 1, M 
               IF( W( J ).LT.TMP1 ) THEN 
                  IE = J 
                  TMP1 = W( J ) 
               END IF 
  140       CONTINUE 
            IF( IE.NE.0 ) THEN 
               TMP2 = WERR( IE ) 
               ITMP1 = IBLOCK( IE ) 
               ITMP2 = INDEXW( IE ) 
               W( IE ) = W( JE ) 
               WERR( IE ) = WERR( JE ) 
               IBLOCK( IE ) = IBLOCK( JE ) 
               INDEXW( IE ) = INDEXW( JE ) 
               W( JE ) = TMP1 
               WERR( JE ) = TMP2 
               IBLOCK( JE ) = ITMP1 
               INDEXW( JE ) = ITMP2 
            END IF 
  150    CONTINUE 
      END IF 
!                                                                       
      INFO = 0 
      IF( NCNVRG )                                                      &
     &   INFO = INFO + 1                                                
      IF( TOOFEW )                                                      &
     &   INFO = INFO + 2                                                
      RETURN 
!                                                                       
!     End of SLARRD                                                     
!                                                                       
!> \brief \b SLARRE given the tridiagonal matrix T, sets small off-diago
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLARRE + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SLARRE( RANGE, N, VL, VU, IL, IU, D, E, E2,          
!                           RTOL1, RTOL2, SPLTOL, NSPLIT, ISPLIT, M,    
!                           W, WERR, WGAP, IBLOCK, INDEXW, GERS, PIVMIN,
!                           WORK, IWORK, INFO )                         
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          RANGE                                        
!       INTEGER            IL, INFO, IU, M, N, NSPLIT                   
!       REAL               PIVMIN, RTOL1, RTOL2, SPLTOL, VL, VU         
!       ..                                                              
!       .. Array Arguments ..                                           
!       INTEGER            IBLOCK( * ), ISPLIT( * ), IWORK( * ),        
!      $                   INDEXW( * )                                  
!       REAL               D( * ), E( * ), E2( * ), GERS( * ),          
!      $                   W( * ),WERR( * ), WGAP( * ), WORK( * )       
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> To find the desired eigenvalues of a given real symmetric            
!> tridiagonal matrix T, SLARRE sets any "small" off-diagonal           
!> elements to zero, and for each unreduced block T_i, it finds         
!> (a) a suitable shift at one end of the block's spectrum,             
!> (b) the base representation, T_i - sigma_i I = L_i D_i L_i^T, and    
!> (c) eigenvalues of each L_i D_i L_i^T.                               
!> The representations and eigenvalues found are then used by           
!> SSTEMR to compute the eigenvectors of T.                             
!> The accuracy varies depending on whether bisection is used to        
!> find a few eigenvalues or the dqds algorithm (subroutine SLASQ2) to  
!> conpute all and then discard any unwanted one.                       
!> As an added benefit, SLARRE also outputs the n                       
!> Gerschgorin intervals for the matrices L_i D_i L_i^T.                
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] RANGE                                                     
!> \verbatim                                                            
!>          RANGE is CHARACTER*1                                        
!>          = 'A': ("All")   all eigenvalues will be found.             
!>          = 'V': ("Value") all eigenvalues in the half-open interval  
!>                           (VL, VU] will be found.                    
!>          = 'I': ("Index") the IL-th through IU-th eigenvalues (of the
!>                           entire matrix) will be found.              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix. N > 0.                             
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] VL                                                    
!> \verbatim                                                            
!>          VL is REAL                                                  
!>          If RANGE='V', the lower bound for the eigenvalues.          
!>          Eigenvalues less than or equal to VL, or greater than VU,   
!>          will not be returned.  VL < VU.                             
!>          If RANGE='I' or ='A', SLARRE computes bounds on the desired 
!>          part of the spectrum.                                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] VU                                                    
!> \verbatim                                                            
!>          VU is REAL                                                  
!>          If RANGE='V', the upper bound for the eigenvalues.          
!>          Eigenvalues less than or equal to VL, or greater than VU,   
!>          will not be returned.  VL < VU.                             
!>          If RANGE='I' or ='A', SLARRE computes bounds on the desired 
!>          part of the spectrum.                                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IL                                                        
!> \verbatim                                                            
!>          IL is INTEGER                                               
!>          If RANGE='I', the index of the                              
!>          smallest eigenvalue to be returned.                         
!>          1 <= IL <= IU <= N.                                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IU                                                        
!> \verbatim                                                            
!>          IU is INTEGER                                               
!>          If RANGE='I', the index of the                              
!>          largest eigenvalue to be returned.                          
!>          1 <= IL <= IU <= N.                                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] D                                                     
!> \verbatim                                                            
!>          D is REAL array, dimension (N)                              
!>          On entry, the N diagonal elements of the tridiagonal        
!>          matrix T.                                                   
!>          On exit, the N diagonal elements of the diagonal            
!>          matrices D_i.                                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] E                                                     
!> \verbatim                                                            
!>          E is REAL array, dimension (N)                              
!>          On entry, the first (N-1) entries contain the subdiagonal   
!>          elements of the tridiagonal matrix T; E(N) need not be set. 
!>          On exit, E contains the subdiagonal elements of the unit    
!>          bidiagonal matrices L_i. The entries E( ISPLIT( I ) ),      
!>          1 <= I <= NSPLIT, contain the base points sigma_i on output.
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] E2                                                    
!> \verbatim                                                            
!>          E2 is REAL array, dimension (N)                             
!>          On entry, the first (N-1) entries contain the SQUARES of the
!>          subdiagonal elements of the tridiagonal matrix T;           
!>          E2(N) need not be set.                                      
!>          On exit, the entries E2( ISPLIT( I ) ),                     
!>          1 <= I <= NSPLIT, have been set to zero                     
!> \endverbatim                                                         
!>                                                                      
!> \param[in] RTOL1                                                     
!> \verbatim                                                            
!>          RTOL1 is REAL                                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] RTOL2                                                     
!> \verbatim                                                            
!>          RTOL2 is REAL                                               
!>           Parameters for bisection.                                  
!>           An interval [LEFT,RIGHT] has converged if                  
!>           RIGHT-LEFT < MAX( RTOL1*GAP, RTOL2*MAX(|LEFT|,|RIGHT|) )   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] SPLTOL                                                    
!> \verbatim                                                            
!>          SPLTOL is REAL                                              
!>          The threshold for splitting.                                
!> \endverbatim                                                         
!>                                                                      
!> \param[out] NSPLIT                                                   
!> \verbatim                                                            
!>          NSPLIT is INTEGER                                           
!>          The number of blocks T splits into. 1 <= NSPLIT <= N.       
!> \endverbatim                                                         
!>                                                                      
!> \param[out] ISPLIT                                                   
!> \verbatim                                                            
!>          ISPLIT is INTEGER array, dimension (N)                      
!>          The splitting points, at which T breaks up into blocks.     
!>          The first block consists of rows/columns 1 to ISPLIT(1),    
!>          the second of rows/columns ISPLIT(1)+1 through ISPLIT(2),   
!>          etc., and the NSPLIT-th consists of rows/columns            
!>          ISPLIT(NSPLIT-1)+1 through ISPLIT(NSPLIT)=N.                
!> \endverbatim                                                         
!>                                                                      
!> \param[out] M                                                        
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The total number of eigenvalues (of all L_i D_i L_i^T)      
!>          found.                                                      
!> \endverbatim                                                         
!>                                                                      
!> \param[out] W                                                        
!> \verbatim                                                            
!>          W is REAL array, dimension (N)                              
!>          The first M elements contain the eigenvalues. The           
!>          eigenvalues of each of the blocks, L_i D_i L_i^T, are       
!>          sorted in ascending order ( SLARRE may use the              
!>          remaining N-M elements as workspace).                       
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WERR                                                     
!> \verbatim                                                            
!>          WERR is REAL array, dimension (N)                           
!>          The error bound on the corresponding eigenvalue in W.       
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WGAP                                                     
!> \verbatim                                                            
      END                                           
!>          WGAP is REAL array, dimension (N)                           
!>          The separation from the right neighbor eigenvalue in W.     
!>          The gap is only with respect to the eigenvalues of the same 
!>          as each block has its own representation tree.              
!>          Exception: at the right end of a block we store the left gap
!> \endverbatim                                                         
!>                                                                      
!> \param[out] IBLOCK                                                   
!> \verbatim                                                            
!>          IBLOCK is INTEGER array, dimension (N)                      
!>          The indices of the blocks (submatrices) associated with the 
!>          corresponding eigenvalues in W; IBLOCK(i)=1 if eigenvalue   
!>          W(i) belongs to the first block from the top, =2 if W(i)    
!>          belongs to the second block, etc.                           
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INDEXW                                                   
!> \verbatim                                                            
!>          INDEXW is INTEGER array, dimension (N)                      
!>          The indices of the eigenvalues within each block (submatrix)
!>          for example, INDEXW(i)= 10 and IBLOCK(i)=2 imply that the   
!>          i-th eigenvalue W(i) is the 10-th eigenvalue in block 2     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] GERS                                                     
!> \verbatim                                                            
!>          GERS is REAL array, dimension (2*N)                         
!>          The N Gerschgorin intervals (the i-th Gerschgorin interval  
!>          is (GERS(2*i-1), GERS(2*i)).                                
!> \endverbatim                                                         
!>                                                                      
!> \param[out] PIVMIN                                                   
!> \verbatim                                                            
!>          PIVMIN is REAL                                              
!>          The minimum pivot in the Sturm sequence for T.              
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is REAL array, dimension (6*N)                         
!>          Workspace.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[out] IWORK                                                    
!> \verbatim                                                            
!>          IWORK is INTEGER array, dimension (5*N)                     
!>          Workspace.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0:  successful exit                                       
!>          > 0:  A problem occurred in SLARRE.                         
!>          < 0:  One of the called subroutines signaled an internal pro
!>                Needs inspection of the corresponding parameter IINFO 
!>                for further information.                              
!>                                                                      
!>          =-1:  Problem in SLARRD.                                    
!>          = 2:  No base representation could be found in MAXTRY iterat
!>                Increasing MAXTRY and recompilation might be a remedy.
!>          =-3:  Problem in SLARRB when computing the refined root     
!>                representation for SLASQ2.                            
!>          =-4:  Problem in SLARRB when preforming bisection on the    
!>                desired part of the spectrum.                         
!>          =-5:  Problem in SLASQ2.                                    
!>          =-6:  Problem in SLASQ2.                                    
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2016                                                      
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  The base representations are required to suffer very little         
!>  element growth and consequently define all their eigenvalues to     
!>  high relative accuracy.                                             
!> \endverbatim                                                         
!                                                                       
!> \par Contributors:                                                   
!  ==================                                                   
!>                                                                      
!>     Beresford Parlett, University of California, Berkeley, USA \n    
!>     Jim Demmel, University of California, Berkeley, USA \n           
!>     Inderjit Dhillon, University of Texas, Austin, USA \n            
!>     Osni Marques, LBNL/NERSC, USA \n                                 
!>     Christof Voemel, University of California, Berkeley, USA \n      
!>                                                                      
!  =====================================================================
      SUBROUTINE SLARRE( RANGE, N, VL, VU, IL, IU, D, E, E2,            &
     &                    RTOL1, RTOL2, SPLTOL, NSPLIT, ISPLIT, M,      &
     &                    W, WERR, WGAP, IBLOCK, INDEXW, GERS, PIVMIN,  &
     &                    WORK, IWORK, INFO )                           
!                                                                       
!  -- LAPACK auxiliary routine (version 3.8.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2016                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          RANGE 
      INTEGER            IL, INFO, IU, M, N, NSPLIT 
      REAL               PIVMIN, RTOL1, RTOL2, SPLTOL, VL, VU 
!     ..                                                                
!     .. Array Arguments ..                                             
      INTEGER            IBLOCK( * ), ISPLIT( * ), IWORK( * ),          &
     &                   INDEXW( * )                                    
      REAL               D( * ), E( * ), E2( * ), GERS( * ),            &
     &                   W( * ),WERR( * ), WGAP( * ), WORK( * )         
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               FAC, FOUR, FOURTH, FUDGE, HALF, HNDRD,         &
     &                   MAXGROWTH, ONE, PERT, TWO, ZERO                
      PARAMETER          ( ZERO = 0.0E0, ONE = 1.0E0,                   &
     &                     TWO = 2.0E0, FOUR=4.0E0,                     &
     &                     HNDRD = 100.0E0,                             &
     &                     PERT = 4.0E0,                                &
     &                     HALF = ONE/TWO, FOURTH = ONE/FOUR, FAC= HALF,&
     &                     MAXGROWTH = 64.0E0, FUDGE = 2.0E0 )          
      INTEGER            MAXTRY, ALLRNG, INDRNG, VALRNG 
      PARAMETER          ( MAXTRY = 6, ALLRNG = 1, INDRNG = 2,          &
     &                     VALRNG = 3 )                                 
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            FORCEB, NOREP, USEDQD 
      INTEGER            CNT, CNT1, CNT2, I, IBEGIN, IDUM, IEND, IINFO, &
     &                   IN, INDL, INDU, IRANGE, J, JBLK, MB, MM,       &
     &                   WBEGIN, WEND                                   
      REAL               AVGAP, BSRTOL, CLWDTH, DMAX, DPIVOT, EABS,     &
     &                   EMAX, EOLD, EPS, GL, GU, ISLEFT, ISRGHT, RTL,  &
     &                   RTOL, S1, S2, SAFMIN, SGNDEF, SIGMA, SPDIAM,   &
     &                   TAU, TMP, TMP1                                 
                                                                        
                                                                        
!     ..                                                                
!     .. Local Arrays ..                                                
      INTEGER            ISEED( 4 ) 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      REAL                        SLAMCH 
      EXTERNAL           SLAMCH, LSAME 
                                                                        
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           SCOPY, SLARNV, SLARRA, SLARRB, SLARRC, SLARRD, &
     &                   SLASQ2, SLARRK                                 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, MAX, MIN 
                                                                        
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
                                                                        
      INFO = 0 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.LE.0 ) THEN 
         RETURN 
      END IF 
!                                                                       
!     Decode RANGE                                                      
!                                                                       
      IF( LSAME( RANGE, 'A' ) ) THEN 
         IRANGE = ALLRNG 
      ELSE IF( LSAME( RANGE, 'V' ) ) THEN 
         IRANGE = VALRNG 
      ELSE IF( LSAME( RANGE, 'I' ) ) THEN 
         IRANGE = INDRNG 
      END IF 
                                                                        
      M = 0 
                                                                        
!     Get machine constants                                             
      SAFMIN = SLAMCH( 'S' ) 
      EPS = SLAMCH( 'P' ) 
                                                                        
!     Set parameters                                                    
      RTL = HNDRD*EPS 
!     If one were ever to ask for less initial precision in BSRTOL,     
!     one should keep in mind that for the subset case, the extremal    
!     eigenvalues must be at least as accurate as the current setting   
!     (eigenvalues in the middle need not as much accuracy)             
      BSRTOL = SQRT(EPS)*(0.5E-3) 
                                                                        
!     Treat case of 1x1 matrix for quick return                         
      IF( N.EQ.1 ) THEN 
         IF( (IRANGE.EQ.ALLRNG).OR.                                     &
     &       ((IRANGE.EQ.VALRNG).AND.(D(1).GT.VL).AND.(D(1).LE.VU)).OR. &
     &       ((IRANGE.EQ.INDRNG).AND.(IL.EQ.1).AND.(IU.EQ.1)) ) THEN    
            M = 1 
            W(1) = D(1) 
!           The computation error of the eigenvalue is zero             
            WERR(1) = ZERO 
            WGAP(1) = ZERO 
            IBLOCK( 1 ) = 1 
            INDEXW( 1 ) = 1 
            GERS(1) = D( 1 ) 
            GERS(2) = D( 1 ) 
         ENDIF 
!        store the shift for the initial RRR, which is zero in this case
         E(1) = ZERO 
         RETURN 
      END IF 
                                                                        
!     General case: tridiagonal matrix of order > 1                     
!                                                                       
!     Init WERR, WGAP. Compute Gerschgorin intervals and spectral diamet
!     Compute maximum off-diagonal entry and pivmin.                    
      GL = D(1) 
      GU = D(1) 
      EOLD = ZERO 
      EMAX = ZERO 
      E(N) = ZERO 
      DO 5 I = 1,N 
         WERR(I) = ZERO 
         WGAP(I) = ZERO 
         EABS = ABS( E(I) ) 
         IF( EABS .GE. EMAX ) THEN 
            EMAX = EABS 
         END IF 
         TMP1 = EABS + EOLD 
         GERS( 2*I-1) = D(I) - TMP1 
         GL =  MIN( GL, GERS( 2*I - 1)) 
         GERS( 2*I ) = D(I) + TMP1 
         GU = MAX( GU, GERS(2*I) ) 
         EOLD  = EABS 
    5 END DO 
!     The minimum pivot allowed in the Sturm sequence for T             
      PIVMIN = SAFMIN * MAX( ONE, EMAX**2 ) 
!     Compute spectral diameter. The Gerschgorin bounds give an         
!     estimate that is wrong by at most a factor of SQRT(2)             
      SPDIAM = GU - GL 
                                                                        
!     Compute splitting points                                          
      CALL SLARRA( N, D, E, E2, SPLTOL, SPDIAM,                         &
     &                    NSPLIT, ISPLIT, IINFO )                       
                                                                        
!     Can force use of bisection instead of faster DQDS.                
!     Option left in the code for future multisection work.             
      FORCEB = .FALSE. 
                                                                        
!     Initialize USEDQD, DQDS should be used for ALLRNG unless someone  
!     explicitly wants bisection.                                       
      USEDQD = (( IRANGE.EQ.ALLRNG ) .AND. (.NOT.FORCEB)) 
                                                                        
      IF( (IRANGE.EQ.ALLRNG) .AND. (.NOT. FORCEB) ) THEN 
!        Set interval [VL,VU] that contains all eigenvalues             
         VL = GL 
         VU = GU 
      ELSE 
!        We call SLARRD to find crude approximations to the eigenvalues 
!        in the desired range. In case IRANGE = INDRNG, we also obtain t
!        interval (VL,VU] that contains all the wanted eigenvalues.     
!        An interval [LEFT,RIGHT] has converged if                      
!        RIGHT-LEFT.LT.RTOL*MAX(ABS(LEFT),ABS(RIGHT))                   
!        SLARRD needs a WORK of size 4*N, IWORK of size 3*N             
         CALL SLARRD( RANGE, 'B', N, VL, VU, IL, IU, GERS,              &
     &                    BSRTOL, D, E, E2, PIVMIN, NSPLIT, ISPLIT,     &
     &                    MM, W, WERR, VL, VU, IBLOCK, INDEXW,          &
     &                    WORK, IWORK, IINFO )                          
         IF( IINFO.NE.0 ) THEN 
            INFO = -1 
            RETURN 
         ENDIF 
!        Make sure that the entries M+1 to N in W, WERR, IBLOCK, INDEXW 
         DO 14 I = MM+1,N 
            W( I ) = ZERO 
            WERR( I ) = ZERO 
            IBLOCK( I ) = 0 
            INDEXW( I ) = 0 
   14    CONTINUE 
      END IF 
                                                                        
                                                                        
!**                                                                     
!     Loop over unreduced blocks                                        
      IBEGIN = 1 
      WBEGIN = 1 
      DO 170 JBLK = 1, NSPLIT 
         IEND = ISPLIT( JBLK ) 
         IN = IEND - IBEGIN + 1 
                                                                        
!        1 X 1 block                                                    
         IF( IN.EQ.1 ) THEN 
            IF( (IRANGE.EQ.ALLRNG).OR.( (IRANGE.EQ.VALRNG).AND.         &
     &         ( D( IBEGIN ).GT.VL ).AND.( D( IBEGIN ).LE.VU ) )        &
     &        .OR. ( (IRANGE.EQ.INDRNG).AND.(IBLOCK(WBEGIN).EQ.JBLK))   &
     &        ) THEN                                                    
               M = M + 1 
               W( M ) = D( IBEGIN ) 
               WERR(M) = ZERO 
!              The gap for a single block doesn't matter for the later  
!              algorithm and is assigned an arbitrary large value       
               WGAP(M) = ZERO 
               IBLOCK( M ) = JBLK 
               INDEXW( M ) = 1 
               WBEGIN = WBEGIN + 1 
            ENDIF 
!           E( IEND ) holds the shift for the initial RRR               
            E( IEND ) = ZERO 
            IBEGIN = IEND + 1 
            GO TO 170 
         END IF 
!                                                                       
!        Blocks of size larger than 1x1                                 
!                                                                       
!        E( IEND ) will hold the shift for the initial RRR, for now set 
         E( IEND ) = ZERO 
!                                                                       
!        Find local outer bounds GL,GU for the block                    
         GL = D(IBEGIN) 
         GU = D(IBEGIN) 
         DO 15 I = IBEGIN , IEND 
            GL = MIN( GERS( 2*I-1 ), GL ) 
            GU = MAX( GERS( 2*I ), GU ) 
   15    CONTINUE 
         SPDIAM = GU - GL 
                                                                        
         IF(.NOT. ((IRANGE.EQ.ALLRNG).AND.(.NOT.FORCEB)) ) THEN 
!           Count the number of eigenvalues in the current block.       
            MB = 0 
            DO 20 I = WBEGIN,MM 
               IF( IBLOCK(I).EQ.JBLK ) THEN 
                  MB = MB+1 
               ELSE 
                  GOTO 21 
               ENDIF 
   20       CONTINUE 
   21       CONTINUE 
                                                                        
            IF( MB.EQ.0) THEN 
!              No eigenvalue in the current block lies in the desired ra
!              E( IEND ) holds the shift for the initial RRR            
               E( IEND ) = ZERO 
               IBEGIN = IEND + 1 
               GO TO 170 
            ELSE 
                                                                        
!              Decide whether dqds or bisection is more efficient       
               USEDQD = ( (MB .GT. FAC*IN) .AND. (.NOT.FORCEB) ) 
               WEND = WBEGIN + MB - 1 
!              Calculate gaps for the current block                     
!              In later stages, when representations for individual     
!              eigenvalues are different, we use SIGMA = E( IEND ).     
               SIGMA = ZERO 
               DO 30 I = WBEGIN, WEND - 1 
                  WGAP( I ) = MAX( ZERO,                                &
     &                        W(I+1)-WERR(I+1) - (W(I)+WERR(I)) )       
   30          CONTINUE 
               WGAP( WEND ) = MAX( ZERO,                                &
     &                     VU - SIGMA - (W( WEND )+WERR( WEND )))       
!              Find local index of the first and last desired evalue.   
               INDL = INDEXW(WBEGIN) 
               INDU = INDEXW( WEND ) 
            ENDIF 
         ENDIF 
         IF(( (IRANGE.EQ.ALLRNG) .AND. (.NOT. FORCEB) ).OR.USEDQD) THEN 
!           Case of DQDS                                                
!           Find approximations to the extremal eigenvalues of the block
            CALL SLARRK( IN, 1, GL, GU, D(IBEGIN),                      &
     &               E2(IBEGIN), PIVMIN, RTL, TMP, TMP1, IINFO )        
            IF( IINFO.NE.0 ) THEN 
               INFO = -1 
               RETURN 
            ENDIF 
            ISLEFT = MAX(GL, TMP - TMP1                                 &
     &               - HNDRD * EPS* ABS(TMP - TMP1))                    
                                                                        
            CALL SLARRK( IN, IN, GL, GU, D(IBEGIN),                     &
     &               E2(IBEGIN), PIVMIN, RTL, TMP, TMP1, IINFO )        
            IF( IINFO.NE.0 ) THEN 
               INFO = -1 
               RETURN 
            ENDIF 
            ISRGHT = MIN(GU, TMP + TMP1                                 &
     &                 + HNDRD * EPS * ABS(TMP + TMP1))                 
!           Improve the estimate of the spectral diameter               
            SPDIAM = ISRGHT - ISLEFT 
         ELSE 
!           Case of bisection                                           
!           Find approximations to the wanted extremal eigenvalues      
            ISLEFT = MAX(GL, W(WBEGIN) - WERR(WBEGIN)                   &
     &                  - HNDRD * EPS*ABS(W(WBEGIN)- WERR(WBEGIN) ))    
            ISRGHT = MIN(GU,W(WEND) + WERR(WEND)                        &
     &                  + HNDRD * EPS * ABS(W(WEND)+ WERR(WEND)))       
         ENDIF 
                                                                        
                                                                        
!        Decide whether the base representation for the current block   
!        L_JBLK D_JBLK L_JBLK^T = T_JBLK - sigma_JBLK I                 
!        should be on the left or the right end of the current block.   
!        The strategy is to shift to the end which is "more populated"  
!        Furthermore, decide whether to use DQDS for the computation of 
!        the eigenvalue approximations at the end of SLARRE or bisection
!        dqds is chosen if all eigenvalues are desired or the number of 
!        eigenvalues to be computed is large compared to the blocksize. 
         IF( ( IRANGE.EQ.ALLRNG ) .AND. (.NOT.FORCEB) ) THEN 
!           If all the eigenvalues have to be computed, we use dqd      
            USEDQD = .TRUE. 
!           INDL is the local index of the first eigenvalue to compute  
            INDL = 1 
            INDU = IN 
!           MB =  number of eigenvalues to compute                      
            MB = IN 
            WEND = WBEGIN + MB - 1 
!           Define 1/4 and 3/4 points of the spectrum                   
            S1 = ISLEFT + FOURTH * SPDIAM 
            S2 = ISRGHT - FOURTH * SPDIAM 
         ELSE 
!           SLARRD has computed IBLOCK and INDEXW for each eigenvalue   
!           approximation.                                              
!           choose sigma                                                
            IF( USEDQD ) THEN 
               S1 = ISLEFT + FOURTH * SPDIAM 
               S2 = ISRGHT - FOURTH * SPDIAM 
            ELSE 
               TMP = MIN(ISRGHT,VU) -  MAX(ISLEFT,VL) 
               S1 =  MAX(ISLEFT,VL) + FOURTH * TMP 
               S2 =  MIN(ISRGHT,VU) - FOURTH * TMP 
            ENDIF 
         ENDIF 
                                                                        
!        Compute the negcount at the 1/4 and 3/4 points                 
         IF(MB.GT.1) THEN 
            CALL SLARRC( 'T', IN, S1, S2, D(IBEGIN),                    &
     &                    E(IBEGIN), PIVMIN, CNT, CNT1, CNT2, IINFO)    
         ENDIF 
                                                                        
         IF(MB.EQ.1) THEN 
            SIGMA = GL 
            SGNDEF = ONE 
         ELSEIF( CNT1 - INDL .GE. INDU - CNT2 ) THEN 
            IF( ( IRANGE.EQ.ALLRNG ) .AND. (.NOT.FORCEB) ) THEN 
               SIGMA = MAX(ISLEFT,GL) 
            ELSEIF( USEDQD ) THEN 
!              use Gerschgorin bound as shift to get pos def matrix     
!              for dqds                                                 
               SIGMA = ISLEFT 
            ELSE 
!              use approximation of the first desired eigenvalue of the 
!              block as shift                                           
               SIGMA = MAX(ISLEFT,VL) 
            ENDIF 
            SGNDEF = ONE 
         ELSE 
            IF( ( IRANGE.EQ.ALLRNG ) .AND. (.NOT.FORCEB) ) THEN 
               SIGMA = MIN(ISRGHT,GU) 
            ELSEIF( USEDQD ) THEN 
!              use Gerschgorin bound as shift to get neg def matrix     
!              for dqds                                                 
               SIGMA = ISRGHT 
            ELSE 
!              use approximation of the first desired eigenvalue of the 
!              block as shift                                           
               SIGMA = MIN(ISRGHT,VU) 
            ENDIF 
            SGNDEF = -ONE 
         ENDIF 
                                                                        
                                                                        
!        An initial SIGMA has been chosen that will be used for computin
!        T - SIGMA I = L D L^T                                          
!        Define the increment TAU of the shift in case the initial shift
!        needs to be refined to obtain a factorization with not too much
!        element growth.                                                
         IF( USEDQD ) THEN 
!           The initial SIGMA was to the outer end of the spectrum      
!           the matrix is definite and we need not retreat.             
            TAU = SPDIAM*EPS*N + TWO*PIVMIN 
            TAU = MAX( TAU,TWO*EPS*ABS(SIGMA) ) 
         ELSE 
            IF(MB.GT.1) THEN 
               CLWDTH = W(WEND) + WERR(WEND) - W(WBEGIN) - WERR(WBEGIN) 
               AVGAP = ABS(CLWDTH / REAL(WEND-WBEGIN)) 
               IF( SGNDEF.EQ.ONE ) THEN 
                  TAU = HALF*MAX(WGAP(WBEGIN),AVGAP) 
                  TAU = MAX(TAU,WERR(WBEGIN)) 
               ELSE 
                  TAU = HALF*MAX(WGAP(WEND-1),AVGAP) 
                  TAU = MAX(TAU,WERR(WEND)) 
               ENDIF 
            ELSE 
               TAU = WERR(WBEGIN) 
            ENDIF 
         ENDIF 
!                                                                       
         DO 80 IDUM = 1, MAXTRY 
!           Compute L D L^T factorization of tridiagonal matrix T - sigm
!           Store D in WORK(1:IN), L in WORK(IN+1:2*IN), and reciprocals
!           pivots in WORK(2*IN+1:3*IN)                                 
            DPIVOT = D( IBEGIN ) - SIGMA 
            WORK( 1 ) = DPIVOT 
            DMAX = ABS( WORK(1) ) 
            J = IBEGIN 
            DO 70 I = 1, IN - 1 
               WORK( 2*IN+I ) = ONE / WORK( I ) 
               TMP = E( J )*WORK( 2*IN+I ) 
               WORK( IN+I ) = TMP 
               DPIVOT = ( D( J+1 )-SIGMA ) - TMP*E( J ) 
               WORK( I+1 ) = DPIVOT 
               DMAX = MAX( DMAX, ABS(DPIVOT) ) 
               J = J + 1 
   70       CONTINUE 
!           check for element growth                                    
            IF( DMAX .GT. MAXGROWTH*SPDIAM ) THEN 
               NOREP = .TRUE. 
            ELSE 
               NOREP = .FALSE. 
            ENDIF 
            IF( USEDQD .AND. .NOT.NOREP ) THEN 
!              Ensure the definiteness of the representation            
!              All entries of D (of L D L^T) must have the same sign    
               DO 71 I = 1, IN 
                  TMP = SGNDEF*WORK( I ) 
                  IF( TMP.LT.ZERO ) NOREP = .TRUE. 
   71          CONTINUE 
            ENDIF 
            IF(NOREP) THEN 
!              Note that in the case of IRANGE=ALLRNG, we use the Gersch
!              shift which makes the matrix definite. So we should end u
!              here really only in the case of IRANGE = VALRNG or INDRNG
               IF( IDUM.EQ.MAXTRY-1 ) THEN 
                  IF( SGNDEF.EQ.ONE ) THEN 
!                    The fudged Gerschgorin shift should succeed        
                     SIGMA =                                            &
     &                    GL - FUDGE*SPDIAM*EPS*N - FUDGE*TWO*PIVMIN    
                  ELSE 
                     SIGMA =                                            &
     &                    GU + FUDGE*SPDIAM*EPS*N + FUDGE*TWO*PIVMIN    
                  END IF 
               ELSE 
                  SIGMA = SIGMA - SGNDEF * TAU 
                  TAU = TWO * TAU 
               END IF 
            ELSE 
!              an initial RRR is found                                  
               GO TO 83 
            END IF 
   80    CONTINUE 
!        if the program reaches this point, no base representation could
!        found in MAXTRY iterations.                                    
         INFO = 2 
         RETURN 
                                                                        
   83    CONTINUE 
!        At this point, we have found an initial base representation    
!        T - SIGMA I = L D L^T with not too much element growth.        
!        Store the shift.                                               
         E( IEND ) = SIGMA 
!        Store D and L.                                                 
         CALL SCOPY( IN, WORK, 1, D( IBEGIN ), 1 ) 
         CALL SCOPY( IN-1, WORK( IN+1 ), 1, E( IBEGIN ), 1 ) 
                                                                        
                                                                        
         IF(MB.GT.1 ) THEN 
!                                                                       
!           Perturb each entry of the base representation by a small    
!           (but random) relative amount to overcome difficulties with  
!           glued matrices.                                             
!                                                                       
            DO 122 I = 1, 4 
               ISEED( I ) = 1 
  122       CONTINUE 
                                                                        
            CALL SLARNV(2, ISEED, 2*IN-1, WORK(1)) 
            DO 125 I = 1,IN-1 
               D(IBEGIN+I-1) = D(IBEGIN+I-1)*(ONE+EPS*PERT*WORK(I)) 
               E(IBEGIN+I-1) = E(IBEGIN+I-1)*(ONE+EPS*PERT*WORK(IN+I)) 
  125       CONTINUE 
            D(IEND) = D(IEND)*(ONE+EPS*FOUR*WORK(IN)) 
!                                                                       
         ENDIF 
!                                                                       
!        Don't update the Gerschgorin intervals because keeping track   
!        of the updates would be too much work in SLARRV.               
!        We update W instead and use it to locate the proper Gerschgorin
!        intervals.                                                     
                                                                        
!        Compute the required eigenvalues of L D L' by bisection or dqds
         IF ( .NOT.USEDQD ) THEN 
!           If SLARRD has been used, shift the eigenvalue approximations
!           according to their representation. This is necessary for    
!           a uniform SLARRV since dqds computes eigenvalues of the     
!           shifted representation. In SLARRV, W will always hold the   
!           UNshifted eigenvalue approximation.                         
            DO 134 J=WBEGIN,WEND 
               W(J) = W(J) - SIGMA 
               WERR(J) = WERR(J) + ABS(W(J)) * EPS 
  134       CONTINUE 
!           call SLARRB to reduce eigenvalue error of the approximations
!           from SLARRD                                                 
            DO 135 I = IBEGIN, IEND-1 
               WORK( I ) = D( I ) * E( I )**2 
  135       CONTINUE 
!           use bisection to find EV from INDL to INDU                  
            CALL SLARRB(IN, D(IBEGIN), WORK(IBEGIN),                    &
     &                  INDL, INDU, RTOL1, RTOL2, INDL-1,               &
     &                  W(WBEGIN), WGAP(WBEGIN), WERR(WBEGIN),          &
     &                  WORK( 2*N+1 ), IWORK, PIVMIN, SPDIAM,           &
     &                  IN, IINFO )                                     
            IF( IINFO .NE. 0 ) THEN 
               INFO = -4 
               RETURN 
            END IF 
!           SLARRB computes all gaps correctly except for the last one  
!           Record distance to VU/GU                                    
            WGAP( WEND ) = MAX( ZERO,                                   &
     &           ( VU-SIGMA ) - ( W( WEND ) + WERR( WEND ) ) )          
            DO 138 I = INDL, INDU 
               M = M + 1 
               IBLOCK(M) = JBLK 
               INDEXW(M) = I 
  138       CONTINUE 
         ELSE 
!           Call dqds to get all eigs (and then possibly delete unwanted
!           eigenvalues).                                               
!           Note that dqds finds the eigenvalues of the L D L^T represen
!           of T to high relative accuracy. High relative accuracy      
!           might be lost when the shift of the RRR is subtracted to obt
!           the eigenvalues of T. However, T is not guaranteed to define
!           eigenvalues to high relative accuracy anyway.               
!           Set RTOL to the order of the tolerance used in SLASQ2       
!           This is an ESTIMATED error, the worst case bound is 4*N*EPS 
!           which is usually too large and requires unnecessary work to 
!           done by bisection when computing the eigenvectors           
            RTOL = LOG(REAL(IN)) * FOUR * EPS 
            J = IBEGIN 
            DO 140 I = 1, IN - 1 
               WORK( 2*I-1 ) = ABS( D( J ) ) 
               WORK( 2*I ) = E( J )*E( J )*WORK( 2*I-1 ) 
               J = J + 1 
  140       CONTINUE 
            WORK( 2*IN-1 ) = ABS( D( IEND ) ) 
            WORK( 2*IN ) = ZERO 
            CALL SLASQ2( IN, WORK, IINFO ) 
            IF( IINFO .NE. 0 ) THEN 
!              If IINFO = -5 then an index is part of a tight cluster   
!              and should be changed. The index is in IWORK(1) and the  
!              gap is in WORK(N+1)                                      
               INFO = -5 
               RETURN 
            ELSE 
!              Test that all eigenvalues are positive as expected       
               DO 149 I = 1, IN 
                  IF( WORK( I ).LT.ZERO ) THEN 
                     INFO = -6 
                     RETURN 
                  ENDIF 
  149          CONTINUE 
            END IF 
            IF( SGNDEF.GT.ZERO ) THEN 
               DO 150 I = INDL, INDU 
                  M = M + 1 
                  W( M ) = WORK( IN-I+1 ) 
                  IBLOCK( M ) = JBLK 
                  INDEXW( M ) = I 
  150          CONTINUE 
            ELSE 
               DO 160 I = INDL, INDU 
                  M = M + 1 
                  W( M ) = -WORK( I ) 
                  IBLOCK( M ) = JBLK 
                  INDEXW( M ) = I 
  160          CONTINUE 
            END IF 
                                                                        
            DO 165 I = M - MB + 1, M 
!              the value of RTOL below should be the tolerance in SLASQ2
               WERR( I ) = RTOL * ABS( W(I) ) 
  165       CONTINUE 
            DO 166 I = M - MB + 1, M - 1 
!              compute the right gap between the intervals              
               WGAP( I ) = MAX( ZERO,                                   &
     &                          W(I+1)-WERR(I+1) - (W(I)+WERR(I)) )     
  166       CONTINUE 
            WGAP( M ) = MAX( ZERO,                                      &
     &           ( VU-SIGMA ) - ( W( M ) + WERR( M ) ) )                
         END IF 
!        proceed with next block                                        
         IBEGIN = IEND + 1 
         WBEGIN = WEND + 1 
  170 END DO 
!                                                                       
                                                                        
      RETURN 
!                                                                       
!     end of SLARRE                                                     
!                                                                       
      END                                           
!> \brief \b SLARRF finds a new relatively robust representation such th
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLARRF + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SLARRF( N, D, L, LD, CLSTRT, CLEND,                  
!                          W, WGAP, WERR,                               
!                          SPDIAM, CLGAPL, CLGAPR, PIVMIN, SIGMA,       
!                          DPLUS, LPLUS, WORK, INFO )                   
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            CLSTRT, CLEND, INFO, N                       
!       REAL               CLGAPL, CLGAPR, PIVMIN, SIGMA, SPDIAM        
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL               D( * ), DPLUS( * ), L( * ), LD( * ),         
!      $          LPLUS( * ), W( * ), WGAP( * ), WERR( * ), WORK( * )   
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> Given the initial representation L D L^T and its cluster of close    
!> eigenvalues (in a relative measure), W( CLSTRT ), W( CLSTRT+1 ), ... 
!> W( CLEND ), SLARRF finds a new relatively robust representation      
!> L D L^T - SIGMA I = L(+) D(+) L(+)^T such that at least one of the   
!> eigenvalues of L(+) D(+) L(+)^T is relatively isolated.              
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix (subblock, if the matrix split).    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] D                                                         
!> \verbatim                                                            
!>          D is REAL array, dimension (N)                              
!>          The N diagonal elements of the diagonal matrix D.           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] L                                                         
!> \verbatim                                                            
!>          L is REAL array, dimension (N-1)                            
!>          The (N-1) subdiagonal elements of the unit bidiagonal       
!>          matrix L.                                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LD                                                        
!> \verbatim                                                            
!>          LD is REAL array, dimension (N-1)                           
!>          The (N-1) elements L(i)*D(i).                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] CLSTRT                                                    
!> \verbatim                                                            
!>          CLSTRT is INTEGER                                           
!>          The index of the first eigenvalue in the cluster.           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] CLEND                                                     
!> \verbatim                                                            
!>          CLEND is INTEGER                                            
!>          The index of the last eigenvalue in the cluster.            
!> \endverbatim                                                         
!>                                                                      
!> \param[in] W                                                         
!> \verbatim                                                            
!>          W is REAL array, dimension                                  
!>          dimension is >=  (CLEND-CLSTRT+1)                           
!>          The eigenvalue APPROXIMATIONS of L D L^T in ascending order.
!>          W( CLSTRT ) through W( CLEND ) form the cluster of relativel
!>          close eigenalues.                                           
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] WGAP                                                  
!> \verbatim                                                            
!>          WGAP is REAL array, dimension                               
!>          dimension is >=  (CLEND-CLSTRT+1)                           
!>          The separation from the right neighbor eigenvalue in W.     
!> \endverbatim                                                         
!>                                                                      
!> \param[in] WERR                                                      
!> \verbatim                                                            
!>          WERR is REAL array, dimension                               
!>          dimension is >=  (CLEND-CLSTRT+1)                           
!>          WERR contain the semiwidth of the uncertainty               
!>          interval of the corresponding eigenvalue APPROXIMATION in W 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] SPDIAM                                                    
!> \verbatim                                                            
!>          SPDIAM is REAL                                              
!>          estimate of the spectral diameter obtained from the         
!>          Gerschgorin intervals                                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] CLGAPL                                                    
!> \verbatim                                                            
!>          CLGAPL is REAL                                              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] CLGAPR                                                    
!> \verbatim                                                            
!>          CLGAPR is REAL                                              
!>          absolute gap on each end of the cluster.                    
!>          Set by the calling routine to protect against shifts too clo
!>          to eigenvalues outside the cluster.                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] PIVMIN                                                    
!> \verbatim                                                            
!>          PIVMIN is REAL                                              
!>          The minimum pivot allowed in the Sturm sequence.            
!> \endverbatim                                                         
!>                                                                      
!> \param[out] SIGMA                                                    
!> \verbatim                                                            
!>          SIGMA is REAL                                               
!>          The shift used to form L(+) D(+) L(+)^T.                    
!> \endverbatim                                                         
!>                                                                      
!> \param[out] DPLUS                                                    
!> \verbatim                                                            
!>          DPLUS is REAL array, dimension (N)                          
!>          The N diagonal elements of the diagonal matrix D(+).        
!> \endverbatim                                                         
!>                                                                      
!> \param[out] LPLUS                                                    
!> \verbatim                                                            
!>          LPLUS is REAL array, dimension (N-1)                        
!>          The first (N-1) elements of LPLUS contain the subdiagonal   
!>          elements of the unit bidiagonal matrix L(+).                
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is REAL array, dimension (2*N)                         
!>          Workspace.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          Signals processing OK (=0) or failure (=1)                  
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2016                                                      
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!> \par Contributors:                                                   
!  ==================                                                   
!>                                                                      
!> Beresford Parlett, University of California, Berkeley, USA \n        
!> Jim Demmel, University of California, Berkeley, USA \n               
!> Inderjit Dhillon, University of Texas, Austin, USA \n                
!> Osni Marques, LBNL/NERSC, USA \n                                     
!> Christof Voemel, University of California, Berkeley, USA             
!                                                                       
!  =====================================================================
      SUBROUTINE SLARRF( N, D, L, LD, CLSTRT, CLEND,                    &
     &                   W, WGAP, WERR,                                 &
     &                   SPDIAM, CLGAPL, CLGAPR, PIVMIN, SIGMA,         &
     &                   DPLUS, LPLUS, WORK, INFO )                     
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.1) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2016                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            CLSTRT, CLEND, INFO, N 
      REAL               CLGAPL, CLGAPR, PIVMIN, SIGMA, SPDIAM 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               D( * ), DPLUS( * ), L( * ), LD( * ),           &
     &          LPLUS( * ), W( * ), WGAP( * ), WERR( * ), WORK( * )     
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               MAXGROWTH1, MAXGROWTH2, ONE, QUART, TWO 
      PARAMETER          ( ONE = 1.0E0, TWO = 2.0E0,                    &
     &                     QUART = 0.25E0,                              &
     &                     MAXGROWTH1 = 8.E0,                           &
     &                     MAXGROWTH2 = 8.E0 )                          
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL   DORRR1, FORCER, NOFAIL, SAWNAN1, SAWNAN2, TRYRRR1 
      INTEGER            I, INDX, KTRY, KTRYMAX, SLEFT, SRIGHT, SHIFT 
      PARAMETER          ( KTRYMAX = 1, SLEFT = 1, SRIGHT = 2 ) 
      REAL               AVGAP, BESTSHIFT, CLWDTH, EPS, FACT, FAIL,     &
     &                   FAIL2, GROWTHBOUND, LDELTA, LDMAX, LSIGMA,     &
     &                   MAX1, MAX2, MINGAP, OLDP, PROD, RDELTA, RDMAX, &
     &                   RRR1, RRR2, RSIGMA, S, SMLGROWTH, TMP, ZNM2    
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL SISNAN 
      REAL               SLAMCH 
      EXTERNAL           SISNAN, SLAMCH 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           SCOPY 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      INFO = 0 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.LE.0 ) THEN 
         RETURN 
      END IF 
!                                                                       
      FACT = REAL(2**KTRYMAX) 
      EPS = SLAMCH( 'Precision' ) 
      SHIFT = 0 
      FORCER = .FALSE. 
                                                                        
                                                                        
!     Note that we cannot guarantee that for any of the shifts tried,   
!     the factorization has a small or even moderate element growth.    
!     There could be Ritz values at both ends of the cluster and despite
!     backing off, there are examples where all factorizations tried    
!     (in IEEE mode, allowing zero pivots & infinities) have INFINITE   
!     element growth.                                                   
!     For this reason, we should use PIVMIN in this subroutine so that a
!     least the L D L^T factorization exists. It can be checked afterwar
!     whether the element growth caused bad residuals/orthogonality.    
                                                                        
!     Decide whether the code should accept the best among all          
!     representations despite large element growth or signal INFO=1     
!     Setting NOFAIL to .FALSE. for quick fix for bug 113               
      NOFAIL = .FALSE. 
!                                                                       
                                                                        
!     Compute the average gap length of the cluster                     
      CLWDTH = ABS(W(CLEND)-W(CLSTRT)) + WERR(CLEND) + WERR(CLSTRT) 
      AVGAP = CLWDTH / REAL(CLEND-CLSTRT) 
      MINGAP = MIN(CLGAPL, CLGAPR) 
!     Initial values for shifts to both ends of cluster                 
      LSIGMA = MIN(W( CLSTRT ),W( CLEND )) - WERR( CLSTRT ) 
      RSIGMA = MAX(W( CLSTRT ),W( CLEND )) + WERR( CLEND ) 
                                                                        
!     Use a small fudge to make sure that we really shift to the outside
      LSIGMA = LSIGMA - ABS(LSIGMA)* TWO * EPS 
      RSIGMA = RSIGMA + ABS(RSIGMA)* TWO * EPS 
                                                                        
!     Compute upper bounds for how much to back off the initial shifts  
      LDMAX = QUART * MINGAP + TWO * PIVMIN 
      RDMAX = QUART * MINGAP + TWO * PIVMIN 
                                                                        
      LDELTA = MAX(AVGAP,WGAP( CLSTRT ))/FACT 
      RDELTA = MAX(AVGAP,WGAP( CLEND-1 ))/FACT 
!                                                                       
!     Initialize the record of the best representation found            
!                                                                       
      S = SLAMCH( 'S' ) 
      SMLGROWTH = ONE / S 
      FAIL = REAL(N-1)*MINGAP/(SPDIAM*EPS) 
      FAIL2 = REAL(N-1)*MINGAP/(SPDIAM*SQRT(EPS)) 
      BESTSHIFT = LSIGMA 
!                                                                       
!     while (KTRY <= KTRYMAX)                                           
      KTRY = 0 
      GROWTHBOUND = MAXGROWTH1*SPDIAM 
                                                                        
    5 CONTINUE 
      SAWNAN1 = .FALSE. 
      SAWNAN2 = .FALSE. 
!     Ensure that we do not back off too much of the initial shifts     
      LDELTA = MIN(LDMAX,LDELTA) 
      RDELTA = MIN(RDMAX,RDELTA) 
                                                                        
!     Compute the element growth when shifting to both ends of the clust
!     accept the shift if there is no element growth at one of the two e
                                                                        
!     Left end                                                          
      S = -LSIGMA 
      DPLUS( 1 ) = D( 1 ) + S 
      IF(ABS(DPLUS(1)).LT.PIVMIN) THEN 
         DPLUS(1) = -PIVMIN 
!        Need to set SAWNAN1 because refined RRR test should not be used
!        in this case                                                   
         SAWNAN1 = .TRUE. 
      ENDIF 
      MAX1 = ABS( DPLUS( 1 ) ) 
      DO 6 I = 1, N - 1 
         LPLUS( I ) = LD( I ) / DPLUS( I ) 
         S = S*LPLUS( I )*L( I ) - LSIGMA 
         DPLUS( I+1 ) = D( I+1 ) + S 
         IF(ABS(DPLUS(I+1)).LT.PIVMIN) THEN 
            DPLUS(I+1) = -PIVMIN 
!           Need to set SAWNAN1 because refined RRR test should not be u
!           in this case                                                
            SAWNAN1 = .TRUE. 
         ENDIF 
         MAX1 = MAX( MAX1,ABS(DPLUS(I+1)) ) 
    6 END DO 
      SAWNAN1 = SAWNAN1 .OR.  SISNAN( MAX1 ) 
                                                                        
      IF( FORCER .OR.                                                   &
     &   (MAX1.LE.GROWTHBOUND .AND. .NOT.SAWNAN1 ) ) THEN               
         SIGMA = LSIGMA 
         SHIFT = SLEFT 
         GOTO 100 
      ENDIF 
                                                                        
!     Right end                                                         
      S = -RSIGMA 
      WORK( 1 ) = D( 1 ) + S 
      IF(ABS(WORK(1)).LT.PIVMIN) THEN 
         WORK(1) = -PIVMIN 
!        Need to set SAWNAN2 because refined RRR test should not be used
!        in this case                                                   
         SAWNAN2 = .TRUE. 
      ENDIF 
      MAX2 = ABS( WORK( 1 ) ) 
      DO 7 I = 1, N - 1 
         WORK( N+I ) = LD( I ) / WORK( I ) 
         S = S*WORK( N+I )*L( I ) - RSIGMA 
         WORK( I+1 ) = D( I+1 ) + S 
         IF(ABS(WORK(I+1)).LT.PIVMIN) THEN 
            WORK(I+1) = -PIVMIN 
!           Need to set SAWNAN2 because refined RRR test should not be u
!           in this case                                                
            SAWNAN2 = .TRUE. 
         ENDIF 
         MAX2 = MAX( MAX2,ABS(WORK(I+1)) ) 
    7 END DO 
      SAWNAN2 = SAWNAN2 .OR.  SISNAN( MAX2 ) 
                                                                        
      IF( FORCER .OR.                                                   &
     &   (MAX2.LE.GROWTHBOUND .AND. .NOT.SAWNAN2 ) ) THEN               
         SIGMA = RSIGMA 
         SHIFT = SRIGHT 
         GOTO 100 
      ENDIF 
!     If we are at this point, both shifts led to too much element growt
                                                                        
!     Record the better of the two shifts (provided it didn't lead to Na
      IF(SAWNAN1.AND.SAWNAN2) THEN 
!        both MAX1 and MAX2 are NaN                                     
         GOTO 50 
      ELSE 
         IF( .NOT.SAWNAN1 ) THEN 
            INDX = 1 
            IF(MAX1.LE.SMLGROWTH) THEN 
               SMLGROWTH = MAX1 
               BESTSHIFT = LSIGMA 
            ENDIF 
         ENDIF 
         IF( .NOT.SAWNAN2 ) THEN 
            IF(SAWNAN1 .OR. MAX2.LE.MAX1) INDX = 2 
            IF(MAX2.LE.SMLGROWTH) THEN 
               SMLGROWTH = MAX2 
               BESTSHIFT = RSIGMA 
            ENDIF 
         ENDIF 
      ENDIF 
                                                                        
!     If we are here, both the left and the right shift led to          
!     element growth. If the element growth is moderate, then           
!     we may still accept the representation, if it passes a            
!     refined test for RRR. This test supposes that no NaN occurred.    
!     Moreover, we use the refined RRR test only for isolated clusters. 
      IF((CLWDTH.LT.MINGAP/REAL(128)) .AND.                             &
     &   (MIN(MAX1,MAX2).LT.FAIL2)                                      &
     &  .AND.(.NOT.SAWNAN1).AND.(.NOT.SAWNAN2)) THEN                    
         DORRR1 = .TRUE. 
      ELSE 
         DORRR1 = .FALSE. 
      ENDIF 
      TRYRRR1 = .TRUE. 
      IF( TRYRRR1 .AND. DORRR1 ) THEN 
      IF(INDX.EQ.1) THEN 
         TMP = ABS( DPLUS( N ) ) 
         ZNM2 = ONE 
         PROD = ONE 
         OLDP = ONE 
         DO 15 I = N-1, 1, -1 
            IF( PROD .LE. EPS ) THEN 
               PROD =                                                   &
     &         ((DPLUS(I+1)*WORK(N+I+1))/(DPLUS(I)*WORK(N+I)))*OLDP     
            ELSE 
               PROD = PROD*ABS(WORK(N+I)) 
            END IF 
            OLDP = PROD 
            ZNM2 = ZNM2 + PROD**2 
            TMP = MAX( TMP, ABS( DPLUS( I ) * PROD )) 
   15    CONTINUE 
         RRR1 = TMP/( SPDIAM * SQRT( ZNM2 ) ) 
         IF (RRR1.LE.MAXGROWTH2) THEN 
            SIGMA = LSIGMA 
            SHIFT = SLEFT 
            GOTO 100 
         ENDIF 
      ELSE IF(INDX.EQ.2) THEN 
         TMP = ABS( WORK( N ) ) 
         ZNM2 = ONE 
         PROD = ONE 
         OLDP = ONE 
         DO 16 I = N-1, 1, -1 
            IF( PROD .LE. EPS ) THEN 
               PROD = ((WORK(I+1)*LPLUS(I+1))/(WORK(I)*LPLUS(I)))*OLDP 
            ELSE 
               PROD = PROD*ABS(LPLUS(I)) 
            END IF 
            OLDP = PROD 
            ZNM2 = ZNM2 + PROD**2 
            TMP = MAX( TMP, ABS( WORK( I ) * PROD )) 
   16    CONTINUE 
         RRR2 = TMP/( SPDIAM * SQRT( ZNM2 ) ) 
         IF (RRR2.LE.MAXGROWTH2) THEN 
            SIGMA = RSIGMA 
            SHIFT = SRIGHT 
            GOTO 100 
         ENDIF 
      END IF 
      ENDIF 
                                                                        
   50 CONTINUE 
                                                                        
      IF (KTRY.LT.KTRYMAX) THEN 
!        If we are here, both shifts failed also the RRR test.          
!        Back off to the outside                                        
         LSIGMA = MAX( LSIGMA - LDELTA,                                 &
     &     LSIGMA - LDMAX)                                              
         RSIGMA = MIN( RSIGMA + RDELTA,                                 &
     &     RSIGMA + RDMAX )                                             
         LDELTA = TWO * LDELTA 
         RDELTA = TWO * RDELTA 
         KTRY = KTRY + 1 
         GOTO 5 
      ELSE 
!        None of the representations investigated satisfied our         
!        criteria. Take the best one we found.                          
         IF((SMLGROWTH.LT.FAIL).OR.NOFAIL) THEN 
            LSIGMA = BESTSHIFT 
            RSIGMA = BESTSHIFT 
            FORCER = .TRUE. 
            GOTO 5 
         ELSE 
            INFO = 1 
            RETURN 
         ENDIF 
      END IF 
                                                                        
  100 CONTINUE 
      IF (SHIFT.EQ.SLEFT) THEN 
      ELSEIF (SHIFT.EQ.SRIGHT) THEN 
!        store new L and D back into DPLUS, LPLUS                       
         CALL SCOPY( N, WORK, 1, DPLUS, 1 ) 
         CALL SCOPY( N-1, WORK(N+1), 1, LPLUS, 1 ) 
      ENDIF 
                                                                        
      RETURN 
!                                                                       
!     End of SLARRF                                                     
!                                                                       
      END                                           
!> \brief \b SLARRJ performs refinement of the initial estimates of the 
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLARRJ + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SLARRJ( N, D, E2, IFIRST, ILAST,                     
!                          RTOL, OFFSET, W, WERR, WORK, IWORK,          
!                          PIVMIN, SPDIAM, INFO )                       
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            IFIRST, ILAST, INFO, N, OFFSET               
!       REAL               PIVMIN, RTOL, SPDIAM                         
!       ..                                                              
!       .. Array Arguments ..                                           
!       INTEGER            IWORK( * )                                   
!       REAL               D( * ), E2( * ), W( * ),                     
!      $                   WERR( * ), WORK( * )                         
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> Given the initial eigenvalue approximations of T, SLARRJ             
!> does  bisection to refine the eigenvalues of T,                      
!> W( IFIRST-OFFSET ) through W( ILAST-OFFSET ), to more accuracy. Initi
!> guesses for these eigenvalues are input in W, the corresponding estim
!> of the error in these guesses in WERR. During bisection, intervals   
!> [left, right] are maintained by storing their mid-points and         
!> semi-widths in the arrays W and WERR respectively.                   
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix.                                    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] D                                                         
!> \verbatim                                                            
!>          D is REAL array, dimension (N)                              
!>          The N diagonal elements of T.                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] E2                                                        
!> \verbatim                                                            
!>          E2 is REAL array, dimension (N-1)                           
!>          The Squares of the (N-1) subdiagonal elements of T.         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IFIRST                                                    
!> \verbatim                                                            
!>          IFIRST is INTEGER                                           
!>          The index of the first eigenvalue to be computed.           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ILAST                                                     
!> \verbatim                                                            
!>          ILAST is INTEGER                                            
!>          The index of the last eigenvalue to be computed.            
!> \endverbatim                                                         
!>                                                                      
!> \param[in] RTOL                                                      
!> \verbatim                                                            
!>          RTOL is REAL                                                
!>          Tolerance for the convergence of the bisection intervals.   
!>          An interval [LEFT,RIGHT] has converged if                   
!>          RIGHT-LEFT < RTOL*MAX(|LEFT|,|RIGHT|).                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] OFFSET                                                    
!> \verbatim                                                            
!>          OFFSET is INTEGER                                           
!>          Offset for the arrays W and WERR, i.e., the IFIRST-OFFSET   
!>          through ILAST-OFFSET elements of these arrays are to be used
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] W                                                     
!> \verbatim                                                            
!>          W is REAL array, dimension (N)                              
!>          On input, W( IFIRST-OFFSET ) through W( ILAST-OFFSET ) are  
!>          estimates of the eigenvalues of L D L^T indexed IFIRST throu
!>          ILAST.                                                      
!>          On output, these estimates are refined.                     
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] WERR                                                  
!> \verbatim                                                            
!>          WERR is REAL array, dimension (N)                           
!>          On input, WERR( IFIRST-OFFSET ) through WERR( ILAST-OFFSET )
!>          the errors in the estimates of the corresponding elements in
!>          On output, these errors are refined.                        
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is REAL array, dimension (2*N)                         
!>          Workspace.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[out] IWORK                                                    
!> \verbatim                                                            
!>          IWORK is INTEGER array, dimension (2*N)                     
!>          Workspace.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] PIVMIN                                                    
!> \verbatim                                                            
!>          PIVMIN is REAL                                              
!>          The minimum pivot in the Sturm sequence for T.              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] SPDIAM                                                    
!> \verbatim                                                            
!>          SPDIAM is REAL                                              
!>          The spectral diameter of T.                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          Error flag.                                                 
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2017                                                      
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!> \par Contributors:                                                   
!  ==================                                                   
!>                                                                      
!> Beresford Parlett, University of California, Berkeley, USA \n        
!> Jim Demmel, University of California, Berkeley, USA \n               
!> Inderjit Dhillon, University of Texas, Austin, USA \n                
!> Osni Marques, LBNL/NERSC, USA \n                                     
!> Christof Voemel, University of California, Berkeley, USA             
!                                                                       
!  =====================================================================
      SUBROUTINE SLARRJ( N, D, E2, IFIRST, ILAST,                       &
     &                   RTOL, OFFSET, W, WERR, WORK, IWORK,            &
     &                   PIVMIN, SPDIAM, INFO )                         
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.1) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2017                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            IFIRST, ILAST, INFO, N, OFFSET 
      REAL               PIVMIN, RTOL, SPDIAM 
!     ..                                                                
!     .. Array Arguments ..                                             
      INTEGER            IWORK( * ) 
      REAL               D( * ), E2( * ), W( * ),                       &
     &                   WERR( * ), WORK( * )                           
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ZERO, ONE, TWO, HALF 
      PARAMETER        ( ZERO = 0.0E0, ONE = 1.0E0, TWO = 2.0E0,        &
     &                   HALF = 0.5E0 )                                 
      INTEGER   MAXITR 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            CNT, I, I1, I2, II, ITER, J, K, NEXT, NINT,    &
     &                   OLNINT, P, PREV, SAVI1                         
      REAL               DPLUS, FAC, LEFT, MID, RIGHT, S, TMP, WIDTH 
!                                                                       
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, MAX 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      INFO = 0 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.LE.0 ) THEN 
         RETURN 
      END IF 
!                                                                       
      MAXITR = INT( ( LOG( SPDIAM+PIVMIN )-LOG( PIVMIN ) ) /            &
     &           LOG( TWO ) ) + 2                                       
!                                                                       
!     Initialize unconverged intervals in [ WORK(2*I-1), WORK(2*I) ].   
!     The Sturm Count, Count( WORK(2*I-1) ) is arranged to be I-1, while
!     Count( WORK(2*I) ) is stored in IWORK( 2*I ). The integer IWORK( 2
!     for an unconverged interval is set to the index of the next unconv
!     interval, and is -1 or 0 for a converged interval. Thus a linked  
!     list of unconverged intervals is set up.                          
!                                                                       
                                                                        
      I1 = IFIRST 
      I2 = ILAST 
!     The number of unconverged intervals                               
      NINT = 0 
!     The last unconverged interval found                               
      PREV = 0 
      DO 75 I = I1, I2 
         K = 2*I 
         II = I - OFFSET 
         LEFT = W( II ) - WERR( II ) 
         MID = W(II) 
         RIGHT = W( II ) + WERR( II ) 
         WIDTH = RIGHT - MID 
         TMP = MAX( ABS( LEFT ), ABS( RIGHT ) ) 
                                                                        
!        The following test prevents the test of converged intervals    
         IF( WIDTH.LT.RTOL*TMP ) THEN 
!           This interval has already converged and does not need refine
!           (Note that the gaps might change through refining the       
!            eigenvalues, however, they can only get bigger.)           
!           Remove it from the list.                                    
            IWORK( K-1 ) = -1 
!           Make sure that I1 always points to the first unconverged int
            IF((I.EQ.I1).AND.(I.LT.I2)) I1 = I + 1 
            IF((PREV.GE.I1).AND.(I.LE.I2)) IWORK( 2*PREV-1 ) = I + 1 
         ELSE 
!           unconverged interval found                                  
            PREV = I 
!           Make sure that [LEFT,RIGHT] contains the desired eigenvalue 
!                                                                       
!           Do while( CNT(LEFT).GT.I-1 )                                
!                                                                       
            FAC = ONE 
   20       CONTINUE 
            CNT = 0 
            S = LEFT 
            DPLUS = D( 1 ) - S 
            IF( DPLUS.LT.ZERO ) CNT = CNT + 1 
            DO 30 J = 2, N 
               DPLUS = D( J ) - S - E2( J-1 )/DPLUS 
               IF( DPLUS.LT.ZERO ) CNT = CNT + 1 
   30       CONTINUE 
            IF( CNT.GT.I-1 ) THEN 
               LEFT = LEFT - WERR( II )*FAC 
               FAC = TWO*FAC 
               GO TO 20 
            END IF 
!                                                                       
!           Do while( CNT(RIGHT).LT.I )                                 
!                                                                       
            FAC = ONE 
   50       CONTINUE 
            CNT = 0 
            S = RIGHT 
            DPLUS = D( 1 ) - S 
            IF( DPLUS.LT.ZERO ) CNT = CNT + 1 
            DO 60 J = 2, N 
               DPLUS = D( J ) - S - E2( J-1 )/DPLUS 
               IF( DPLUS.LT.ZERO ) CNT = CNT + 1 
   60       CONTINUE 
            IF( CNT.LT.I ) THEN 
               RIGHT = RIGHT + WERR( II )*FAC 
               FAC = TWO*FAC 
               GO TO 50 
            END IF 
            NINT = NINT + 1 
            IWORK( K-1 ) = I + 1 
            IWORK( K ) = CNT 
         END IF 
         WORK( K-1 ) = LEFT 
         WORK( K ) = RIGHT 
   75 END DO 
                                                                        
                                                                        
      SAVI1 = I1 
!                                                                       
!     Do while( NINT.GT.0 ), i.e. there are still unconverged intervals 
!     and while (ITER.LT.MAXITR)                                        
!                                                                       
      ITER = 0 
   80 CONTINUE 
      PREV = I1 - 1 
      I = I1 
      OLNINT = NINT 
                                                                        
      DO 100 P = 1, OLNINT 
         K = 2*I 
         II = I - OFFSET 
         NEXT = IWORK( K-1 ) 
         LEFT = WORK( K-1 ) 
         RIGHT = WORK( K ) 
         MID = HALF*( LEFT + RIGHT ) 
                                                                        
!        semiwidth of interval                                          
         WIDTH = RIGHT - MID 
         TMP = MAX( ABS( LEFT ), ABS( RIGHT ) ) 
                                                                        
         IF( ( WIDTH.LT.RTOL*TMP ) .OR.                                 &
     &      (ITER.EQ.MAXITR) )THEN                                      
!           reduce number of unconverged intervals                      
            NINT = NINT - 1 
!           Mark interval as converged.                                 
            IWORK( K-1 ) = 0 
            IF( I1.EQ.I ) THEN 
               I1 = NEXT 
            ELSE 
!              Prev holds the last unconverged interval previously exami
               IF(PREV.GE.I1) IWORK( 2*PREV-1 ) = NEXT 
            END IF 
            I = NEXT 
            GO TO 100 
         END IF 
         PREV = I 
!                                                                       
!        Perform one bisection step                                     
!                                                                       
         CNT = 0 
         S = MID 
         DPLUS = D( 1 ) - S 
         IF( DPLUS.LT.ZERO ) CNT = CNT + 1 
         DO 90 J = 2, N 
            DPLUS = D( J ) - S - E2( J-1 )/DPLUS 
            IF( DPLUS.LT.ZERO ) CNT = CNT + 1 
   90    CONTINUE 
         IF( CNT.LE.I-1 ) THEN 
            WORK( K-1 ) = MID 
         ELSE 
            WORK( K ) = MID 
         END IF 
         I = NEXT 
                                                                        
  100 END DO 
      ITER = ITER + 1 
!     do another loop if there are still unconverged intervals          
!     However, in the last iteration, all intervals are accepted        
!     since this is the best we can do.                                 
      IF( ( NINT.GT.0 ).AND.(ITER.LE.MAXITR) ) GO TO 80 
!                                                                       
!                                                                       
!     At this point, all the intervals have converged                   
      DO 110 I = SAVI1, ILAST 
         K = 2*I 
         II = I - OFFSET 
!        All intervals marked by '0' have been refined.                 
         IF( IWORK( K-1 ).EQ.0 ) THEN 
            W( II ) = HALF*( WORK( K-1 )+WORK( K ) ) 
            WERR( II ) = WORK( K ) - W( II ) 
         END IF 
  110 END DO 
!                                                                       
                                                                        
      RETURN 
!                                                                       
!     End of SLARRJ                                                     
!                                                                       
      END                                           
!> \brief \b SLARRK computes one eigenvalue of a symmetric tridiagonal m
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLARRK + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SLARRK( N, IW, GL, GU,                               
!                           D, E2, PIVMIN, RELTOL, W, WERR, INFO)       
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER   INFO, IW, N                                           
!       REAL                PIVMIN, RELTOL, GL, GU, W, WERR             
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL               D( * ), E2( * )                              
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SLARRK computes one eigenvalue of a symmetric tridiagonal            
!> matrix T to suitable accuracy. This is an auxiliary code to be       
!> called from SSTEMR.                                                  
!>                                                                      
!> To avoid overflow, the matrix must be scaled so that its             
!> largest element is no greater than overflow**(1/2) * underflow**(1/4)
!> accuracy, it should not be much smaller than that.                   
!>                                                                      
!> See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal        
!> Matrix", Report CS41, Computer Science Dept., Stanford               
!> University, July 21, 1966.                                           
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the tridiagonal matrix T.  N >= 0.             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IW                                                        
!> \verbatim                                                            
!>          IW is INTEGER                                               
!>          The index of the eigenvalues to be returned.                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] GL                                                        
!> \verbatim                                                            
!>          GL is REAL                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] GU                                                        
!> \verbatim                                                            
!>          GU is REAL                                                  
!>          An upper and a lower bound on the eigenvalue.               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] D                                                         
!> \verbatim                                                            
!>          D is REAL array, dimension (N)                              
!>          The n diagonal elements of the tridiagonal matrix T.        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] E2                                                        
!> \verbatim                                                            
!>          E2 is REAL array, dimension (N-1)                           
!>          The (n-1) squared off-diagonal elements of the tridiagonal m
!> \endverbatim                                                         
!>                                                                      
!> \param[in] PIVMIN                                                    
!> \verbatim                                                            
!>          PIVMIN is REAL                                              
!>          The minimum pivot allowed in the Sturm sequence for T.      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] RELTOL                                                    
!> \verbatim                                                            
!>          RELTOL is REAL                                              
!>          The minimum relative width of an interval.  When an interval
!>          is narrower than RELTOL times the larger (in                
!>          magnitude) endpoint, then it is considered to be            
!>          sufficiently small, i.e., converged.  Note: this should     
!>          always be at least radix*machine epsilon.                   
!> \endverbatim                                                         
!>                                                                      
!> \param[out] W                                                        
!> \verbatim                                                            
!>          W is REAL                                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WERR                                                     
!> \verbatim                                                            
!>          WERR is REAL                                                
!>          The error bound on the corresponding eigenvalue approximatio
!>          in W.                                                       
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0:       Eigenvalue converged                             
!>          = -1:      Eigenvalue did NOT converge                      
!> \endverbatim                                                         
!                                                                       
!> \par Internal Parameters:                                            
!  =========================                                            
!>                                                                      
!> \verbatim                                                            
!>  FUDGE   REAL            , default = 2                               
!>          A "fudge factor" to widen the Gershgorin intervals.         
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2017                                                      
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!  =====================================================================
      SUBROUTINE SLARRK( N, IW, GL, GU,                                 &
     &                    D, E2, PIVMIN, RELTOL, W, WERR, INFO)         
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.1) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2017                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER   INFO, IW, N 
      REAL                PIVMIN, RELTOL, GL, GU, W, WERR 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               D( * ), E2( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               FUDGE, HALF, TWO, ZERO 
      PARAMETER          ( HALF = 0.5E0, TWO = 2.0E0,                   &
     &                     FUDGE = TWO, ZERO = 0.0E0 )                  
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER   I, IT, ITMAX, NEGCNT 
      REAL               ATOLI, EPS, LEFT, MID, RIGHT, RTOLI, TMP1,     &
     &                   TMP2, TNORM                                    
!     ..                                                                
!     .. External Functions ..                                          
      REAL               SLAMCH 
      EXTERNAL   SLAMCH 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, INT, LOG, MAX 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.LE.0 ) THEN 
         INFO = 0 
         RETURN 
      END IF 
!                                                                       
!     Get machine constants                                             
      EPS = SLAMCH( 'P' ) 
                                                                        
      TNORM = MAX( ABS( GL ), ABS( GU ) ) 
      RTOLI = RELTOL 
      ATOLI = FUDGE*TWO*PIVMIN 
                                                                        
      ITMAX = INT( ( LOG( TNORM+PIVMIN )-LOG( PIVMIN ) ) /              &
     &           LOG( TWO ) ) + 2                                       
                                                                        
      INFO = -1 
                                                                        
      LEFT = GL - FUDGE*TNORM*EPS*N - FUDGE*TWO*PIVMIN 
      RIGHT = GU + FUDGE*TNORM*EPS*N + FUDGE*TWO*PIVMIN 
      IT = 0 
                                                                        
   10 CONTINUE 
!                                                                       
!     Check if interval converged or maximum number of iterations reache
!                                                                       
      TMP1 = ABS( RIGHT - LEFT ) 
      TMP2 = MAX( ABS(RIGHT), ABS(LEFT) ) 
      IF( TMP1.LT.MAX( ATOLI, PIVMIN, RTOLI*TMP2 ) ) THEN 
         INFO = 0 
         GOTO 30 
      ENDIF 
      IF(IT.GT.ITMAX)                                                   &
     &   GOTO 30                                                        
                                                                        
!                                                                       
!     Count number of negative pivots for mid-point                     
!                                                                       
      IT = IT + 1 
      MID = HALF * (LEFT + RIGHT) 
      NEGCNT = 0 
      TMP1 = D( 1 ) - MID 
      IF( ABS( TMP1 ).LT.PIVMIN )                                       &
     &   TMP1 = -PIVMIN                                                 
      IF( TMP1.LE.ZERO )                                                &
     &   NEGCNT = NEGCNT + 1                                            
!                                                                       
      DO 20 I = 2, N 
         TMP1 = D( I ) - E2( I-1 ) / TMP1 - MID 
         IF( ABS( TMP1 ).LT.PIVMIN )                                    &
     &      TMP1 = -PIVMIN                                              
         IF( TMP1.LE.ZERO )                                             &
     &      NEGCNT = NEGCNT + 1                                         
   20 END DO 
                                                                        
      IF(NEGCNT.GE.IW) THEN 
         RIGHT = MID 
      ELSE 
         LEFT = MID 
      ENDIF 
      GOTO 10 
                                                                        
   30 CONTINUE 
!                                                                       
!     Converged or maximum number of iterations reached                 
!                                                                       
      W = HALF * (LEFT + RIGHT) 
      WERR = HALF * ABS( RIGHT - LEFT ) 
                                                                        
      RETURN 
!                                                                       
!     End of SLARRK                                                     
!                                                                       
      END                                           
!> \brief \b SLARRR performs tests to decide whether the symmetric tridi
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLARRR + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SLARRR( N, D, E, INFO )                              
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            N, INFO                                      
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL               D( * ), E( * )                               
!       ..                                                              
!                                                                       
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> Perform tests to decide whether the symmetric tridiagonal matrix T   
!> warrants expensive computations which guarantee high relative accurac
!> in the eigenvalues.                                                  
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix. N > 0.                             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] D                                                         
!> \verbatim                                                            
!>          D is REAL array, dimension (N)                              
!>          The N diagonal elements of the tridiagonal matrix T.        
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] E                                                     
!> \verbatim                                                            
!>          E is REAL array, dimension (N)                              
!>          On entry, the first (N-1) entries contain the subdiagonal   
!>          elements of the tridiagonal matrix T; E(N) is set to ZERO.  
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          INFO = 0(default) : the matrix warrants computations preserv
!>                              relative accuracy.                      
!>          INFO = 1          : the matrix warrants computations guarant
!>                              only absolute accuracy.                 
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2017                                                      
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!> \par Contributors:                                                   
!  ==================                                                   
!>                                                                      
!> Beresford Parlett, University of California, Berkeley, USA \n        
!> Jim Demmel, University of California, Berkeley, USA \n               
!> Inderjit Dhillon, University of Texas, Austin, USA \n                
!> Osni Marques, LBNL/NERSC, USA \n                                     
!> Christof Voemel, University of California, Berkeley, USA             
!                                                                       
!  =====================================================================
      SUBROUTINE SLARRR( N, D, E, INFO ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.1) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2017                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            N, INFO 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               D( * ), E( * ) 
!     ..                                                                
!                                                                       
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ZERO, RELCOND 
      PARAMETER          ( ZERO = 0.0E0,                                &
     &                     RELCOND = 0.999E0 )                          
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I 
      LOGICAL            YESREL 
      REAL               EPS, SAFMIN, SMLNUM, RMIN, TMP, TMP2,          &
     &          OFFDIG, OFFDIG2                                         
                                                                        
!     ..                                                                
!     .. External Functions ..                                          
      REAL               SLAMCH 
      EXTERNAL           SLAMCH 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.LE.0 ) THEN 
         INFO = 0 
         RETURN 
      END IF 
!                                                                       
!     As a default, do NOT go for relative-accuracy preserving computati
      INFO = 1 
                                                                        
      SAFMIN = SLAMCH( 'Safe minimum' ) 
      EPS = SLAMCH( 'Precision' ) 
      SMLNUM = SAFMIN / EPS 
      RMIN = SQRT( SMLNUM ) 
                                                                        
!     Tests for relative accuracy                                       
!                                                                       
!     Test for scaled diagonal dominance                                
!     Scale the diagonal entries to one and check whether the sum of the
!     off-diagonals is less than one                                    
!                                                                       
!     The sdd relative error bounds have a 1/(1- 2*x) factor in them,   
!     x = max(OFFDIG + OFFDIG2), so when x is close to 1/2, no relative 
!     accuracy is promised.  In the notation of the code fragment below,
!     1/(1 - (OFFDIG + OFFDIG2)) is the condition number.               
!     We don't think it is worth going into "sdd mode" unless the relati
!     condition number is reasonable, not 1/macheps.                    
!     The threshold should be compatible with other thresholds used in t
!     code. We set  OFFDIG + OFFDIG2 <= .999 =: RELCOND, it corresponds 
!     to losing at most 3 decimal digits: 1 / (1 - (OFFDIG + OFFDIG2)) <
!     instead of the current OFFDIG + OFFDIG2 < 1                       
!                                                                       
      YESREL = .TRUE. 
      OFFDIG = ZERO 
      TMP = SQRT(ABS(D(1))) 
      IF (TMP.LT.RMIN) YESREL = .FALSE. 
      IF(.NOT.YESREL) GOTO 11 
      DO 10 I = 2, N 
         TMP2 = SQRT(ABS(D(I))) 
         IF (TMP2.LT.RMIN) YESREL = .FALSE. 
         IF(.NOT.YESREL) GOTO 11 
         OFFDIG2 = ABS(E(I-1))/(TMP*TMP2) 
         IF(OFFDIG+OFFDIG2.GE.RELCOND) YESREL = .FALSE. 
         IF(.NOT.YESREL) GOTO 11 
         TMP = TMP2 
         OFFDIG = OFFDIG2 
   10 END DO 
   11 CONTINUE 
                                                                        
      IF( YESREL ) THEN 
         INFO = 0 
         RETURN 
      ELSE 
      ENDIF 
!                                                                       
                                                                        
!                                                                       
!     *** MORE TO BE IMPLEMENTED ***                                    
!                                                                       
                                                                        
!                                                                       
!     Test if the lower bidiagonal matrix L from T = L D L^T            
!     (zero shift facto) is well conditioned                            
!                                                                       
                                                                        
!                                                                       
!     Test if the upper bidiagonal matrix U from T = U D U^T            
!     (zero shift facto) is well conditioned.                           
!     In this case, the matrix needs to be flipped and, at the end      
!     of the eigenvector computation, the flip needs to be applied      
!     to the computed eigenvectors (and the support)                    
!                                                                       
                                                                        
!                                                                       
      RETURN 
!                                                                       
!     END OF SLARRR                                                     
!                                                                       
!> \brief \b SLARRV computes the eigenvectors of the tridiagonal matrix 
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLARRV + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SLARRV( N, VL, VU, D, L, PIVMIN,                     
!                          ISPLIT, M, DOL, DOU, MINRGP,                 
!                          RTOL1, RTOL2, W, WERR, WGAP,                 
!                          IBLOCK, INDEXW, GERS, Z, LDZ, ISUPPZ,        
!                          WORK, IWORK, INFO )                          
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            DOL, DOU, INFO, LDZ, M, N                    
!       REAL               MINRGP, PIVMIN, RTOL1, RTOL2, VL, VU         
!       ..                                                              
!       .. Array Arguments ..                                           
!       INTEGER            IBLOCK( * ), INDEXW( * ), ISPLIT( * ),       
!      $                   ISUPPZ( * ), IWORK( * )                      
!       REAL               D( * ), GERS( * ), L( * ), W( * ), WERR( * ),
!      $                   WGAP( * ), WORK( * )                         
!       REAL              Z( LDZ, * )                                   
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SLARRV computes the eigenvectors of the tridiagonal matrix           
!> T = L D L**T given L, D and APPROXIMATIONS to the eigenvalues of L D 
!> The input eigenvalues should have been computed by SLARRE.           
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix.  N >= 0.                           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] VL                                                        
!> \verbatim                                                            
!>          VL is REAL                                                  
!>          Lower bound of the interval that contains the desired       
!>          eigenvalues. VL < VU. Needed to compute gaps on the left or 
!>          end of the extremal eigenvalues in the desired RANGE.       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] VU                                                        
!> \verbatim                                                            
!>          VU is REAL                                                  
!>          Upper bound of the interval that contains the desired       
!>          eigenvalues. VL < VU.                                       
!>          Note: VU is currently not used by this implementation of SLA
!>          passed to SLARRV because it could be used compute gaps on th
!>          of the extremal eigenvalues. However, with not much initial 
!>          LAMBDA and VU, the formula can lead to an overestimation of 
!>          and thus to inadequately early RQI 'convergence'. This is cu
!>          prevented this by forcing a small right gap. And so it turns
!>          is currently not used by this implementation of SLARRV.     
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] D                                                     
!> \verbatim                                                            
!>          D is REAL array, dimension (N)                              
!>          On entry, the N diagonal elements of the diagonal matrix D. 
!>          On exit, D may be overwritten.                              
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] L                                                     
!> \verbatim                                                            
!>          L is REAL array, dimension (N)                              
!>          On entry, the (N-1) subdiagonal elements of the unit        
!>          bidiagonal matrix L are in elements 1 to N-1 of L           
!>          (if the matrix is not split.) At the end of each block      
!>          is stored the corresponding shift as given by SLARRE.       
!>          On exit, L is overwritten.                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] PIVMIN                                                    
!> \verbatim                                                            
!>          PIVMIN is REAL                                              
!>          The minimum pivot allowed in the Sturm sequence.            
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ISPLIT                                                    
!> \verbatim                                                            
!>          ISPLIT is INTEGER array, dimension (N)                      
!>          The splitting points, at which T breaks up into blocks.     
!>          The first block consists of rows/columns 1 to               
!>          ISPLIT( 1 ), the second of rows/columns ISPLIT( 1 )+1       
!>          through ISPLIT( 2 ), etc.                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The total number of input eigenvalues.  0 <= M <= N.        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] DOL                                                       
!> \verbatim                                                            
!>          DOL is INTEGER                                              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] DOU                                                       
!> \verbatim                                                            
!>          DOU is INTEGER                                              
!>          If the user wants to compute only selected eigenvectors from
!>          the eigenvalues supplied, he can specify an index range DOL:
!>          Or else the setting DOL=1, DOU=M should be applied.         
!>          Note that DOL and DOU refer to the order in which the eigenv
!>          are stored in W.                                            
!>          If the user wants to compute only selected eigenpairs, then 
!>          the columns DOL-1 to DOU+1 of the eigenvector space Z contai
!>          computed eigenvectors. All other columns of Z are set to zer
!> \endverbatim                                                         
!>                                                                      
!> \param[in] MINRGP                                                    
!> \verbatim                                                            
!>          MINRGP is REAL                                              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] RTOL1                                                     
!> \verbatim                                                            
!>          RTOL1 is REAL                                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] RTOL2                                                     
!> \verbatim                                                            
!>          RTOL2 is REAL                                               
!>           Parameters for bisection.                                  
!>           An interval [LEFT,RIGHT] has converged if                  
!>           RIGHT-LEFT < MAX( RTOL1*GAP, RTOL2*MAX(|LEFT|,|RIGHT|) )   
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] W                                                     
!> \verbatim                                                            
!>          W is REAL array, dimension (N)                              
!>          The first M elements of W contain the APPROXIMATE eigenvalue
!>          which eigenvectors are to be computed.  The eigenvalues     
!>          should be grouped by split-off block and ordered from       
!>          smallest to largest within the block ( The output array     
!>          W from SLARRE is expected here ). Furthermore, they are with
!>          respect to the shift of the corresponding root representatio
!>          for their block. On exit, W holds the eigenvalues of the    
!>          UNshifted matrix.                                           
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] WERR                                                  
!> \verbatim                                                            
!>          WERR is REAL array, dimension (N)                           
!>          The first M elements contain the semiwidth of the uncertaint
!>          interval of the corresponding eigenvalue in W               
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] WGAP                                                  
!> \verbatim                                                            
!>          WGAP is REAL array, dimension (N)                           
!>          The separation from the right neighbor eigenvalue in W.     
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IBLOCK                                                    
!> \verbatim                                                            
!>          IBLOCK is INTEGER array, dimension (N)                      
!>          The indices of the blocks (submatrices) associated with the 
!>          corresponding eigenvalues in W; IBLOCK(i)=1 if eigenvalue   
!>          W(i) belongs to the first block from the top, =2 if W(i)    
!>          belongs to the second block, etc.                           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INDEXW                                                    
!> \verbatim                                                            
!>          INDEXW is INTEGER array, dimension (N)                      
!>          The indices of the eigenvalues within each block (submatrix)
!>          for example, INDEXW(i)= 10 and IBLOCK(i)=2 imply that the   
!>          i-th eigenvalue W(i) is the 10-th eigenvalue in the second b
!> \endverbatim                                                         
!>                                                                      
!> \param[in] GERS                                                      
!> \verbatim                                                            
!>          GERS is REAL array, dimension (2*N)                         
!>          The N Gerschgorin intervals (the i-th Gerschgorin interval  
      END                                           
!>          is (GERS(2*i-1), GERS(2*i)). The Gerschgorin intervals shoul
!>          be computed from the original UNshifted matrix.             
!> \endverbatim                                                         
!>                                                                      
!> \param[out] Z                                                        
!> \verbatim                                                            
!>          Z is REAL array, dimension (LDZ, max(1,M) )                 
!>          If INFO = 0, the first M columns of Z contain the           
!>          orthonormal eigenvectors of the matrix T                    
!>          corresponding to the input eigenvalues, with the i-th       
!>          column of Z holding the eigenvector associated with W(i).   
!>          Note: the user must ensure that at least max(1,M) columns ar
!>          supplied in the array Z.                                    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDZ                                                       
!> \verbatim                                                            
!>          LDZ is INTEGER                                              
!>          The leading dimension of the array Z.  LDZ >= 1, and if     
!>          JOBZ = 'V', LDZ >= max(1,N).                                
!> \endverbatim                                                         
!>                                                                      
!> \param[out] ISUPPZ                                                   
!> \verbatim                                                            
!>          ISUPPZ is INTEGER array, dimension ( 2*max(1,M) )           
!>          The support of the eigenvectors in Z, i.e., the indices     
!>          indicating the nonzero elements in Z. The I-th eigenvector  
!>          is nonzero only in elements ISUPPZ( 2*I-1 ) through         
!>          ISUPPZ( 2*I ).                                              
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is REAL array, dimension (12*N)                        
!> \endverbatim                                                         
!>                                                                      
!> \param[out] IWORK                                                    
!> \verbatim                                                            
!>          IWORK is INTEGER array, dimension (7*N)                     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0:  successful exit                                       
!>                                                                      
!>          > 0:  A problem occurred in SLARRV.                         
!>          < 0:  One of the called subroutines signaled an internal pro
!>                Needs inspection of the corresponding parameter IINFO 
!>                for further information.                              
!>                                                                      
!>          =-1:  Problem in SLARRB when refining a child's eigenvalues.
!>          =-2:  Problem in SLARRF when computing the RRR of a child.  
!>                When a child is inside a tight cluster, it can be diff
!>                to find an RRR. A partial remedy from the user's point
!>                view is to make the parameter MINRGP smaller and recom
!>                However, as the orthogonality of the computed vectors 
!>                proportional to 1/MINRGP, the user should be aware tha
!>                he might be trading in precision when he decreases MIN
!>          =-3:  Problem in SLARRB when refining a single eigenvalue   
!>                after the Rayleigh correction was rejected.           
!>          = 5:  The Rayleigh Quotient Iteration failed to converge to 
!>                full accuracy in MAXITR steps.                        
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2016                                                      
!                                                                       
!> \ingroup realOTHERauxiliary                                          
!                                                                       
!> \par Contributors:                                                   
!  ==================                                                   
!>                                                                      
!> Beresford Parlett, University of California, Berkeley, USA \n        
!> Jim Demmel, University of California, Berkeley, USA \n               
!> Inderjit Dhillon, University of Texas, Austin, USA \n                
!> Osni Marques, LBNL/NERSC, USA \n                                     
!> Christof Voemel, University of California, Berkeley, USA             
!                                                                       
!  =====================================================================
      SUBROUTINE SLARRV( N, VL, VU, D, L, PIVMIN,                       &
     &                   ISPLIT, M, DOL, DOU, MINRGP,                   &
     &                   RTOL1, RTOL2, W, WERR, WGAP,                   &
     &                   IBLOCK, INDEXW, GERS, Z, LDZ, ISUPPZ,          &
     &                   WORK, IWORK, INFO )                            
!                                                                       
!  -- LAPACK auxiliary routine (version 3.8.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2016                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            DOL, DOU, INFO, LDZ, M, N 
      REAL               MINRGP, PIVMIN, RTOL1, RTOL2, VL, VU 
!     ..                                                                
!     .. Array Arguments ..                                             
      INTEGER            IBLOCK( * ), INDEXW( * ), ISPLIT( * ),         &
     &                   ISUPPZ( * ), IWORK( * )                        
      REAL               D( * ), GERS( * ), L( * ), W( * ), WERR( * ),  &
     &                   WGAP( * ), WORK( * )                           
      REAL              Z( LDZ, * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      INTEGER            MAXITR 
      PARAMETER          ( MAXITR = 10 ) 
      REAL               ZERO, ONE, TWO, THREE, FOUR, HALF 
      PARAMETER          ( ZERO = 0.0E0, ONE = 1.0E0,                   &
     &                     TWO = 2.0E0, THREE = 3.0E0,                  &
     &                     FOUR = 4.0E0, HALF = 0.5E0)                  
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            ESKIP, NEEDBS, STP2II, TRYRQC, USEDBS, USEDRQ 
      INTEGER            DONE, I, IBEGIN, IDONE, IEND, II, IINDC1,      &
     &                   IINDC2, IINDR, IINDWK, IINFO, IM, IN, INDEIG,  &
     &                   INDLD, INDLLD, INDWRK, ISUPMN, ISUPMX, ITER,   &
     &                   ITMP1, J, JBLK, K, MINIWSIZE, MINWSIZE, NCLUS, &
     &                   NDEPTH, NEGCNT, NEWCLS, NEWFST, NEWFTT, NEWLST,&
     &                   NEWSIZ, OFFSET, OLDCLS, OLDFST, OLDIEN, OLDLST,&
     &                   OLDNCL, P, PARITY, Q, WBEGIN, WEND, WINDEX,    &
     &                   WINDMN, WINDPL, ZFROM, ZTO, ZUSEDL, ZUSEDU,    &
     &                   ZUSEDW                                         
      REAL               BSTRES, BSTW, EPS, FUDGE, GAP, GAPTOL, GL, GU, &
     &                   LAMBDA, LEFT, LGAP, MINGMA, NRMINV, RESID,     &
     &                   RGAP, RIGHT, RQCORR, RQTOL, SAVGAP, SGNDEF,    &
     &                   SIGMA, SPDIAM, SSIGMA, TAU, TMP, TOL, ZTZ      
!     ..                                                                
!     .. External Functions ..                                          
      REAL              SLAMCH 
      EXTERNAL           SLAMCH 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           SCOPY, SLAR1V, SLARRB, SLARRF, SLASET,         &
     &                   SSCAL                                          
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC ABS, REAL, MAX, MIN 
!     ..                                                                
!     .. Executable Statements ..                                       
!     ..                                                                
                                                                        
      INFO = 0 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.LE.0 ) THEN 
         RETURN 
      END IF 
!                                                                       
!     The first N entries of WORK are reserved for the eigenvalues      
      INDLD = N+1 
      INDLLD= 2*N+1 
      INDWRK= 3*N+1 
      MINWSIZE = 12 * N 
                                                                        
      DO 5 I= 1,MINWSIZE 
         WORK( I ) = ZERO 
    5 END DO 
                                                                        
!     IWORK(IINDR+1:IINDR+N) hold the twist indices R for the           
!     factorization used to compute the FP vector                       
      IINDR = 0 
!     IWORK(IINDC1+1:IINC2+N) are used to store the clusters of the curr
!     layer and the one above.                                          
      IINDC1 = N 
      IINDC2 = 2*N 
      IINDWK = 3*N + 1 
                                                                        
      MINIWSIZE = 7 * N 
      DO 10 I= 1,MINIWSIZE 
         IWORK( I ) = 0 
   10 END DO 
                                                                        
      ZUSEDL = 1 
      IF(DOL.GT.1) THEN 
!        Set lower bound for use of Z                                   
         ZUSEDL = DOL-1 
      ENDIF 
      ZUSEDU = M 
      IF(DOU.LT.M) THEN 
!        Set lower bound for use of Z                                   
         ZUSEDU = DOU+1 
      ENDIF 
!     The width of the part of Z that is used                           
      ZUSEDW = ZUSEDU - ZUSEDL + 1 
                                                                        
                                                                        
      CALL SLASET( 'Full', N, ZUSEDW, ZERO, ZERO,                       &
     &                    Z(1,ZUSEDL), LDZ )                            
                                                                        
      EPS = SLAMCH( 'Precision' ) 
      RQTOL = TWO * EPS 
!                                                                       
!     Set expert flags for standard code.                               
      TRYRQC = .TRUE. 
                                                                        
      IF((DOL.EQ.1).AND.(DOU.EQ.M)) THEN 
      ELSE 
!        Only selected eigenpairs are computed. Since the other evalues 
!        are not refined by RQ iteration, bisection has to compute to fu
!        accuracy.                                                      
         RTOL1 = FOUR * EPS 
         RTOL2 = FOUR * EPS 
      ENDIF 
                                                                        
!     The entries WBEGIN:WEND in W, WERR, WGAP correspond to the        
!     desired eigenvalues. The support of the nonzero eigenvector       
!     entries is contained in the interval IBEGIN:IEND.                 
!     Remark that if k eigenpairs are desired, then the eigenvectors    
!     are stored in k contiguous columns of Z.                          
                                                                        
!     DONE is the number of eigenvectors already computed               
      DONE = 0 
      IBEGIN = 1 
      WBEGIN = 1 
      DO 170 JBLK = 1, IBLOCK( M ) 
         IEND = ISPLIT( JBLK ) 
         SIGMA = L( IEND ) 
!        Find the eigenvectors of the submatrix indexed IBEGIN          
!        through IEND.                                                  
         WEND = WBEGIN - 1 
   15    CONTINUE 
         IF( WEND.LT.M ) THEN 
            IF( IBLOCK( WEND+1 ).EQ.JBLK ) THEN 
               WEND = WEND + 1 
               GO TO 15 
            END IF 
         END IF 
         IF( WEND.LT.WBEGIN ) THEN 
            IBEGIN = IEND + 1 
            GO TO 170 
         ELSEIF( (WEND.LT.DOL).OR.(WBEGIN.GT.DOU) ) THEN 
            IBEGIN = IEND + 1 
            WBEGIN = WEND + 1 
            GO TO 170 
         END IF 
                                                                        
!        Find local spectral diameter of the block                      
         GL = GERS( 2*IBEGIN-1 ) 
         GU = GERS( 2*IBEGIN ) 
         DO 20 I = IBEGIN+1 , IEND 
            GL = MIN( GERS( 2*I-1 ), GL ) 
            GU = MAX( GERS( 2*I ), GU ) 
   20    CONTINUE 
         SPDIAM = GU - GL 
                                                                        
!        OLDIEN is the last index of the previous block                 
         OLDIEN = IBEGIN - 1 
!        Calculate the size of the current block                        
         IN = IEND - IBEGIN + 1 
!        The number of eigenvalues in the current block                 
         IM = WEND - WBEGIN + 1 
                                                                        
!        This is for a 1x1 block                                        
         IF( IBEGIN.EQ.IEND ) THEN 
            DONE = DONE+1 
            Z( IBEGIN, WBEGIN ) = ONE 
            ISUPPZ( 2*WBEGIN-1 ) = IBEGIN 
            ISUPPZ( 2*WBEGIN ) = IBEGIN 
            W( WBEGIN ) = W( WBEGIN ) + SIGMA 
            WORK( WBEGIN ) = W( WBEGIN ) 
            IBEGIN = IEND + 1 
            WBEGIN = WBEGIN + 1 
            GO TO 170 
         END IF 
                                                                        
!        The desired (shifted) eigenvalues are stored in W(WBEGIN:WEND) 
!        Note that these can be approximations, in this case, the corres
!        entries of WERR give the size of the uncertainty interval.     
!        The eigenvalue approximations will be refined when necessary as
!        high relative accuracy is required for the computation of the  
!        corresponding eigenvectors.                                    
         CALL SCOPY( IM, W( WBEGIN ), 1,                                &
     &                   WORK( WBEGIN ), 1 )                            
                                                                        
!        We store in W the eigenvalue approximations w.r.t. the original
!        matrix T.                                                      
         DO 30 I=1,IM 
            W(WBEGIN+I-1) = W(WBEGIN+I-1)+SIGMA 
   30    CONTINUE 
                                                                        
                                                                        
!        NDEPTH is the current depth of the representation tree         
         NDEPTH = 0 
!        PARITY is either 1 or 0                                        
         PARITY = 1 
!        NCLUS is the number of clusters for the next level of the      
!        representation tree, we start with NCLUS = 1 for the root      
         NCLUS = 1 
         IWORK( IINDC1+1 ) = 1 
         IWORK( IINDC1+2 ) = IM 
                                                                        
!        IDONE is the number of eigenvectors already computed in the cur
!        block                                                          
         IDONE = 0 
!        loop while( IDONE.LT.IM )                                      
!        generate the representation tree for the current block and     
!        compute the eigenvectors                                       
   40    CONTINUE 
         IF( IDONE.LT.IM ) THEN 
!           This is a crude protection against infinitely deep trees    
            IF( NDEPTH.GT.M ) THEN 
               INFO = -2 
               RETURN 
            ENDIF 
!           breadth first processing of the current level of the represe
!           tree: OLDNCL = number of clusters on current level          
            OLDNCL = NCLUS 
!           reset NCLUS to count the number of child clusters           
            NCLUS = 0 
!                                                                       
            PARITY = 1 - PARITY 
            IF( PARITY.EQ.0 ) THEN 
               OLDCLS = IINDC1 
               NEWCLS = IINDC2 
            ELSE 
               OLDCLS = IINDC2 
               NEWCLS = IINDC1 
            END IF 
!           Process the clusters on the current level                   
            DO 150 I = 1, OLDNCL 
               J = OLDCLS + 2*I 
!              OLDFST, OLDLST = first, last index of current cluster.   
!                               cluster indices start with 1 and are rel
!                               to WBEGIN when accessing W, WGAP, WERR, 
               OLDFST = IWORK( J-1 ) 
               OLDLST = IWORK( J ) 
               IF( NDEPTH.GT.0 ) THEN 
!                 Retrieve relatively robust representation (RRR) of clu
!                 that has been computed at the previous level          
!                 The RRR is stored in Z and overwritten once the eigenv
!                 have been computed or when the cluster is refined     
                                                                        
                  IF((DOL.EQ.1).AND.(DOU.EQ.M)) THEN 
!                    Get representation from location of the leftmost ev
!                    of the cluster                                     
                     J = WBEGIN + OLDFST - 1 
                  ELSE 
                     IF(WBEGIN+OLDFST-1.LT.DOL) THEN 
!                       Get representation from the left end of Z array 
                        J = DOL - 1 
                     ELSEIF(WBEGIN+OLDFST-1.GT.DOU) THEN 
!                       Get representation from the right end of Z array
                        J = DOU 
                     ELSE 
                        J = WBEGIN + OLDFST - 1 
                     ENDIF 
                  ENDIF 
                  CALL SCOPY( IN, Z( IBEGIN, J ), 1, D( IBEGIN ), 1 ) 
                  CALL SCOPY( IN-1, Z( IBEGIN, J+1 ), 1, L( IBEGIN ),   &
     &               1 )                                                
                  SIGMA = Z( IEND, J+1 ) 
                                                                        
!                 Set the corresponding entries in Z to zero            
                  CALL SLASET( 'Full', IN, 2, ZERO, ZERO,               &
     &                         Z( IBEGIN, J), LDZ )                     
               END IF 
                                                                        
!              Compute DL and DLL of current RRR                        
               DO 50 J = IBEGIN, IEND-1 
                  TMP = D( J )*L( J ) 
                  WORK( INDLD-1+J ) = TMP 
                  WORK( INDLLD-1+J ) = TMP*L( J ) 
   50          CONTINUE 
                                                                        
               IF( NDEPTH.GT.0 ) THEN 
!                 P and Q are index of the first and last eigenvalue to 
!                 within the current block                              
                  P = INDEXW( WBEGIN-1+OLDFST ) 
                  Q = INDEXW( WBEGIN-1+OLDLST ) 
!                 Offset for the arrays WORK, WGAP and WERR, i.e., the P
!                 through the Q-OFFSET elements of these arrays are to b
!                  OFFSET = P-OLDFST                                    
                  OFFSET = INDEXW( WBEGIN ) - 1 
!                 perform limited bisection (if necessary) to get approx
!                 eigenvalues to the precision needed.                  
                  CALL SLARRB( IN, D( IBEGIN ),                         &
     &                         WORK(INDLLD+IBEGIN-1),                   &
     &                         P, Q, RTOL1, RTOL2, OFFSET,              &
     &                         WORK(WBEGIN),WGAP(WBEGIN),WERR(WBEGIN),  &
     &                         WORK( INDWRK ), IWORK( IINDWK ),         &
     &                         PIVMIN, SPDIAM, IN, IINFO )              
                  IF( IINFO.NE.0 ) THEN 
                     INFO = -1 
                     RETURN 
                  ENDIF 
!                 We also recompute the extremal gaps. W holds all eigen
!                 of the unshifted matrix and must be used for computati
!                 of WGAP, the entries of WORK might stem from RRRs with
!                 different shifts. The gaps from WBEGIN-1+OLDFST to    
!                 WBEGIN-1+OLDLST are correctly computed in SLARRB.     
!                 However, we only allow the gaps to become greater sinc
!                 this is what should happen when we decrease WERR      
                  IF( OLDFST.GT.1) THEN 
                     WGAP( WBEGIN+OLDFST-2 ) =                          &
     &             MAX(WGAP(WBEGIN+OLDFST-2),                           &
     &                 W(WBEGIN+OLDFST-1)-WERR(WBEGIN+OLDFST-1)         &
     &                 - W(WBEGIN+OLDFST-2)-WERR(WBEGIN+OLDFST-2) )     
                  ENDIF 
                  IF( WBEGIN + OLDLST -1 .LT. WEND ) THEN 
                     WGAP( WBEGIN+OLDLST-1 ) =                          &
     &               MAX(WGAP(WBEGIN+OLDLST-1),                         &
     &                   W(WBEGIN+OLDLST)-WERR(WBEGIN+OLDLST)           &
     &                   - W(WBEGIN+OLDLST-1)-WERR(WBEGIN+OLDLST-1) )   
                  ENDIF 
!                 Each time the eigenvalues in WORK get refined, we stor
!                 the newly found approximation with all shifts applied 
                  DO 53 J=OLDFST,OLDLST 
                     W(WBEGIN+J-1) = WORK(WBEGIN+J-1)+SIGMA 
   53             CONTINUE 
               END IF 
                                                                        
!              Process the current node.                                
               NEWFST = OLDFST 
               DO 140 J = OLDFST, OLDLST 
                  IF( J.EQ.OLDLST ) THEN 
!                    we are at the right end of the cluster, this is als
!                    boundary of the child cluster                      
                     NEWLST = J 
                  ELSE IF ( WGAP( WBEGIN + J -1).GE.                    &
     &                    MINRGP* ABS( WORK(WBEGIN + J -1) ) ) THEN     
!                    the right relative gap is big enough, the child clu
!                    (NEWFST,..,NEWLST) is well separated from the follo
                     NEWLST = J 
                   ELSE 
!                    inside a child cluster, the relative gap is not    
!                    big enough.                                        
                     GOTO 140 
                  END IF 
                                                                        
!                 Compute size of child cluster found                   
                  NEWSIZ = NEWLST - NEWFST + 1 
                                                                        
!                 NEWFTT is the place in Z where the new RRR or the comp
!                 eigenvector is to be stored                           
                  IF((DOL.EQ.1).AND.(DOU.EQ.M)) THEN 
!                    Store representation at location of the leftmost ev
!                    of the cluster                                     
                     NEWFTT = WBEGIN + NEWFST - 1 
                  ELSE 
                     IF(WBEGIN+NEWFST-1.LT.DOL) THEN 
!                       Store representation at the left end of Z array 
                        NEWFTT = DOL - 1 
                     ELSEIF(WBEGIN+NEWFST-1.GT.DOU) THEN 
!                       Store representation at the right end of Z array
                        NEWFTT = DOU 
                     ELSE 
                        NEWFTT = WBEGIN + NEWFST - 1 
                     ENDIF 
                  ENDIF 
                                                                        
                  IF( NEWSIZ.GT.1) THEN 
!                                                                       
!                    Current child is not a singleton but a cluster.    
!                    Compute and store new representation of child.     
!                                                                       
!                                                                       
!                    Compute left and right cluster gap.                
!                                                                       
!                    LGAP and RGAP are not computed from WORK because   
!                    the eigenvalue approximations may stem from RRRs   
!                    different shifts. However, W hold all eigenvalues  
!                    of the unshifted matrix. Still, the entries in WGAP
!                    have to be computed from WORK since the entries    
!                    in W might be of the same order so that gaps are no
!                    exhibited correctly for very close eigenvalues.    
                     IF( NEWFST.EQ.1 ) THEN 
                        LGAP = MAX( ZERO,                               &
     &                       W(WBEGIN)-WERR(WBEGIN) - VL )              
                    ELSE 
                        LGAP = WGAP( WBEGIN+NEWFST-2 ) 
                     ENDIF 
                     RGAP = WGAP( WBEGIN+NEWLST-1 ) 
!                                                                       
!                    Compute left- and rightmost eigenvalue of child    
!                    to high precision in order to shift as close       
!                    as possible and obtain as large relative gaps      
!                    as possible                                        
!                                                                       
                     DO 55 K =1,2 
                        IF(K.EQ.1) THEN 
                           P = INDEXW( WBEGIN-1+NEWFST ) 
                        ELSE 
                           P = INDEXW( WBEGIN-1+NEWLST ) 
                        ENDIF 
                        OFFSET = INDEXW( WBEGIN ) - 1 
                        CALL SLARRB( IN, D(IBEGIN),                     &
     &                       WORK( INDLLD+IBEGIN-1 ),P,P,               &
     &                       RQTOL, RQTOL, OFFSET,                      &
     &                       WORK(WBEGIN),WGAP(WBEGIN),                 &
     &                       WERR(WBEGIN),WORK( INDWRK ),               &
     &                       IWORK( IINDWK ), PIVMIN, SPDIAM,           &
     &                       IN, IINFO )                                
   55                CONTINUE 
!                                                                       
                     IF((WBEGIN+NEWLST-1.LT.DOL).OR.                    &
     &                  (WBEGIN+NEWFST-1.GT.DOU)) THEN                  
!                       if the cluster contains no desired eigenvalues  
!                       skip the computation of that branch of the rep. 
!                                                                       
!                       We could skip before the refinement of the extre
!                       eigenvalues of the child, but then the represent
!                       tree could be different from the one when nothin
!                       skipped. For this reason we skip at this place. 
                        IDONE = IDONE + NEWLST - NEWFST + 1 
                        GOTO 139 
                     ENDIF 
!                                                                       
!                    Compute RRR of child cluster.                      
!                    Note that the new RRR is stored in Z               
!                                                                       
!                    SLARRF needs LWORK = 2*N                           
                     CALL SLARRF( IN, D( IBEGIN ), L( IBEGIN ),         &
     &                         WORK(INDLD+IBEGIN-1),                    &
     &                         NEWFST, NEWLST, WORK(WBEGIN),            &
     &                         WGAP(WBEGIN), WERR(WBEGIN),              &
     &                         SPDIAM, LGAP, RGAP, PIVMIN, TAU,         &
     &                         Z(IBEGIN, NEWFTT),Z(IBEGIN, NEWFTT+1),   &
     &                         WORK( INDWRK ), IINFO )                  
                     IF( IINFO.EQ.0 ) THEN 
!                       a new RRR for the cluster was found by SLARRF   
!                       update shift and store it                       
                        SSIGMA = SIGMA + TAU 
                        Z( IEND, NEWFTT+1 ) = SSIGMA 
!                       WORK() are the midpoints and WERR() the semi-wid
!                       Note that the entries in W are unchanged.       
                        DO 116 K = NEWFST, NEWLST 
                           FUDGE =                                      &
     &                          THREE*EPS*ABS(WORK(WBEGIN+K-1))         
                           WORK( WBEGIN + K - 1 ) =                     &
     &                          WORK( WBEGIN + K - 1) - TAU             
                           FUDGE = FUDGE +                              &
     &                          FOUR*EPS*ABS(WORK(WBEGIN+K-1))          
!                          Fudge errors                                 
                           WERR( WBEGIN + K - 1 ) =                     &
     &                          WERR( WBEGIN + K - 1 ) + FUDGE          
!                          Gaps are not fudged. Provided that WERR is sm
!                          when eigenvalues are close, a zero gap indica
!                          that a new representation is needed for resol
!                          the cluster. A fudge could lead to a wrong de
!                          of judging eigenvalues 'separated' which in  
!                          reality are not. This could have a negative i
!                          on the orthogonality of the computed eigenvec
  116                   CONTINUE 
                                                                        
                        NCLUS = NCLUS + 1 
                        K = NEWCLS + 2*NCLUS 
                        IWORK( K-1 ) = NEWFST 
                        IWORK( K ) = NEWLST 
                     ELSE 
                        INFO = -2 
                        RETURN 
                     ENDIF 
                  ELSE 
!                                                                       
!                    Compute eigenvector of singleton                   
!                                                                       
                     ITER = 0 
!                                                                       
                     TOL = FOUR * LOG(REAL(IN)) * EPS 
!                                                                       
                     K = NEWFST 
                     WINDEX = WBEGIN + K - 1 
                     WINDMN = MAX(WINDEX - 1,1) 
                     WINDPL = MIN(WINDEX + 1,M) 
                     LAMBDA = WORK( WINDEX ) 
                     DONE = DONE + 1 
!                    Check if eigenvector computation is to be skipped  
                     IF((WINDEX.LT.DOL).OR.                             &
     &                  (WINDEX.GT.DOU)) THEN                           
                        ESKIP = .TRUE. 
                        GOTO 125 
                     ELSE 
                        ESKIP = .FALSE. 
                     ENDIF 
                     LEFT = WORK( WINDEX ) - WERR( WINDEX ) 
                     RIGHT = WORK( WINDEX ) + WERR( WINDEX ) 
                     INDEIG = INDEXW( WINDEX ) 
!                    Note that since we compute the eigenpairs for a chi
!                    all eigenvalue approximations are w.r.t the same sh
!                    In this case, the entries in WORK should be used fo
!                    computing the gaps since they exhibit even very sma
!                    differences in the eigenvalues, as opposed to the  
!                    entries in W which might "look" the same.          
                                                                        
                     IF( K .EQ. 1) THEN 
!                       In the case RANGE='I' and with not much initial 
!                       accuracy in LAMBDA and VL, the formula          
!                       LGAP = MAX( ZERO, (SIGMA - VL) + LAMBDA )       
!                       can lead to an overestimation of the left gap an
!                       thus to inadequately early RQI 'convergence'.   
!                       Prevent this by forcing a small left gap.       
                        LGAP = EPS*MAX(ABS(LEFT),ABS(RIGHT)) 
                     ELSE 
                        LGAP = WGAP(WINDMN) 
                     ENDIF 
                     IF( K .EQ. IM) THEN 
!                       In the case RANGE='I' and with not much initial 
!                       accuracy in LAMBDA and VU, the formula          
!                       can lead to an overestimation of the right gap a
!                       thus to inadequately early RQI 'convergence'.   
!                       Prevent this by forcing a small right gap.      
                        RGAP = EPS*MAX(ABS(LEFT),ABS(RIGHT)) 
                     ELSE 
                        RGAP = WGAP(WINDEX) 
                     ENDIF 
                     GAP = MIN( LGAP, RGAP ) 
                     IF(( K .EQ. 1).OR.(K .EQ. IM)) THEN 
!                       The eigenvector support can become wrong        
!                       because significant entries could be cut off due
!                       large GAPTOL parameter in LAR1V. Prevent this.  
                        GAPTOL = ZERO 
                     ELSE 
                        GAPTOL = GAP * EPS 
                     ENDIF 
                     ISUPMN = IN 
                     ISUPMX = 1 
!                    Update WGAP so that it holds the minimum gap       
!                    to the left or the right. This is crucial in the   
!                    case where bisection is used to ensure that the    
!                    eigenvalue is refined up to the required precision.
!                    The correct value is restored afterwards.          
                     SAVGAP = WGAP(WINDEX) 
                     WGAP(WINDEX) = GAP 
!                    We want to use the Rayleigh Quotient Correction    
!                    as often as possible since it converges quadratical
!                    when we are close enough to the desired eigenvalue.
!                    However, the Rayleigh Quotient can have the wrong s
!                    and lead us away from the desired eigenvalue. In th
!                    case, the best we can do is to use bisection.      
                     USEDBS = .FALSE. 
                     USEDRQ = .FALSE. 
!                    Bisection is initially turned off unless it is forc
                     NEEDBS =  .NOT.TRYRQC 
  120                CONTINUE 
!                    Check if bisection should be used to refine eigenva
                     IF(NEEDBS) THEN 
!                       Take the bisection as new iterate               
                        USEDBS = .TRUE. 
                        ITMP1 = IWORK( IINDR+WINDEX ) 
                        OFFSET = INDEXW( WBEGIN ) - 1 
                        CALL SLARRB( IN, D(IBEGIN),                     &
     &                       WORK(INDLLD+IBEGIN-1),INDEIG,INDEIG,       &
     &                       ZERO, TWO*EPS, OFFSET,                     &
     &                       WORK(WBEGIN),WGAP(WBEGIN),                 &
     &                       WERR(WBEGIN),WORK( INDWRK ),               &
     &                       IWORK( IINDWK ), PIVMIN, SPDIAM,           &
     &                       ITMP1, IINFO )                             
                        IF( IINFO.NE.0 ) THEN 
                           INFO = -3 
                           RETURN 
                        ENDIF 
                        LAMBDA = WORK( WINDEX ) 
!                       Reset twist index from inaccurate LAMBDA to     
!                       force computation of true MINGMA                
                        IWORK( IINDR+WINDEX ) = 0 
                     ENDIF 
!                    Given LAMBDA, compute the eigenvector.             
                     CALL SLAR1V( IN, 1, IN, LAMBDA, D( IBEGIN ),       &
     &                    L( IBEGIN ), WORK(INDLD+IBEGIN-1),            &
     &                    WORK(INDLLD+IBEGIN-1),                        &
     &                    PIVMIN, GAPTOL, Z( IBEGIN, WINDEX ),          &
     &                    .NOT.USEDBS, NEGCNT, ZTZ, MINGMA,             &
     &                    IWORK( IINDR+WINDEX ), ISUPPZ( 2*WINDEX-1 ),  &
     &                    NRMINV, RESID, RQCORR, WORK( INDWRK ) )       
                     IF(ITER .EQ. 0) THEN 
                        BSTRES = RESID 
                        BSTW = LAMBDA 
                     ELSEIF(RESID.LT.BSTRES) THEN 
                        BSTRES = RESID 
                        BSTW = LAMBDA 
                     ENDIF 
                     ISUPMN = MIN(ISUPMN,ISUPPZ( 2*WINDEX-1 )) 
                     ISUPMX = MAX(ISUPMX,ISUPPZ( 2*WINDEX )) 
                     ITER = ITER + 1 
                                                                        
!                    sin alpha <= |resid|/gap                           
!                    Note that both the residual and the gap are        
!                    proportional to the matrix, so ||T|| doesn't play  
!                    a role in the quotient                             
                                                                        
!                                                                       
!                    Convergence test for Rayleigh-Quotient iteration   
!                    (omitted when Bisection has been used)             
!                                                                       
                     IF( RESID.GT.TOL*GAP .AND. ABS( RQCORR ).GT.       &
     &                    RQTOL*ABS( LAMBDA ) .AND. .NOT. USEDBS)       &
     &                    THEN                                          
!                       We need to check that the RQCORR update doesn't 
!                       move the eigenvalue away from the desired one an
!                       towards a neighbor. -> protection with bisection
                        IF(INDEIG.LE.NEGCNT) THEN 
!                          The wanted eigenvalue lies to the left       
                           SGNDEF = -ONE 
                        ELSE 
!                          The wanted eigenvalue lies to the right      
                           SGNDEF = ONE 
                        ENDIF 
!                       We only use the RQCORR if it improves the       
!                       the iterate reasonably.                         
                        IF( ( RQCORR*SGNDEF.GE.ZERO )                   &
     &                       .AND.( LAMBDA + RQCORR.LE. RIGHT)          &
     &                       .AND.( LAMBDA + RQCORR.GE. LEFT)           &
     &                       ) THEN                                     
                           USEDRQ = .TRUE. 
!                          Store new midpoint of bisection interval in W
                           IF(SGNDEF.EQ.ONE) THEN 
!                             The current LAMBDA is on the left of the t
!                             eigenvalue                                
                              LEFT = LAMBDA 
!                             We prefer to assume that the error estimat
!                             is correct. We could make the interval not
!                             as a bracket but to be modified if the RQC
!                             chooses to. In this case, the RIGHT side s
!                             be modified as follows:                   
!                              RIGHT = MAX(RIGHT, LAMBDA + RQCORR)      
                           ELSE 
!                             The current LAMBDA is on the right of the 
!                             eigenvalue                                
                              RIGHT = LAMBDA 
!                             See comment about assuming the error estim
!                             correct above.                            
!                              LEFT = MIN(LEFT, LAMBDA + RQCORR)        
                           ENDIF 
                           WORK( WINDEX ) =                             &
     &                       HALF * (RIGHT + LEFT)                      
!                          Take RQCORR since it has the correct sign and
!                          improves the iterate reasonably              
                           LAMBDA = LAMBDA + RQCORR 
!                          Update width of error interval               
                           WERR( WINDEX ) =                             &
     &                             HALF * (RIGHT-LEFT)                  
                        ELSE 
                           NEEDBS = .TRUE. 
                        ENDIF 
                        IF(RIGHT-LEFT.LT.RQTOL*ABS(LAMBDA)) THEN 
!                             The eigenvalue is computed to bisection ac
!                             compute eigenvector and stop              
                           USEDBS = .TRUE. 
                           GOTO 120 
                        ELSEIF( ITER.LT.MAXITR ) THEN 
                           GOTO 120 
                        ELSEIF( ITER.EQ.MAXITR ) THEN 
                           NEEDBS = .TRUE. 
                           GOTO 120 
                        ELSE 
                           INFO = 5 
                           RETURN 
                        END IF 
                     ELSE 
                        STP2II = .FALSE. 
        IF(USEDRQ .AND. USEDBS .AND.                                    &
     &                     BSTRES.LE.RESID) THEN                        
                           LAMBDA = BSTW 
                           STP2II = .TRUE. 
                        ENDIF 
                        IF (STP2II) THEN 
!                          improve error angle by second step           
                           CALL SLAR1V( IN, 1, IN, LAMBDA,              &
     &                          D( IBEGIN ), L( IBEGIN ),               &
     &                          WORK(INDLD+IBEGIN-1),                   &
     &                          WORK(INDLLD+IBEGIN-1),                  &
     &                          PIVMIN, GAPTOL, Z( IBEGIN, WINDEX ),    &
     &                          .NOT.USEDBS, NEGCNT, ZTZ, MINGMA,       &
     &                          IWORK( IINDR+WINDEX ),                  &
     &                          ISUPPZ( 2*WINDEX-1 ),                   &
     &                          NRMINV, RESID, RQCORR, WORK( INDWRK ) ) 
                        ENDIF 
                        WORK( WINDEX ) = LAMBDA 
                     END IF 
!                                                                       
!                    Compute FP-vector support w.r.t. whole matrix      
!                                                                       
                     ISUPPZ( 2*WINDEX-1 ) = ISUPPZ( 2*WINDEX-1 )+OLDIEN 
                     ISUPPZ( 2*WINDEX ) = ISUPPZ( 2*WINDEX )+OLDIEN 
                     ZFROM = ISUPPZ( 2*WINDEX-1 ) 
                     ZTO = ISUPPZ( 2*WINDEX ) 
                     ISUPMN = ISUPMN + OLDIEN 
                     ISUPMX = ISUPMX + OLDIEN 
!                    Ensure vector is ok if support in the RQI has chang
                     IF(ISUPMN.LT.ZFROM) THEN 
                        DO 122 II = ISUPMN,ZFROM-1 
                           Z( II, WINDEX ) = ZERO 
  122                   CONTINUE 
                     ENDIF 
                     IF(ISUPMX.GT.ZTO) THEN 
                        DO 123 II = ZTO+1,ISUPMX 
                           Z( II, WINDEX ) = ZERO 
  123                   CONTINUE 
                     ENDIF 
                     CALL SSCAL( ZTO-ZFROM+1, NRMINV,                   &
     &                       Z( ZFROM, WINDEX ), 1 )                    
  125                CONTINUE 
!                    Update W                                           
                     W( WINDEX ) = LAMBDA+SIGMA 
!                    Recompute the gaps on the left and right           
!                    But only allow them to become larger and not       
!                    smaller (which can only happen through "bad"       
!                    cancellation and doesn't reflect the theory        
!                    where the initial gaps are underestimated due      
!                    to WERR being too crude.)                          
                     IF(.NOT.ESKIP) THEN 
                        IF( K.GT.1) THEN 
                           WGAP( WINDMN ) = MAX( WGAP(WINDMN),          &
     &                          W(WINDEX)-WERR(WINDEX)                  &
     &                          - W(WINDMN)-WERR(WINDMN) )              
                        ENDIF 
                        IF( WINDEX.LT.WEND ) THEN 
                           WGAP( WINDEX ) = MAX( SAVGAP,                &
     &                          W( WINDPL )-WERR( WINDPL )              &
     &                          - W( WINDEX )-WERR( WINDEX) )           
                        ENDIF 
                     ENDIF 
                     IDONE = IDONE + 1 
                  ENDIF 
!                 here ends the code for the current child              
!                                                                       
  139             CONTINUE 
!                 Proceed to any remaining child nodes                  
                  NEWFST = J + 1 
  140          CONTINUE 
  150       CONTINUE 
            NDEPTH = NDEPTH + 1 
            GO TO 40 
         END IF 
         IBEGIN = IEND + 1 
         WBEGIN = WEND + 1 
  170 END DO 
!                                                                       
                                                                        
      RETURN 
!                                                                       
!     End of SLARRV                                                     
!                                                                       
      END                                           
!> \brief \b SLARUV returns a vector of n random real numbers from a uni
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLARUV + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SLARUV( ISEED, N, X )                                
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            N                                            
!       ..                                                              
!       .. Array Arguments ..                                           
!       INTEGER            ISEED( 4 )                                   
!       REAL               X( N )                                       
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SLARUV returns a vector of n random real numbers from a uniform (0,1)
!> distribution (n <= 128).                                             
!>                                                                      
!> This is an auxiliary routine called by SLARNV and CLARNV.            
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in,out] ISEED                                                 
!> \verbatim                                                            
!>          ISEED is INTEGER array, dimension (4)                       
!>          On entry, the seed of the random number generator; the array
!>          elements must be between 0 and 4095, and ISEED(4) must be   
!>          odd.                                                        
!>          On exit, the seed is updated.                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The number of random numbers to be generated. N <= 128.     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] X                                                        
!> \verbatim                                                            
!>          X is REAL array, dimension (N)                              
!>          The generated random numbers.                               
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  This routine uses a multiplicative congruential method with modulus 
!>  2**48 and multiplier 33952834046453 (see G.S.Fishman,               
!>  'Multiplicative congruential random number generators with modulus  
!>  2**b: an exhaustive analysis for b = 32 and a partial analysis for  
!>  b = 48', Math. Comp. 189, pp 331-344, 1990).                        
!>                                                                      
!>  48-bit integers are stored in 4 integer array elements with 12 bits 
!>  per element. Hence the routine is portable across machines with     
!>  integers of 32 bits or more.                                        
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE SLARUV( ISEED, N, X ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            N 
!     ..                                                                
!     .. Array Arguments ..                                             
      INTEGER            ISEED( 4 ) 
      REAL               X( N ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ONE 
      PARAMETER          ( ONE = 1.0E0 ) 
      INTEGER            LV, IPW2 
      REAL               R 
      PARAMETER          ( LV = 128, IPW2 = 4096, R = ONE / IPW2 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I, I1, I2, I3, I4, IT1, IT2, IT3, IT4, J 
!     ..                                                                
!     .. Local Arrays ..                                                
      INTEGER            MM( LV, 4 ) 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MIN, MOD, REAL 
!     ..                                                                
!     .. Data statements ..                                             
      DATA               ( MM( 1, J ), J = 1, 4 ) / 494, 322, 2508,     &
     &                   2549 /                                         
      DATA               ( MM( 2, J ), J = 1, 4 ) / 2637, 789, 3754,    &
     &                   1145 /                                         
      DATA               ( MM( 3, J ), J = 1, 4 ) / 255, 1440, 1766,    &
     &                   2253 /                                         
      DATA               ( MM( 4, J ), J = 1, 4 ) / 2008, 752, 3572,    &
     &                   305 /                                          
      DATA               ( MM( 5, J ), J = 1, 4 ) / 1253, 2859, 2893,   &
     &                   3301 /                                         
      DATA               ( MM( 6, J ), J = 1, 4 ) / 3344, 123, 307,     &
     &                   1065 /                                         
      DATA               ( MM( 7, J ), J = 1, 4 ) / 4084, 1848, 1297,   &
     &                   3133 /                                         
      DATA               ( MM( 8, J ), J = 1, 4 ) / 1739, 643, 3966,    &
     &                   2913 /                                         
      DATA               ( MM( 9, J ), J = 1, 4 ) / 3143, 2405, 758,    &
     &                   3285 /                                         
      DATA               ( MM( 10, J ), J = 1, 4 ) / 3468, 2638, 2598,  &
     &                   1241 /                                         
      DATA               ( MM( 11, J ), J = 1, 4 ) / 688, 2344, 3406,   &
     &                   1197 /                                         
      DATA               ( MM( 12, J ), J = 1, 4 ) / 1657, 46, 2922,    &
     &                   3729 /                                         
      DATA               ( MM( 13, J ), J = 1, 4 ) / 1238, 3814, 1038,  &
     &                   2501 /                                         
      DATA               ( MM( 14, J ), J = 1, 4 ) / 3166, 913, 2934,   &
     &                   1673 /                                         
      DATA               ( MM( 15, J ), J = 1, 4 ) / 1292, 3649, 2091,  &
     &                   541 /                                          
      DATA               ( MM( 16, J ), J = 1, 4 ) / 3422, 339, 2451,   &
     &                   2753 /                                         
      DATA               ( MM( 17, J ), J = 1, 4 ) / 1270, 3808, 1580,  &
     &                   949 /                                          
      DATA               ( MM( 18, J ), J = 1, 4 ) / 2016, 822, 1958,   &
     &                   2361 /                                         
      DATA               ( MM( 19, J ), J = 1, 4 ) / 154, 2832, 2055,   &
     &                   1165 /                                         
      DATA               ( MM( 20, J ), J = 1, 4 ) / 2862, 3078, 1507,  &
     &                   4081 /                                         
      DATA               ( MM( 21, J ), J = 1, 4 ) / 697, 3633, 1078,   &
     &                   2725 /                                         
      DATA               ( MM( 22, J ), J = 1, 4 ) / 1706, 2970, 3273,  &
     &                   3305 /                                         
      DATA               ( MM( 23, J ), J = 1, 4 ) / 491, 637, 17,      &
     &                   3069 /                                         
      DATA               ( MM( 24, J ), J = 1, 4 ) / 931, 2249, 854,    &
     &                   3617 /                                         
      DATA               ( MM( 25, J ), J = 1, 4 ) / 1444, 2081, 2916,  &
     &                   3733 /                                         
      DATA               ( MM( 26, J ), J = 1, 4 ) / 444, 4019, 3971,   &
     &                   409 /                                          
      DATA               ( MM( 27, J ), J = 1, 4 ) / 3577, 1478, 2889,  &
     &                   2157 /                                         
      DATA               ( MM( 28, J ), J = 1, 4 ) / 3944, 242, 3831,   &
     &                   1361 /                                         
      DATA               ( MM( 29, J ), J = 1, 4 ) / 2184, 481, 2621,   &
     &                   3973 /                                         
      DATA               ( MM( 30, J ), J = 1, 4 ) / 1661, 2075, 1541,  &
     &                   1865 /                                         
      DATA               ( MM( 31, J ), J = 1, 4 ) / 3482, 4058, 893,   &
     &                   2525 /                                         
      DATA               ( MM( 32, J ), J = 1, 4 ) / 657, 622, 736,     &
     &                   1409 /                                         
      DATA               ( MM( 33, J ), J = 1, 4 ) / 3023, 3376, 3992,  &
     &                   3445 /                                         
      DATA               ( MM( 34, J ), J = 1, 4 ) / 3618, 812, 787,    &
     &                   3577 /                                         
      DATA               ( MM( 35, J ), J = 1, 4 ) / 1267, 234, 2125,   &
     &                   77 /                                           
      DATA               ( MM( 36, J ), J = 1, 4 ) / 1828, 641, 2364,   &
     &                   3761 /                                         
      DATA               ( MM( 37, J ), J = 1, 4 ) / 164, 4005, 2460,   &
     &                   2149 /                                         
      DATA               ( MM( 38, J ), J = 1, 4 ) / 3798, 1122, 257,   &
     &                   1449 /                                         
      DATA               ( MM( 39, J ), J = 1, 4 ) / 3087, 3135, 1574,  &
     &                   3005 /                                         
      DATA               ( MM( 40, J ), J = 1, 4 ) / 2400, 2640, 3912,  &
     &                   225 /                                          
      DATA               ( MM( 41, J ), J = 1, 4 ) / 2870, 2302, 1216,  &
     &                   85 /                                           
      DATA               ( MM( 42, J ), J = 1, 4 ) / 3876, 40, 3248,    &
     &                   3673 /                                         
      DATA               ( MM( 43, J ), J = 1, 4 ) / 1905, 1832, 3401,  &
     &                   3117 /                                         
      DATA               ( MM( 44, J ), J = 1, 4 ) / 1593, 2247, 2124,  &
     &                   3089 /                                         
      DATA               ( MM( 45, J ), J = 1, 4 ) / 1797, 2034, 2762,  &
     &                   1349 /                                         
      DATA               ( MM( 46, J ), J = 1, 4 ) / 1234, 2637, 149,   &
     &                   2057 /                                         
      DATA               ( MM( 47, J ), J = 1, 4 ) / 3460, 1287, 2245,  &
     &                   413 /                                          
      DATA               ( MM( 48, J ), J = 1, 4 ) / 328, 1691, 166,    &
     &                   65 /                                           
      DATA               ( MM( 49, J ), J = 1, 4 ) / 2861, 496, 466,    &
     &                   1845 /                                         
      DATA               ( MM( 50, J ), J = 1, 4 ) / 1950, 1597, 4018,  &
     &                   697 /                                          
      DATA               ( MM( 51, J ), J = 1, 4 ) / 617, 2394, 1399,   &
     &                   3085 /                                         
      DATA               ( MM( 52, J ), J = 1, 4 ) / 2070, 2584, 190,   &
     &                   3441 /                                         
      DATA               ( MM( 53, J ), J = 1, 4 ) / 3331, 1843, 2879,  &
     &                   1573 /                                         
      DATA               ( MM( 54, J ), J = 1, 4 ) / 769, 336, 153,     &
     &                   3689 /                                         
      DATA               ( MM( 55, J ), J = 1, 4 ) / 1558, 1472, 2320,  &
     &                   2941 /                                         
      DATA               ( MM( 56, J ), J = 1, 4 ) / 2412, 2407, 18,    &
     &                   929 /                                          
      DATA               ( MM( 57, J ), J = 1, 4 ) / 2800, 433, 712,    &
     &                   533 /                                          
      DATA               ( MM( 58, J ), J = 1, 4 ) / 189, 2096, 2159,   &
     &                   2841 /                                         
      DATA               ( MM( 59, J ), J = 1, 4 ) / 287, 1761, 2318,   &
     &                   4077 /                                         
      DATA               ( MM( 60, J ), J = 1, 4 ) / 2045, 2810, 2091,  &
     &                   721 /                                          
      DATA               ( MM( 61, J ), J = 1, 4 ) / 1227, 566, 3443,   &
     &                   2821 /                                         
      DATA               ( MM( 62, J ), J = 1, 4 ) / 2838, 442, 1510,   &
     &                   2249 /                                         
      DATA               ( MM( 63, J ), J = 1, 4 ) / 209, 41, 449,      &
     &                   2397 /                                         
      DATA               ( MM( 64, J ), J = 1, 4 ) / 2770, 1238, 1956,  &
     &                   2817 /                                         
      DATA               ( MM( 65, J ), J = 1, 4 ) / 3654, 1086, 2201,  &
     &                   245 /                                          
      DATA               ( MM( 66, J ), J = 1, 4 ) / 3993, 603, 3137,   &
     &                   1913 /                                         
      DATA               ( MM( 67, J ), J = 1, 4 ) / 192, 840, 3399,    &
     &                   1997 /                                         
      DATA               ( MM( 68, J ), J = 1, 4 ) / 2253, 3168, 1321,  &
     &                   3121 /                                         
      DATA               ( MM( 69, J ), J = 1, 4 ) / 3491, 1499, 2271,  &
     &                   997 /                                          
      DATA               ( MM( 70, J ), J = 1, 4 ) / 2889, 1084, 3667,  &
     &                   1833 /                                         
      DATA               ( MM( 71, J ), J = 1, 4 ) / 2857, 3438, 2703,  &
     &                   2877 /                                         
      DATA               ( MM( 72, J ), J = 1, 4 ) / 2094, 2408, 629,   &
     &                   1633 /                                         
      DATA               ( MM( 73, J ), J = 1, 4 ) / 1818, 1589, 2365,  &
     &                   981 /                                          
      DATA               ( MM( 74, J ), J = 1, 4 ) / 688, 2391, 2431,   &
     &                   2009 /                                         
      DATA               ( MM( 75, J ), J = 1, 4 ) / 1407, 288, 1113,   &
     &                   941 /                                          
      DATA               ( MM( 76, J ), J = 1, 4 ) / 634, 26, 3922,     &
     &                   2449 /                                         
      DATA               ( MM( 77, J ), J = 1, 4 ) / 3231, 512, 2554,   &
     &                   197 /                                          
      DATA               ( MM( 78, J ), J = 1, 4 ) / 815, 1456, 184,    &
     &                   2441 /                                         
      DATA               ( MM( 79, J ), J = 1, 4 ) / 3524, 171, 2099,   &
     &                   285 /                                          
      DATA               ( MM( 80, J ), J = 1, 4 ) / 1914, 1677, 3228,  &
     &                   1473 /                                         
      DATA               ( MM( 81, J ), J = 1, 4 ) / 516, 2657, 4012,   &
     &                   2741 /                                         
      DATA               ( MM( 82, J ), J = 1, 4 ) / 164, 2270, 1921,   &
     &                   3129 /                                         
      DATA               ( MM( 83, J ), J = 1, 4 ) / 303, 2587, 3452,   &
     &                   909 /                                          
      DATA               ( MM( 84, J ), J = 1, 4 ) / 2144, 2961, 3901,  &
     &                   2801 /                                         
      DATA               ( MM( 85, J ), J = 1, 4 ) / 3480, 1970, 572,   &
     &                   421 /                                          
      DATA               ( MM( 86, J ), J = 1, 4 ) / 119, 1817, 3309,   &
     &                   4073 /                                         
      DATA               ( MM( 87, J ), J = 1, 4 ) / 3357, 676, 3171,   &
     &                   2813 /                                         
      DATA               ( MM( 88, J ), J = 1, 4 ) / 837, 1410, 817,    &
     &                   2337 /                                         
      DATA               ( MM( 89, J ), J = 1, 4 ) / 2826, 3723, 3039,  &
     &                   1429 /                                         
      DATA               ( MM( 90, J ), J = 1, 4 ) / 2332, 2803, 1696,  &
     &                   1177 /                                         
      DATA               ( MM( 91, J ), J = 1, 4 ) / 2089, 3185, 1256,  &
     &                   1901 /                                         
      DATA               ( MM( 92, J ), J = 1, 4 ) / 3780, 184, 3715,   &
     &                   81 /                                           
      DATA               ( MM( 93, J ), J = 1, 4 ) / 1700, 663, 2077,   &
     &                   1669 /                                         
      DATA               ( MM( 94, J ), J = 1, 4 ) / 3712, 499, 3019,   &
     &                   2633 /                                         
      DATA               ( MM( 95, J ), J = 1, 4 ) / 150, 3784, 1497,   &
     &                   2269 /                                         
      DATA               ( MM( 96, J ), J = 1, 4 ) / 2000, 1631, 1101,  &
     &                   129 /                                          
      DATA               ( MM( 97, J ), J = 1, 4 ) / 3375, 1925, 717,   &
     &                   1141 /                                         
      DATA               ( MM( 98, J ), J = 1, 4 ) / 1621, 3912, 51,    &
     &                   249 /                                          
      DATA               ( MM( 99, J ), J = 1, 4 ) / 3090, 1398, 981,   &
     &                   3917 /                                         
      DATA               ( MM( 100, J ), J = 1, 4 ) / 3765, 1349, 1978, &
     &                   2481 /                                         
      DATA               ( MM( 101, J ), J = 1, 4 ) / 1149, 1441, 1813, &
     &                   3941 /                                         
      DATA               ( MM( 102, J ), J = 1, 4 ) / 3146, 2224, 3881, &
     &                   2217 /                                         
      DATA               ( MM( 103, J ), J = 1, 4 ) / 33, 2411, 76,     &
     &                   2749 /                                         
      DATA               ( MM( 104, J ), J = 1, 4 ) / 3082, 1907, 3846, &
     &                   3041 /                                         
      DATA               ( MM( 105, J ), J = 1, 4 ) / 2741, 3192, 3694, &
     &                   1877 /                                         
      DATA               ( MM( 106, J ), J = 1, 4 ) / 359, 2786, 1682,  &
     &                   345 /                                          
      DATA               ( MM( 107, J ), J = 1, 4 ) / 3316, 382, 124,   &
     &                   2861 /                                         
      DATA               ( MM( 108, J ), J = 1, 4 ) / 1749, 37, 1660,   &
     &                   1809 /                                         
      DATA               ( MM( 109, J ), J = 1, 4 ) / 185, 759, 3997,   &
     &                   3141 /                                         
      DATA               ( MM( 110, J ), J = 1, 4 ) / 2784, 2948, 479,  &
     &                   2825 /                                         
      DATA               ( MM( 111, J ), J = 1, 4 ) / 2202, 1862, 1141, &
     &                   157 /                                          
      DATA               ( MM( 112, J ), J = 1, 4 ) / 2199, 3802, 886,  &
     &                   2881 /                                         
      DATA               ( MM( 113, J ), J = 1, 4 ) / 1364, 2423, 3514, &
     &                   3637 /                                         
      DATA               ( MM( 114, J ), J = 1, 4 ) / 1244, 2051, 1301, &
     &                   1465 /                                         
      DATA               ( MM( 115, J ), J = 1, 4 ) / 2020, 2295, 3604, &
     &                   2829 /                                         
      DATA               ( MM( 116, J ), J = 1, 4 ) / 3160, 1332, 1888, &
     &                   2161 /                                         
      DATA               ( MM( 117, J ), J = 1, 4 ) / 2785, 1832, 1836, &
     &                   3365 /                                         
      DATA               ( MM( 118, J ), J = 1, 4 ) / 2772, 2405, 1990, &
     &                   361 /                                          
      DATA               ( MM( 119, J ), J = 1, 4 ) / 1217, 3638, 2058, &
     &                   2685 /                                         
      DATA               ( MM( 120, J ), J = 1, 4 ) / 1822, 3661, 692,  &
     &                   3745 /                                         
      DATA               ( MM( 121, J ), J = 1, 4 ) / 1245, 327, 1194,  &
     &                   2325 /                                         
      DATA               ( MM( 122, J ), J = 1, 4 ) / 2252, 3660, 20,   &
     &                   3609 /                                         
      DATA               ( MM( 123, J ), J = 1, 4 ) / 3904, 716, 3285,  &
     &                   3821 /                                         
      DATA               ( MM( 124, J ), J = 1, 4 ) / 2774, 1842, 2046, &
     &                   3537 /                                         
      DATA               ( MM( 125, J ), J = 1, 4 ) / 997, 3987, 2107,  &
     &                   517 /                                          
      DATA               ( MM( 126, J ), J = 1, 4 ) / 2573, 1368, 3508, &
     &                   3017 /                                         
      DATA               ( MM( 127, J ), J = 1, 4 ) / 1148, 1848, 3525, &
     &                   2141 /                                         
      DATA               ( MM( 128, J ), J = 1, 4 ) / 545, 2366, 3801,  &
     &                   1537 /                                         
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      I1 = ISEED( 1 ) 
      I2 = ISEED( 2 ) 
      I3 = ISEED( 3 ) 
      I4 = ISEED( 4 ) 
!                                                                       
      DO 10 I = 1, MIN( N, LV ) 
!                                                                       
   20    CONTINUE 
!                                                                       
!        Multiply the seed by i-th power of the multiplier modulo 2**48 
!                                                                       
         IT4 = I4*MM( I, 4 ) 
         IT3 = IT4 / IPW2 
         IT4 = IT4 - IPW2*IT3 
         IT3 = IT3 + I3*MM( I, 4 ) + I4*MM( I, 3 ) 
         IT2 = IT3 / IPW2 
         IT3 = IT3 - IPW2*IT2 
         IT2 = IT2 + I2*MM( I, 4 ) + I3*MM( I, 3 ) + I4*MM( I, 2 ) 
         IT1 = IT2 / IPW2 
         IT2 = IT2 - IPW2*IT1 
         IT1 = IT1 + I1*MM( I, 4 ) + I2*MM( I, 3 ) + I3*MM( I, 2 ) +    &
     &         I4*MM( I, 1 )                                            
         IT1 = MOD( IT1, IPW2 ) 
!                                                                       
!        Convert 48-bit integer to a real number in the interval (0,1)  
!                                                                       
         X( I ) = R*( REAL( IT1 )+R*( REAL( IT2 )+R*( REAL( IT3 )+R*    &
     &            REAL( IT4 ) ) ) )                                     
!                                                                       
         IF (X( I ).EQ.1.0) THEN 
!           If a real number has n bits of precision, and the first     
!           n bits of the 48-bit integer above happen to be all 1 (which
!           will occur about once every 2**n calls), then X( I ) will   
!           be rounded to exactly 1.0. In IEEE single precision arithmet
!           this will happen relatively often since n = 24.             
!           Since X( I ) is not supposed to return exactly 0.0 or 1.0,  
!           the statistically correct thing to do in this situation is  
!           simply to iterate again.                                    
!           N.B. the case X( I ) = 0.0 should not be possible.          
            I1 = I1 + 2 
            I2 = I2 + 2 
            I3 = I3 + 2 
            I4 = I4 + 2 
            GOTO 20 
         END IF 
!                                                                       
   10 END DO 
!                                                                       
!     Return final value of seed                                        
!                                                                       
      ISEED( 1 ) = IT1 
      ISEED( 2 ) = IT2 
      ISEED( 3 ) = IT3 
      ISEED( 4 ) = IT4 
      RETURN 
!                                                                       
!     End of SLARUV                                                     
!                                                                       
      END                                           
!> \brief \b SLASCL multiplies a general rectangular matrix by a real sc
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLASCL + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SLASCL( TYPE, KL, KU, CFROM, CTO, M, N, A, LDA, INFO 
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          TYPE                                         
!       INTEGER            INFO, KL, KU, LDA, M, N                      
!       REAL               CFROM, CTO                                   
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL               A( LDA, * )                                  
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SLASCL multiplies the M by N real matrix A by the real scalar        
!> CTO/CFROM.  This is done without over/underflow as long as the final 
!> result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that 
!> A may be full, upper triangular, lower triangular, upper Hessenberg, 
!> or banded.                                                           
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] TYPE                                                      
!> \verbatim                                                            
!>          TYPE is CHARACTER*1                                         
!>          TYPE indices the storage type of the input matrix.          
!>          = 'G':  A is a full matrix.                                 
!>          = 'L':  A is a lower triangular matrix.                     
!>          = 'U':  A is an upper triangular matrix.                    
!>          = 'H':  A is an upper Hessenberg matrix.                    
!>          = 'B':  A is a symmetric band matrix with lower bandwidth KL
!>                  and upper bandwidth KU and with the only the lower  
!>                  half stored.                                        
!>          = 'Q':  A is a symmetric band matrix with lower bandwidth KL
!>                  and upper bandwidth KU and with the only the upper  
!>                  half stored.                                        
!>          = 'Z':  A is a band matrix with lower bandwidth KL and upper
!>                  bandwidth KU. See SGBTRF for storage details.       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] KL                                                        
!> \verbatim                                                            
!>          KL is INTEGER                                               
!>          The lower bandwidth of A.  Referenced only if TYPE = 'B',   
!>          'Q' or 'Z'.                                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] KU                                                        
!> \verbatim                                                            
!>          KU is INTEGER                                               
!>          The upper bandwidth of A.  Referenced only if TYPE = 'B',   
!>          'Q' or 'Z'.                                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] CFROM                                                     
!> \verbatim                                                            
!>          CFROM is REAL                                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] CTO                                                       
!> \verbatim                                                            
!>          CTO is REAL                                                 
!>                                                                      
!>          The matrix A is multiplied by CTO/CFROM. A(I,J) is computed 
!>          without over/underflow if the final result CTO*A(I,J)/CFROM 
!>          can be represented without over/underflow.  CFROM must be   
!>          nonzero.                                                    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The number of rows of the matrix A.  M >= 0.                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The number of columns of the matrix A.  N >= 0.             
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] A                                                     
!> \verbatim                                                            
!>          A is REAL array, dimension (LDA,N)                          
!>          The matrix to be multiplied by CTO/CFROM.  See TYPE for the 
!>          storage type.                                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>          The leading dimension of the array A.                       
!>          If TYPE = 'G', 'L', 'U', 'H', LDA >= max(1,M);              
!>             TYPE = 'B', LDA >= KL+1;                                 
!>             TYPE = 'Q', LDA >= KU+1;                                 
!>             TYPE = 'Z', LDA >= 2*KL+KU+1.                            
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          0  - successful exit                                        
!>          <0 - if INFO = -i, the i-th argument had an illegal value.  
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2016                                                      
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!  =====================================================================
      SUBROUTINE SLASCL( TYPE, KL, KU, CFROM, CTO, M, N, A, LDA, INFO ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2016                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          TYPE 
      INTEGER            INFO, KL, KU, LDA, M, N 
      REAL               CFROM, CTO 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               A( LDA, * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ZERO, ONE 
      PARAMETER          ( ZERO = 0.0E0, ONE = 1.0E0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            DONE 
      INTEGER            I, ITYPE, J, K1, K2, K3, K4 
      REAL               BIGNUM, CFROM1, CFROMC, CTO1, CTOC, MUL, SMLNUM 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME, SISNAN 
      REAL               SLAMCH 
      EXTERNAL           LSAME, SLAMCH, SISNAN 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, MAX, MIN 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           XERBLA 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input arguments                                          
!                                                                       
      INFO = 0 
!                                                                       
      IF( LSAME( TYPE, 'G' ) ) THEN 
         ITYPE = 0 
      ELSE IF( LSAME( TYPE, 'L' ) ) THEN 
         ITYPE = 1 
      ELSE IF( LSAME( TYPE, 'U' ) ) THEN 
         ITYPE = 2 
      ELSE IF( LSAME( TYPE, 'H' ) ) THEN 
         ITYPE = 3 
      ELSE IF( LSAME( TYPE, 'B' ) ) THEN 
         ITYPE = 4 
      ELSE IF( LSAME( TYPE, 'Q' ) ) THEN 
         ITYPE = 5 
      ELSE IF( LSAME( TYPE, 'Z' ) ) THEN 
         ITYPE = 6 
      ELSE 
         ITYPE = -1 
      END IF 
!                                                                       
      IF( ITYPE.EQ.-1 ) THEN 
         INFO = -1 
      ELSE IF( CFROM.EQ.ZERO .OR. SISNAN(CFROM) ) THEN 
         INFO = -4 
      ELSE IF( SISNAN(CTO) ) THEN 
         INFO = -5 
      ELSE IF( M.LT.0 ) THEN 
         INFO = -6 
      ELSE IF( N.LT.0 .OR. ( ITYPE.EQ.4 .AND. N.NE.M ) .OR.             &
     &         ( ITYPE.EQ.5 .AND. N.NE.M ) ) THEN                       
         INFO = -7 
      ELSE IF( ITYPE.LE.3 .AND. LDA.LT.MAX( 1, M ) ) THEN 
         INFO = -9 
      ELSE IF( ITYPE.GE.4 ) THEN 
         IF( KL.LT.0 .OR. KL.GT.MAX( M-1, 0 ) ) THEN 
            INFO = -2 
         ELSE IF( KU.LT.0 .OR. KU.GT.MAX( N-1, 0 ) .OR.                 &
     &            ( ( ITYPE.EQ.4 .OR. ITYPE.EQ.5 ) .AND. KL.NE.KU ) )   &
     &             THEN                                                 
            INFO = -3 
         ELSE IF( ( ITYPE.EQ.4 .AND. LDA.LT.KL+1 ) .OR.                 &
     &            ( ITYPE.EQ.5 .AND. LDA.LT.KU+1 ) .OR.                 &
     &            ( ITYPE.EQ.6 .AND. LDA.LT.2*KL+KU+1 ) ) THEN          
            INFO = -9 
         END IF 
      END IF 
!                                                                       
      IF( INFO.NE.0 ) THEN 
         CALL XERBLA( 'SLASCL', -INFO ) 
         RETURN 
      END IF 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.EQ.0 .OR. M.EQ.0 )                                          &
     &   RETURN                                                         
!                                                                       
!     Get machine parameters                                            
!                                                                       
      SMLNUM = SLAMCH( 'S' ) 
      BIGNUM = ONE / SMLNUM 
!                                                                       
      CFROMC = CFROM 
      CTOC = CTO 
!                                                                       
   10 CONTINUE 
      CFROM1 = CFROMC*SMLNUM 
      IF( CFROM1.EQ.CFROMC ) THEN 
!        CFROMC is an inf.  Multiply by a correctly signed zero for     
!        finite CTOC, or a NaN if CTOC is infinite.                     
         MUL = CTOC / CFROMC 
         DONE = .TRUE. 
         CTO1 = CTOC 
      ELSE 
         CTO1 = CTOC / BIGNUM 
         IF( CTO1.EQ.CTOC ) THEN 
!           CTOC is either 0 or an inf.  In both cases, CTOC itself     
!           serves as the correct multiplication factor.                
            MUL = CTOC 
            DONE = .TRUE. 
            CFROMC = ONE 
         ELSE IF( ABS( CFROM1 ).GT.ABS( CTOC ) .AND. CTOC.NE.ZERO ) THEN 
            MUL = SMLNUM 
            DONE = .FALSE. 
            CFROMC = CFROM1 
         ELSE IF( ABS( CTO1 ).GT.ABS( CFROMC ) ) THEN 
            MUL = BIGNUM 
            DONE = .FALSE. 
            CTOC = CTO1 
         ELSE 
            MUL = CTOC / CFROMC 
            DONE = .TRUE. 
         END IF 
      END IF 
!                                                                       
      IF( ITYPE.EQ.0 ) THEN 
!                                                                       
!        Full matrix                                                    
!                                                                       
         DO 30 J = 1, N 
            DO 20 I = 1, M 
               A( I, J ) = A( I, J )*MUL 
   20       CONTINUE 
   30    CONTINUE 
!                                                                       
      ELSE IF( ITYPE.EQ.1 ) THEN 
!                                                                       
!        Lower triangular matrix                                        
!                                                                       
         DO 50 J = 1, N 
            DO 40 I = J, M 
               A( I, J ) = A( I, J )*MUL 
   40       CONTINUE 
   50    CONTINUE 
!                                                                       
      ELSE IF( ITYPE.EQ.2 ) THEN 
!                                                                       
!        Upper triangular matrix                                        
!                                                                       
         DO 70 J = 1, N 
            DO 60 I = 1, MIN( J, M ) 
               A( I, J ) = A( I, J )*MUL 
   60       CONTINUE 
   70    CONTINUE 
!                                                                       
      ELSE IF( ITYPE.EQ.3 ) THEN 
!                                                                       
!        Upper Hessenberg matrix                                        
!                                                                       
         DO 90 J = 1, N 
            DO 80 I = 1, MIN( J+1, M ) 
               A( I, J ) = A( I, J )*MUL 
   80       CONTINUE 
   90    CONTINUE 
!                                                                       
      ELSE IF( ITYPE.EQ.4 ) THEN 
!                                                                       
!        Lower half of a symmetric band matrix                          
!                                                                       
         K3 = KL + 1 
         K4 = N + 1 
         DO 110 J = 1, N 
            DO 100 I = 1, MIN( K3, K4-J ) 
               A( I, J ) = A( I, J )*MUL 
  100       CONTINUE 
  110    CONTINUE 
!                                                                       
      ELSE IF( ITYPE.EQ.5 ) THEN 
!                                                                       
!        Upper half of a symmetric band matrix                          
!                                                                       
         K1 = KU + 2 
         K3 = KU + 1 
         DO 130 J = 1, N 
            DO 120 I = MAX( K1-J, 1 ), K3 
               A( I, J ) = A( I, J )*MUL 
  120       CONTINUE 
  130    CONTINUE 
!                                                                       
      ELSE IF( ITYPE.EQ.6 ) THEN 
!                                                                       
!        Band matrix                                                    
!                                                                       
         K1 = KL + KU + 2 
         K2 = KL + 1 
         K3 = 2*KL + KU + 1 
         K4 = KL + KU + 1 + M 
         DO 150 J = 1, N 
            DO 140 I = MAX( K1-J, K2 ), MIN( K3, K4-J ) 
               A( I, J ) = A( I, J )*MUL 
  140       CONTINUE 
  150    CONTINUE 
!                                                                       
      END IF 
!                                                                       
      IF( .NOT.DONE )                                                   &
     &   GO TO 10                                                       
!                                                                       
      RETURN 
!                                                                       
!     End of SLASCL                                                     
!                                                                       
      END                                           
!> \brief \b SLASET initializes the off-diagonal elements and the diagon
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLASET + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SLASET( UPLO, M, N, ALPHA, BETA, A, LDA )            
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          UPLO                                         
!       INTEGER            LDA, M, N                                    
!       REAL               ALPHA, BETA                                  
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL               A( LDA, * )                                  
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SLASET initializes an m-by-n matrix A to BETA on the diagonal and    
!> ALPHA on the offdiagonals.                                           
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] UPLO                                                      
!> \verbatim                                                            
!>          UPLO is CHARACTER*1                                         
!>          Specifies the part of the matrix A to be set.               
!>          = 'U':      Upper triangular part is set; the strictly lower
!>                      triangular part of A is not changed.            
!>          = 'L':      Lower triangular part is set; the strictly upper
!>                      triangular part of A is not changed.            
!>          Otherwise:  All of the matrix A is set.                     
!> \endverbatim                                                         
!>                                                                      
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The number of rows of the matrix A.  M >= 0.                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The number of columns of the matrix A.  N >= 0.             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ALPHA                                                     
!> \verbatim                                                            
!>          ALPHA is REAL                                               
!>          The constant to which the offdiagonal elements are to be set
!> \endverbatim                                                         
!>                                                                      
!> \param[in] BETA                                                      
!> \verbatim                                                            
!>          BETA is REAL                                                
!>          The constant to which the diagonal elements are to be set.  
!> \endverbatim                                                         
!>                                                                      
!> \param[out] A                                                        
!> \verbatim                                                            
!>          A is REAL array, dimension (LDA,N)                          
!>          On exit, the leading m-by-n submatrix of A is set as follows
!>                                                                      
!>          if UPLO = 'U', A(i,j) = ALPHA, 1<=i<=j-1, 1<=j<=n,          
!>          if UPLO = 'L', A(i,j) = ALPHA, j+1<=i<=m, 1<=j<=n,          
!>          otherwise,     A(i,j) = ALPHA, 1<=i<=m, 1<=j<=n, i.ne.j,    
!>                                                                      
!>          and, for all UPLO, A(i,i) = BETA, 1<=i<=min(m,n).           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>          The leading dimension of the array A.  LDA >= max(1,M).     
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!  =====================================================================
      SUBROUTINE SLASET( UPLO, M, N, ALPHA, BETA, A, LDA ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          UPLO 
      INTEGER            LDA, M, N 
      REAL               ALPHA, BETA 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               A( LDA, * ) 
!     ..                                                                
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Local Scalars ..                                               
      INTEGER            I, J 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      EXTERNAL           LSAME 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MIN 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      IF( LSAME( UPLO, 'U' ) ) THEN 
!                                                                       
!        Set the strictly upper triangular or trapezoidal part of the   
!        array to ALPHA.                                                
!                                                                       
         DO 20 J = 2, N 
            DO 10 I = 1, MIN( J-1, M ) 
               A( I, J ) = ALPHA 
   10       CONTINUE 
   20    CONTINUE 
!                                                                       
      ELSE IF( LSAME( UPLO, 'L' ) ) THEN 
!                                                                       
!        Set the strictly lower triangular or trapezoidal part of the   
!        array to ALPHA.                                                
!                                                                       
         DO 40 J = 1, MIN( M, N ) 
            DO 30 I = J + 1, M 
               A( I, J ) = ALPHA 
   30       CONTINUE 
   40    CONTINUE 
!                                                                       
      ELSE 
!                                                                       
!        Set the leading m-by-n submatrix to ALPHA.                     
!                                                                       
         DO 60 J = 1, N 
            DO 50 I = 1, M 
               A( I, J ) = ALPHA 
   50       CONTINUE 
   60    CONTINUE 
      END IF 
!                                                                       
!     Set the first min(M,N) diagonal elements to BETA.                 
!                                                                       
      DO 70 I = 1, MIN( M, N ) 
         A( I, I ) = BETA 
   70 END DO 
!                                                                       
      RETURN 
!                                                                       
!     End of SLASET                                                     
!                                                                       
      END                                           
!> \brief \b SLASQ2 computes all the eigenvalues of the symmetric positi
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLASQ2 + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SLASQ2( N, Z, INFO )                                 
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            INFO, N                                      
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL               Z( * )                                       
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SLASQ2 computes all the eigenvalues of the symmetric positive        
!> definite tridiagonal matrix associated with the qd array Z to high   
!> relative accuracy are computed to high relative accuracy, in the     
!> absence of denormalization, underflow and overflow.                  
!>                                                                      
!> To see the relation of Z to the tridiagonal matrix, let L be a       
!> unit lower bidiagonal matrix with subdiagonals Z(2,4,6,,..) and      
!> let U be an upper bidiagonal matrix with 1's above and diagonal      
!> Z(1,3,5,,..). The tridiagonal is L*U or, if you prefer, the          
!> symmetric tridiagonal to which it is similar.                        
!>                                                                      
!> Note : SLASQ2 defines a logical variable, IEEE, which is true        
!> on machines which follow ieee-754 floating-point standard in their   
!> handling of infinities and NaNs, and false otherwise. This variable  
!> is passed to SLASQ3.                                                 
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>        The number of rows and columns in the matrix. N >= 0.         
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] Z                                                     
!> \verbatim                                                            
!>          Z is REAL array, dimension ( 4*N )                          
!>        On entry Z holds the qd array. On exit, entries 1 to N hold   
!>        the eigenvalues in decreasing order, Z( 2*N+1 ) holds the     
!>        trace, and Z( 2*N+2 ) holds the sum of the eigenvalues. If    
!>        N > 2, then Z( 2*N+3 ) holds the iteration count, Z( 2*N+4 )  
!>        holds NDIVS/NIN^2, and Z( 2*N+5 ) holds the percentage of     
!>        shifts that failed.                                           
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>        = 0: successful exit                                          
!>        < 0: if the i-th argument is a scalar and had an illegal      
!>             value, then INFO = -i, if the i-th argument is an        
!>             array and the j-entry had an illegal value, then         
!>             INFO = -(i*100+j)                                        
!>        > 0: the algorithm failed                                     
!>              = 1, a split was marked by a positive value in E        
!>              = 2, current block of Z not diagonalized after 100*N    
!>                   iterations (in inner while loop).  On exit Z holds 
!>                   a qd array with the same eigenvalues as the given Z
!>              = 3, termination criterion of outer while loop not met  
!>                   (program created more than N unreduced blocks)     
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup auxOTHERcomputational                                       
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  Local Variables: I0:N0 defines a current unreduced segment of Z.    
!>  The shifts are accumulated in SIGMA. Iteration count is in ITER.    
!>  Ping-pong is controlled by PP (alternates between 0 and 1).         
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE SLASQ2( N, Z, INFO ) 
!                                                                       
!  -- LAPACK computational routine (version 3.7.0) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            INFO, N 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               Z( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               CBIAS 
      PARAMETER          ( CBIAS = 1.50E0 ) 
      REAL               ZERO, HALF, ONE, TWO, FOUR, HUNDRD 
      PARAMETER          ( ZERO = 0.0E0, HALF = 0.5E0, ONE = 1.0E0,     &
     &                     TWO = 2.0E0, FOUR = 4.0E0, HUNDRD = 100.0E0 )
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            IEEE 
      INTEGER            I0, I4, IINFO, IPN4, ITER, IWHILA, IWHILB, K,  &
     &                   KMIN, N0, NBIG, NDIV, NFAIL, PP, SPLT, TTYPE,  &
     &                   I1, N1                                         
      REAL               D, DEE, DEEMIN, DESIG, DMIN, DMIN1, DMIN2, DN, &
     &                   DN1, DN2, E, EMAX, EMIN, EPS, G, OLDEMN, QMAX, &
     &                   QMIN, S, SAFMIN, SIGMA, T, TAU, TEMP, TOL,     &
     &                   TOL2, TRACE, ZMAX, TEMPE, TEMPQ                
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           SLASQ3, SLASRT, XERBLA 
!     ..                                                                
!     .. External Functions ..                                          
      REAL               SLAMCH 
      EXTERNAL           SLAMCH 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, MAX, MIN, REAL, SQRT 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input arguments.                                         
!     (in case SLASQ2 is not called by SLASQ1)                          
!                                                                       
      INFO = 0 
      EPS = SLAMCH( 'Precision' ) 
      SAFMIN = SLAMCH( 'Safe minimum' ) 
      TOL = EPS*HUNDRD 
      TOL2 = TOL**2 
!                                                                       
      IF( N.LT.0 ) THEN 
         INFO = -1 
         CALL XERBLA( 'SLASQ2', 1 ) 
         RETURN 
      ELSE IF( N.EQ.0 ) THEN 
         RETURN 
      ELSE IF( N.EQ.1 ) THEN 
!                                                                       
!        1-by-1 case.                                                   
!                                                                       
         IF( Z( 1 ).LT.ZERO ) THEN 
            INFO = -201 
            CALL XERBLA( 'SLASQ2', 2 ) 
         END IF 
         RETURN 
      ELSE IF( N.EQ.2 ) THEN 
!                                                                       
!        2-by-2 case.                                                   
!                                                                       
         IF( Z( 2 ).LT.ZERO .OR. Z( 3 ).LT.ZERO ) THEN 
            INFO = -2 
            CALL XERBLA( 'SLASQ2', 2 ) 
            RETURN 
         ELSE IF( Z( 3 ).GT.Z( 1 ) ) THEN 
            D = Z( 3 ) 
            Z( 3 ) = Z( 1 ) 
            Z( 1 ) = D 
         END IF 
         Z( 5 ) = Z( 1 ) + Z( 2 ) + Z( 3 ) 
         IF( Z( 2 ).GT.Z( 3 )*TOL2 ) THEN 
            T = HALF*( ( Z( 1 )-Z( 3 ) )+Z( 2 ) ) 
            S = Z( 3 )*( Z( 2 ) / T ) 
            IF( S.LE.T ) THEN 
               S = Z( 3 )*( Z( 2 ) / ( T*( ONE+SQRT( ONE+S / T ) ) ) ) 
            ELSE 
               S = Z( 3 )*( Z( 2 ) / ( T+SQRT( T )*SQRT( T+S ) ) ) 
            END IF 
            T = Z( 1 ) + ( S+Z( 2 ) ) 
            Z( 3 ) = Z( 3 )*( Z( 1 ) / T ) 
            Z( 1 ) = T 
         END IF 
         Z( 2 ) = Z( 3 ) 
         Z( 6 ) = Z( 2 ) + Z( 1 ) 
         RETURN 
      END IF 
!                                                                       
!     Check for negative data and compute sums of q's and e's.          
!                                                                       
      Z( 2*N ) = ZERO 
      EMIN = Z( 2 ) 
      QMAX = ZERO 
      ZMAX = ZERO 
      D = ZERO 
      E = ZERO 
!                                                                       
      DO 10 K = 1, 2*( N-1 ), 2 
         IF( Z( K ).LT.ZERO ) THEN 
            INFO = -( 200+K ) 
            CALL XERBLA( 'SLASQ2', 2 ) 
            RETURN 
         ELSE IF( Z( K+1 ).LT.ZERO ) THEN 
            INFO = -( 200+K+1 ) 
            CALL XERBLA( 'SLASQ2', 2 ) 
            RETURN 
         END IF 
         D = D + Z( K ) 
         E = E + Z( K+1 ) 
         QMAX = MAX( QMAX, Z( K ) ) 
         EMIN = MIN( EMIN, Z( K+1 ) ) 
         ZMAX = MAX( QMAX, ZMAX, Z( K+1 ) ) 
   10 END DO 
      IF( Z( 2*N-1 ).LT.ZERO ) THEN 
         INFO = -( 200+2*N-1 ) 
         CALL XERBLA( 'SLASQ2', 2 ) 
         RETURN 
      END IF 
      D = D + Z( 2*N-1 ) 
      QMAX = MAX( QMAX, Z( 2*N-1 ) ) 
      ZMAX = MAX( QMAX, ZMAX ) 
!                                                                       
!     Check for diagonality.                                            
!                                                                       
      IF( E.EQ.ZERO ) THEN 
         DO 20 K = 2, N 
            Z( K ) = Z( 2*K-1 ) 
   20    CONTINUE 
         CALL SLASRT( 'D', N, Z, IINFO ) 
         Z( 2*N-1 ) = D 
         RETURN 
      END IF 
!                                                                       
      TRACE = D + E 
!                                                                       
!     Check for zero data.                                              
!                                                                       
      IF( TRACE.EQ.ZERO ) THEN 
         Z( 2*N-1 ) = ZERO 
         RETURN 
      END IF 
!                                                                       
!     Check whether the machine is IEEE conformable.                    
!                                                                       
!     IEEE = ILAENV( 10, 'SLASQ2', 'N', 1, 2, 3, 4 ).EQ.1 .AND.         
!    $       ILAENV( 11, 'SLASQ2', 'N', 1, 2, 3, 4 ).EQ.1               
!                                                                       
!     [11/15/2008] The case IEEE=.TRUE. has a problem in single precisio
!     some the test matrices of type 16. The double precision code is fi
!                                                                       
      IEEE = .FALSE. 
!                                                                       
!     Rearrange data for locality: Z=(q1,qq1,e1,ee1,q2,qq2,e2,ee2,...). 
!                                                                       
      DO 30 K = 2*N, 2, -2 
         Z( 2*K ) = ZERO 
         Z( 2*K-1 ) = Z( K ) 
         Z( 2*K-2 ) = ZERO 
         Z( 2*K-3 ) = Z( K-1 ) 
   30 END DO 
!                                                                       
      I0 = 1 
      N0 = N 
!                                                                       
!     Reverse the qd-array, if warranted.                               
!                                                                       
      IF( CBIAS*Z( 4*I0-3 ).LT.Z( 4*N0-3 ) ) THEN 
         IPN4 = 4*( I0+N0 ) 
         DO 40 I4 = 4*I0, 2*( I0+N0-1 ), 4 
            TEMP = Z( I4-3 ) 
            Z( I4-3 ) = Z( IPN4-I4-3 ) 
            Z( IPN4-I4-3 ) = TEMP 
            TEMP = Z( I4-1 ) 
            Z( I4-1 ) = Z( IPN4-I4-5 ) 
            Z( IPN4-I4-5 ) = TEMP 
   40    CONTINUE 
      END IF 
!                                                                       
!     Initial split checking via dqd and Li's test.                     
!                                                                       
      PP = 0 
!                                                                       
      DO 80 K = 1, 2 
!                                                                       
         D = Z( 4*N0+PP-3 ) 
         DO 50 I4 = 4*( N0-1 ) + PP, 4*I0 + PP, -4 
            IF( Z( I4-1 ).LE.TOL2*D ) THEN 
               Z( I4-1 ) = -ZERO 
               D = Z( I4-3 ) 
            ELSE 
               D = Z( I4-3 )*( D / ( D+Z( I4-1 ) ) ) 
            END IF 
   50    CONTINUE 
!                                                                       
!        dqd maps Z to ZZ plus Li's test.                               
!                                                                       
         EMIN = Z( 4*I0+PP+1 ) 
         D = Z( 4*I0+PP-3 ) 
         DO 60 I4 = 4*I0 + PP, 4*( N0-1 ) + PP, 4 
            Z( I4-2*PP-2 ) = D + Z( I4-1 ) 
            IF( Z( I4-1 ).LE.TOL2*D ) THEN 
               Z( I4-1 ) = -ZERO 
               Z( I4-2*PP-2 ) = D 
               Z( I4-2*PP ) = ZERO 
               D = Z( I4+1 ) 
            ELSE IF( SAFMIN*Z( I4+1 ).LT.Z( I4-2*PP-2 ) .AND.           &
     &               SAFMIN*Z( I4-2*PP-2 ).LT.Z( I4+1 ) ) THEN          
               TEMP = Z( I4+1 ) / Z( I4-2*PP-2 ) 
               Z( I4-2*PP ) = Z( I4-1 )*TEMP 
               D = D*TEMP 
            ELSE 
               Z( I4-2*PP ) = Z( I4+1 )*( Z( I4-1 ) / Z( I4-2*PP-2 ) ) 
               D = Z( I4+1 )*( D / Z( I4-2*PP-2 ) ) 
            END IF 
            EMIN = MIN( EMIN, Z( I4-2*PP ) ) 
   60    CONTINUE 
         Z( 4*N0-PP-2 ) = D 
!                                                                       
!        Now find qmax.                                                 
!                                                                       
         QMAX = Z( 4*I0-PP-2 ) 
         DO 70 I4 = 4*I0 - PP + 2, 4*N0 - PP - 2, 4 
            QMAX = MAX( QMAX, Z( I4 ) ) 
   70    CONTINUE 
!                                                                       
!        Prepare for the next iteration on K.                           
!                                                                       
         PP = 1 - PP 
   80 END DO 
!                                                                       
!     Initialise variables to pass to SLASQ3.                           
!                                                                       
      TTYPE = 0 
      DMIN1 = ZERO 
      DMIN2 = ZERO 
      DN    = ZERO 
      DN1   = ZERO 
      DN2   = ZERO 
      G     = ZERO 
      TAU   = ZERO 
!                                                                       
      ITER = 2 
      NFAIL = 0 
      NDIV = 2*( N0-I0 ) 
!                                                                       
      DO 160 IWHILA = 1, N + 1 
         IF( N0.LT.1 )                                                  &
     &      GO TO 170                                                   
!                                                                       
!        While array unfinished do                                      
!                                                                       
!        E(N0) holds the value of SIGMA when submatrix in I0:N0         
!        splits from the rest of the array, but is negated.             
!                                                                       
         DESIG = ZERO 
         IF( N0.EQ.N ) THEN 
            SIGMA = ZERO 
         ELSE 
            SIGMA = -Z( 4*N0-1 ) 
         END IF 
         IF( SIGMA.LT.ZERO ) THEN 
            INFO = 1 
            RETURN 
         END IF 
!                                                                       
!        Find last unreduced submatrix's top index I0, find QMAX and    
!        EMIN. Find Gershgorin-type bound if Q's much greater than E's. 
!                                                                       
         EMAX = ZERO 
         IF( N0.GT.I0 ) THEN 
            EMIN = ABS( Z( 4*N0-5 ) ) 
         ELSE 
            EMIN = ZERO 
         END IF 
         QMIN = Z( 4*N0-3 ) 
         QMAX = QMIN 
         DO 90 I4 = 4*N0, 8, -4 
            IF( Z( I4-5 ).LE.ZERO )                                     &
     &         GO TO 100                                                
            IF( QMIN.GE.FOUR*EMAX ) THEN 
               QMIN = MIN( QMIN, Z( I4-3 ) ) 
               EMAX = MAX( EMAX, Z( I4-5 ) ) 
            END IF 
            QMAX = MAX( QMAX, Z( I4-7 )+Z( I4-5 ) ) 
            EMIN = MIN( EMIN, Z( I4-5 ) ) 
   90    CONTINUE 
         I4 = 4 
!                                                                       
  100    CONTINUE 
         I0 = I4 / 4 
         PP = 0 
!                                                                       
         IF( N0-I0.GT.1 ) THEN 
            DEE = Z( 4*I0-3 ) 
            DEEMIN = DEE 
            KMIN = I0 
            DO 110 I4 = 4*I0+1, 4*N0-3, 4 
               DEE = Z( I4 )*( DEE /( DEE+Z( I4-2 ) ) ) 
               IF( DEE.LE.DEEMIN ) THEN 
                  DEEMIN = DEE 
                  KMIN = ( I4+3 )/4 
               END IF 
  110       CONTINUE 
            IF( (KMIN-I0)*2.LT.N0-KMIN .AND.                            &
     &         DEEMIN.LE.HALF*Z(4*N0-3) ) THEN                          
               IPN4 = 4*( I0+N0 ) 
               PP = 2 
               DO 120 I4 = 4*I0, 2*( I0+N0-1 ), 4 
                  TEMP = Z( I4-3 ) 
                  Z( I4-3 ) = Z( IPN4-I4-3 ) 
                  Z( IPN4-I4-3 ) = TEMP 
                  TEMP = Z( I4-2 ) 
                  Z( I4-2 ) = Z( IPN4-I4-2 ) 
                  Z( IPN4-I4-2 ) = TEMP 
                  TEMP = Z( I4-1 ) 
                  Z( I4-1 ) = Z( IPN4-I4-5 ) 
                  Z( IPN4-I4-5 ) = TEMP 
                  TEMP = Z( I4 ) 
                  Z( I4 ) = Z( IPN4-I4-4 ) 
                  Z( IPN4-I4-4 ) = TEMP 
  120          CONTINUE 
            END IF 
         END IF 
!                                                                       
!        Put -(initial shift) into DMIN.                                
!                                                                       
         DMIN = -MAX( ZERO, QMIN-TWO*SQRT( QMIN )*SQRT( EMAX ) ) 
!                                                                       
!        Now I0:N0 is unreduced.                                        
!        PP = 0 for ping, PP = 1 for pong.                              
!        PP = 2 indicates that flipping was applied to the Z array and  
!               and that the tests for deflation upon entry in SLASQ3   
!               should not be performed.                                
!                                                                       
         NBIG = 100*( N0-I0+1 ) 
         DO 140 IWHILB = 1, NBIG 
            IF( I0.GT.N0 )                                              &
     &         GO TO 150                                                
!                                                                       
!           While submatrix unfinished take a good dqds step.           
!                                                                       
            CALL SLASQ3( I0, N0, Z, PP, DMIN, SIGMA, DESIG, QMAX, NFAIL,&
     &                   ITER, NDIV, IEEE, TTYPE, DMIN1, DMIN2, DN, DN1,&
     &                   DN2, G, TAU )                                  
!                                                                       
            PP = 1 - PP 
!                                                                       
!           When EMIN is very small check for splits.                   
!                                                                       
            IF( PP.EQ.0 .AND. N0-I0.GE.3 ) THEN 
               IF( Z( 4*N0 ).LE.TOL2*QMAX .OR.                          &
     &             Z( 4*N0-1 ).LE.TOL2*SIGMA ) THEN                     
                  SPLT = I0 - 1 
                  QMAX = Z( 4*I0-3 ) 
                  EMIN = Z( 4*I0-1 ) 
                  OLDEMN = Z( 4*I0 ) 
                  DO 130 I4 = 4*I0, 4*( N0-3 ), 4 
                     IF( Z( I4 ).LE.TOL2*Z( I4-3 ) .OR.                 &
     &                   Z( I4-1 ).LE.TOL2*SIGMA ) THEN                 
                        Z( I4-1 ) = -SIGMA 
                        SPLT = I4 / 4 
                        QMAX = ZERO 
                        EMIN = Z( I4+3 ) 
                        OLDEMN = Z( I4+4 ) 
                     ELSE 
                        QMAX = MAX( QMAX, Z( I4+1 ) ) 
                        EMIN = MIN( EMIN, Z( I4-1 ) ) 
                        OLDEMN = MIN( OLDEMN, Z( I4 ) ) 
                     END IF 
  130             CONTINUE 
                  Z( 4*N0-1 ) = EMIN 
                  Z( 4*N0 ) = OLDEMN 
                  I0 = SPLT + 1 
               END IF 
            END IF 
!                                                                       
  140    CONTINUE 
!                                                                       
         INFO = 2 
!                                                                       
!        Maximum number of iterations exceeded, restore the shift       
!        SIGMA and place the new d's and e's in a qd array.             
!        This might need to be done for several blocks                  
!                                                                       
         I1 = I0 
         N1 = N0 
  145    CONTINUE 
         TEMPQ = Z( 4*I0-3 ) 
         Z( 4*I0-3 ) = Z( 4*I0-3 ) + SIGMA 
         DO K = I0+1, N0 
            TEMPE = Z( 4*K-5 ) 
            Z( 4*K-5 ) = Z( 4*K-5 ) * (TEMPQ / Z( 4*K-7 )) 
            TEMPQ = Z( 4*K-3 ) 
            Z( 4*K-3 ) = Z( 4*K-3 ) + SIGMA + TEMPE - Z( 4*K-5 ) 
         END DO 
!                                                                       
!        Prepare to do this on the previous block if there is one       
!                                                                       
         IF( I1.GT.1 ) THEN 
            N1 = I1-1 
            DO WHILE( ( I1.GE.2 ) .AND. ( Z(4*I1-5).GE.ZERO ) ) 
               I1 = I1 - 1 
            END DO 
            IF( I1.GE.1 ) THEN 
               SIGMA = -Z(4*N1-1) 
               GO TO 145 
            END IF 
         END IF 
                                                                        
         DO K = 1, N 
            Z( 2*K-1 ) = Z( 4*K-3 ) 
!                                                                       
!        Only the block 1..N0 is unfinished.  The rest of the e's       
!        must be essentially zero, although sometimes other data        
!        has been stored in them.                                       
!                                                                       
            IF( K.LT.N0 ) THEN 
               Z( 2*K ) = Z( 4*K-1 ) 
            ELSE 
               Z( 2*K ) = 0 
            END IF 
         END DO 
         RETURN 
!                                                                       
!        end IWHILB                                                     
!                                                                       
  150    CONTINUE 
!                                                                       
  160 END DO 
!                                                                       
      INFO = 3 
      RETURN 
!                                                                       
!     end IWHILA                                                        
!                                                                       
  170 CONTINUE 
!                                                                       
!     Move q's to the front.                                            
!                                                                       
      DO 180 K = 2, N 
         Z( K ) = Z( 4*K-3 ) 
  180 END DO 
!                                                                       
!     Sort and compute sum of eigenvalues.                              
!                                                                       
      CALL SLASRT( 'D', N, Z, IINFO ) 
!                                                                       
      E = ZERO 
      DO 190 K = N, 1, -1 
         E = E + Z( K ) 
  190 END DO 
!                                                                       
!     Store trace, sum(eigenvalues) and information on performance.     
!                                                                       
      Z( 2*N+1 ) = TRACE 
      Z( 2*N+2 ) = E 
      Z( 2*N+3 ) = REAL( ITER ) 
      Z( 2*N+4 ) = REAL( NDIV ) / REAL( N**2 ) 
      Z( 2*N+5 ) = HUNDRD*NFAIL / REAL( ITER ) 
      RETURN 
!                                                                       
!     End of SLASQ2                                                     
!                                                                       
      END                                           
!> \brief \b SLASQ3 checks for deflation, computes a shift and calls dqd
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLASQ3 + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SLASQ3( I0, N0, Z, PP, DMIN, SIGMA, DESIG, QMAX, NFAI
!                          ITER, NDIV, IEEE, TTYPE, DMIN1, DMIN2, DN, DN
!                          DN2, G, TAU )                                
!                                                                       
!       .. Scalar Arguments ..                                          
!       LOGICAL            IEEE                                         
!       INTEGER            I0, ITER, N0, NDIV, NFAIL, PP                
!       REAL               DESIG, DMIN, DMIN1, DMIN2, DN, DN1, DN2, G,  
!      $                   QMAX, SIGMA, TAU                             
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL               Z( * )                                       
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SLASQ3 checks for deflation, computes a shift (TAU) and calls dqds.  
!> In case of failure it changes shifts, and tries again until output   
!> is positive.                                                         
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] I0                                                        
!> \verbatim                                                            
!>          I0 is INTEGER                                               
!>         First index.                                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] N0                                                    
!> \verbatim                                                            
!>          N0 is INTEGER                                               
!>         Last index.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] Z                                                     
!> \verbatim                                                            
!>          Z is REAL array, dimension ( 4*N0 )                         
!>         Z holds the qd array.                                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] PP                                                    
!> \verbatim                                                            
!>          PP is INTEGER                                               
!>         PP=0 for ping, PP=1 for pong.                                
!>         PP=2 indicates that flipping was applied to the Z array      
!>         and that the initial tests for deflation should not be       
!>         performed.                                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[out] DMIN                                                     
!> \verbatim                                                            
!>          DMIN is REAL                                                
!>         Minimum value of d.                                          
!> \endverbatim                                                         
!>                                                                      
!> \param[out] SIGMA                                                    
!> \verbatim                                                            
!>          SIGMA is REAL                                               
!>         Sum of shifts used in current segment.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] DESIG                                                 
!> \verbatim                                                            
!>          DESIG is REAL                                               
!>         Lower order part of SIGMA                                    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] QMAX                                                      
!> \verbatim                                                            
!>          QMAX is REAL                                                
!>         Maximum value of q.                                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] NFAIL                                                 
!> \verbatim                                                            
!>          NFAIL is INTEGER                                            
!>         Increment NFAIL by 1 each time the shift was too big.        
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] ITER                                                  
!> \verbatim                                                            
!>          ITER is INTEGER                                             
!>         Increment ITER by 1 for each iteration.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] NDIV                                                  
!> \verbatim                                                            
!>          NDIV is INTEGER                                             
!>         Increment NDIV by 1 for each division.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IEEE                                                      
!> \verbatim                                                            
!>          IEEE is LOGICAL                                             
!>         Flag for IEEE or non IEEE arithmetic (passed to SLASQ5).     
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] TTYPE                                                 
!> \verbatim                                                            
!>          TTYPE is INTEGER                                            
!>         Shift type.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] DMIN1                                                 
!> \verbatim                                                            
!>          DMIN1 is REAL                                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] DMIN2                                                 
!> \verbatim                                                            
!>          DMIN2 is REAL                                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] DN                                                    
!> \verbatim                                                            
!>          DN is REAL                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] DN1                                                   
!> \verbatim                                                            
!>          DN1 is REAL                                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] DN2                                                   
!> \verbatim                                                            
!>          DN2 is REAL                                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] G                                                     
!> \verbatim                                                            
!>          G is REAL                                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] TAU                                                   
!> \verbatim                                                            
!>          TAU is REAL                                                 
!>                                                                      
!>         These are passed as arguments in order to save their values  
!>         between calls to SLASQ3.                                     
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2016                                                      
!                                                                       
!> \ingroup auxOTHERcomputational                                       
!                                                                       
!  =====================================================================
      SUBROUTINE SLASQ3( I0, N0, Z, PP, DMIN, SIGMA, DESIG, QMAX, NFAIL,&
     &                   ITER, NDIV, IEEE, TTYPE, DMIN1, DMIN2, DN, DN1,&
     &                   DN2, G, TAU )                                  
!                                                                       
!  -- LAPACK computational routine (version 3.7.0) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2016                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      LOGICAL            IEEE 
      INTEGER            I0, ITER, N0, NDIV, NFAIL, PP 
      REAL               DESIG, DMIN, DMIN1, DMIN2, DN, DN1, DN2, G,    &
     &                   QMAX, SIGMA, TAU                               
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               Z( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               CBIAS 
      PARAMETER          ( CBIAS = 1.50E0 ) 
      REAL               ZERO, QURTR, HALF, ONE, TWO, HUNDRD 
      PARAMETER          ( ZERO = 0.0E0, QURTR = 0.250E0, HALF = 0.5E0, &
     &                     ONE = 1.0E0, TWO = 2.0E0, HUNDRD = 100.0E0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            IPN4, J4, N0IN, NN, TTYPE 
      REAL               EPS, S, T, TEMP, TOL, TOL2 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           SLASQ4, SLASQ5, SLASQ6 
!     ..                                                                
!     .. External Function ..                                           
      REAL               SLAMCH 
      LOGICAL            SISNAN 
      EXTERNAL           SISNAN, SLAMCH 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, MAX, MIN, SQRT 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      N0IN = N0 
      EPS = SLAMCH( 'Precision' ) 
      TOL = EPS*HUNDRD 
      TOL2 = TOL**2 
!                                                                       
!     Check for deflation.                                              
!                                                                       
   10 CONTINUE 
!                                                                       
      IF( N0.LT.I0 )                                                    &
     &   RETURN                                                         
      IF( N0.EQ.I0 )                                                    &
     &   GO TO 20                                                       
      NN = 4*N0 + PP 
      IF( N0.EQ.( I0+1 ) )                                              &
     &   GO TO 40                                                       
!                                                                       
!     Check whether E(N0-1) is negligible, 1 eigenvalue.                
!                                                                       
      IF( Z( NN-5 ).GT.TOL2*( SIGMA+Z( NN-3 ) ) .AND.                   &
     &    Z( NN-2*PP-4 ).GT.TOL2*Z( NN-7 ) )                            &
     &   GO TO 30                                                       
!                                                                       
   20 CONTINUE 
!                                                                       
      Z( 4*N0-3 ) = Z( 4*N0+PP-3 ) + SIGMA 
      N0 = N0 - 1 
      GO TO 10 
!                                                                       
!     Check  whether E(N0-2) is negligible, 2 eigenvalues.              
!                                                                       
   30 CONTINUE 
!                                                                       
      IF( Z( NN-9 ).GT.TOL2*SIGMA .AND.                                 &
     &    Z( NN-2*PP-8 ).GT.TOL2*Z( NN-11 ) )                           &
     &   GO TO 50                                                       
!                                                                       
   40 CONTINUE 
!                                                                       
      IF( Z( NN-3 ).GT.Z( NN-7 ) ) THEN 
         S = Z( NN-3 ) 
         Z( NN-3 ) = Z( NN-7 ) 
         Z( NN-7 ) = S 
      END IF 
      T = HALF*( ( Z( NN-7 )-Z( NN-3 ) )+Z( NN-5 ) ) 
      IF( Z( NN-5 ).GT.Z( NN-3 )*TOL2.AND.T.NE.ZERO ) THEN 
         S = Z( NN-3 )*( Z( NN-5 ) / T ) 
         IF( S.LE.T ) THEN 
            S = Z( NN-3 )*( Z( NN-5 ) /                                 &
     &          ( T*( ONE+SQRT( ONE+S / T ) ) ) )                       
         ELSE 
            S = Z( NN-3 )*( Z( NN-5 ) / ( T+SQRT( T )*SQRT( T+S ) ) ) 
         END IF 
         T = Z( NN-7 ) + ( S+Z( NN-5 ) ) 
         Z( NN-3 ) = Z( NN-3 )*( Z( NN-7 ) / T ) 
         Z( NN-7 ) = T 
      END IF 
      Z( 4*N0-7 ) = Z( NN-7 ) + SIGMA 
      Z( 4*N0-3 ) = Z( NN-3 ) + SIGMA 
      N0 = N0 - 2 
      GO TO 10 
!                                                                       
   50 CONTINUE 
      IF( PP.EQ.2 )                                                     &
     &   PP = 0                                                         
!                                                                       
!     Reverse the qd-array, if warranted.                               
!                                                                       
      IF( DMIN.LE.ZERO .OR. N0.LT.N0IN ) THEN 
         IF( CBIAS*Z( 4*I0+PP-3 ).LT.Z( 4*N0+PP-3 ) ) THEN 
            IPN4 = 4*( I0+N0 ) 
            DO 60 J4 = 4*I0, 2*( I0+N0-1 ), 4 
               TEMP = Z( J4-3 ) 
               Z( J4-3 ) = Z( IPN4-J4-3 ) 
               Z( IPN4-J4-3 ) = TEMP 
               TEMP = Z( J4-2 ) 
               Z( J4-2 ) = Z( IPN4-J4-2 ) 
               Z( IPN4-J4-2 ) = TEMP 
               TEMP = Z( J4-1 ) 
               Z( J4-1 ) = Z( IPN4-J4-5 ) 
               Z( IPN4-J4-5 ) = TEMP 
               TEMP = Z( J4 ) 
               Z( J4 ) = Z( IPN4-J4-4 ) 
               Z( IPN4-J4-4 ) = TEMP 
   60       CONTINUE 
            IF( N0-I0.LE.4 ) THEN 
               Z( 4*N0+PP-1 ) = Z( 4*I0+PP-1 ) 
               Z( 4*N0-PP ) = Z( 4*I0-PP ) 
            END IF 
            DMIN2 = MIN( DMIN2, Z( 4*N0+PP-1 ) ) 
            Z( 4*N0+PP-1 ) = MIN( Z( 4*N0+PP-1 ), Z( 4*I0+PP-1 ),       &
     &                            Z( 4*I0+PP+3 ) )                      
            Z( 4*N0-PP ) = MIN( Z( 4*N0-PP ), Z( 4*I0-PP ),             &
     &                          Z( 4*I0-PP+4 ) )                        
            QMAX = MAX( QMAX, Z( 4*I0+PP-3 ), Z( 4*I0+PP+1 ) ) 
            DMIN = -ZERO 
         END IF 
      END IF 
!                                                                       
!     Choose a shift.                                                   
!                                                                       
      CALL SLASQ4( I0, N0, Z, PP, N0IN, DMIN, DMIN1, DMIN2, DN, DN1,    &
     &             DN2, TAU, TTYPE, G )                                 
!                                                                       
!     Call dqds until DMIN > 0.                                         
!                                                                       
   70 CONTINUE 
!                                                                       
      CALL SLASQ5( I0, N0, Z, PP, TAU, SIGMA, DMIN, DMIN1, DMIN2, DN,   &
     &             DN1, DN2, IEEE, EPS )                                
!                                                                       
      NDIV = NDIV + ( N0-I0+2 ) 
      ITER = ITER + 1 
!                                                                       
!     Check status.                                                     
!                                                                       
      IF( DMIN.GE.ZERO .AND. DMIN1.GE.ZERO ) THEN 
!                                                                       
!        Success.                                                       
!                                                                       
         GO TO 90 
!                                                                       
      ELSE IF( DMIN.LT.ZERO .AND. DMIN1.GT.ZERO .AND.                   &
     &         Z( 4*( N0-1 )-PP ).LT.TOL*( SIGMA+DN1 ) .AND.            &
     &         ABS( DN ).LT.TOL*SIGMA ) THEN                            
!                                                                       
!        Convergence hidden by negative DN.                             
!                                                                       
         Z( 4*( N0-1 )-PP+2 ) = ZERO 
         DMIN = ZERO 
         GO TO 90 
      ELSE IF( DMIN.LT.ZERO ) THEN 
!                                                                       
!        TAU too big. Select new TAU and try again.                     
!                                                                       
         NFAIL = NFAIL + 1 
         IF( TTYPE.LT.-22 ) THEN 
!                                                                       
!           Failed twice. Play it safe.                                 
!                                                                       
            TAU = ZERO 
         ELSE IF( DMIN1.GT.ZERO ) THEN 
!                                                                       
!           Late failure. Gives excellent shift.                        
!                                                                       
            TAU = ( TAU+DMIN )*( ONE-TWO*EPS ) 
            TTYPE = TTYPE - 11 
         ELSE 
!                                                                       
!           Early failure. Divide by 4.                                 
!                                                                       
            TAU = QURTR*TAU 
            TTYPE = TTYPE - 12 
         END IF 
         GO TO 70 
      ELSE IF( SISNAN( DMIN ) ) THEN 
!                                                                       
!        NaN.                                                           
!                                                                       
         IF( TAU.EQ.ZERO ) THEN 
            GO TO 80 
         ELSE 
            TAU = ZERO 
            GO TO 70 
         END IF 
      ELSE 
!                                                                       
!        Possible underflow. Play it safe.                              
!                                                                       
         GO TO 80 
      END IF 
!                                                                       
!     Risk of underflow.                                                
!                                                                       
   80 CONTINUE 
      CALL SLASQ6( I0, N0, Z, PP, DMIN, DMIN1, DMIN2, DN, DN1, DN2 ) 
      NDIV = NDIV + ( N0-I0+2 ) 
      ITER = ITER + 1 
      TAU = ZERO 
!                                                                       
   90 CONTINUE 
      IF( TAU.LT.SIGMA ) THEN 
         DESIG = DESIG + TAU 
         T = SIGMA + DESIG 
         DESIG = DESIG - ( T-SIGMA ) 
      ELSE 
         T = SIGMA + TAU 
         DESIG = SIGMA - ( T-TAU ) + DESIG 
      END IF 
      SIGMA = T 
!                                                                       
      RETURN 
!                                                                       
!     End of SLASQ3                                                     
!                                                                       
      END                                           
!> \brief \b SLASQ4 computes an approximation to the smallest eigenvalue
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLASQ4 + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SLASQ4( I0, N0, Z, PP, N0IN, DMIN, DMIN1, DMIN2, DN, 
!                          DN1, DN2, TAU, TTYPE, G )                    
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            I0, N0, N0IN, PP, TTYPE                      
!       REAL               DMIN, DMIN1, DMIN2, DN, DN1, DN2, G, TAU     
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL               Z( * )                                       
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SLASQ4 computes an approximation TAU to the smallest eigenvalue      
!> using values of d from the previous transform.                       
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] I0                                                        
!> \verbatim                                                            
!>          I0 is INTEGER                                               
!>        First index.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N0                                                        
!> \verbatim                                                            
!>          N0 is INTEGER                                               
!>        Last index.                                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] Z                                                         
!> \verbatim                                                            
!>          Z is REAL array, dimension ( 4*N0 )                         
!>        Z holds the qd array.                                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] PP                                                        
!> \verbatim                                                            
!>          PP is INTEGER                                               
!>        PP=0 for ping, PP=1 for pong.                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N0IN                                                      
!> \verbatim                                                            
!>          N0IN is INTEGER                                             
!>        The value of N0 at start of EIGTEST.                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] DMIN                                                      
!> \verbatim                                                            
!>          DMIN is REAL                                                
!>        Minimum value of d.                                           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] DMIN1                                                     
!> \verbatim                                                            
!>          DMIN1 is REAL                                               
!>        Minimum value of d, excluding D( N0 ).                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] DMIN2                                                     
!> \verbatim                                                            
!>          DMIN2 is REAL                                               
!>        Minimum value of d, excluding D( N0 ) and D( N0-1 ).          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] DN                                                        
!> \verbatim                                                            
!>          DN is REAL                                                  
!>        d(N)                                                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] DN1                                                       
!> \verbatim                                                            
!>          DN1 is REAL                                                 
!>        d(N-1)                                                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] DN2                                                       
!> \verbatim                                                            
!>          DN2 is REAL                                                 
!>        d(N-2)                                                        
!> \endverbatim                                                         
!>                                                                      
!> \param[out] TAU                                                      
!> \verbatim                                                            
!>          TAU is REAL                                                 
!>        This is the shift.                                            
!> \endverbatim                                                         
!>                                                                      
!> \param[out] TTYPE                                                    
!> \verbatim                                                            
!>          TTYPE is INTEGER                                            
!>        Shift type.                                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] G                                                     
!> \verbatim                                                            
!>          G is REAL                                                   
!>        G is passed as an argument in order to save its value between 
!>        calls to SLASQ4.                                              
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2016                                                      
!                                                                       
!> \ingroup auxOTHERcomputational                                       
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  CNST1 = 9/16                                                        
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE SLASQ4( I0, N0, Z, PP, N0IN, DMIN, DMIN1, DMIN2, DN,   &
     &                   DN1, DN2, TAU, TTYPE, G )                      
!                                                                       
!  -- LAPACK computational routine (version 3.7.1) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2016                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            I0, N0, N0IN, PP, TTYPE 
      REAL               DMIN, DMIN1, DMIN2, DN, DN1, DN2, G, TAU 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               Z( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               CNST1, CNST2, CNST3 
      PARAMETER          ( CNST1 = 0.5630E0, CNST2 = 1.010E0,           &
     &                   CNST3 = 1.050E0 )                              
      REAL               QURTR, THIRD, HALF, ZERO, ONE, TWO, HUNDRD 
      PARAMETER          ( QURTR = 0.250E0, THIRD = 0.3330E0,           &
     &                   HALF = 0.50E0, ZERO = 0.0E0, ONE = 1.0E0,      &
     &                   TWO = 2.0E0, HUNDRD = 100.0E0 )                
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I4, NN, NP 
      REAL               A2, B1, B2, GAM, GAP1, GAP2, S 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX, MIN, SQRT 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     A negative DMIN forces the shift to take that absolute value      
!     TTYPE records the type of shift.                                  
!                                                                       
      IF( DMIN.LE.ZERO ) THEN 
         TAU = -DMIN 
         TTYPE = -1 
         RETURN 
      END IF 
!                                                                       
      NN = 4*N0 + PP 
      IF( N0IN.EQ.N0 ) THEN 
!                                                                       
!        No eigenvalues deflated.                                       
!                                                                       
         IF( DMIN.EQ.DN .OR. DMIN.EQ.DN1 ) THEN 
!                                                                       
            B1 = SQRT( Z( NN-3 ) )*SQRT( Z( NN-5 ) ) 
            B2 = SQRT( Z( NN-7 ) )*SQRT( Z( NN-9 ) ) 
            A2 = Z( NN-7 ) + Z( NN-5 ) 
!                                                                       
!           Cases 2 and 3.                                              
!                                                                       
            IF( DMIN.EQ.DN .AND. DMIN1.EQ.DN1 ) THEN 
               GAP2 = DMIN2 - A2 - DMIN2*QURTR 
               IF( GAP2.GT.ZERO .AND. GAP2.GT.B2 ) THEN 
                  GAP1 = A2 - DN - ( B2 / GAP2 )*B2 
               ELSE 
                  GAP1 = A2 - DN - ( B1+B2 ) 
               END IF 
               IF( GAP1.GT.ZERO .AND. GAP1.GT.B1 ) THEN 
                  S = MAX( DN-( B1 / GAP1 )*B1, HALF*DMIN ) 
                  TTYPE = -2 
               ELSE 
                  S = ZERO 
                  IF( DN.GT.B1 )                                        &
     &               S = DN - B1                                        
                  IF( A2.GT.( B1+B2 ) )                                 &
     &               S = MIN( S, A2-( B1+B2 ) )                         
                  S = MAX( S, THIRD*DMIN ) 
                  TTYPE = -3 
               END IF 
            ELSE 
!                                                                       
!              Case 4.                                                  
!                                                                       
               TTYPE = -4 
               S = QURTR*DMIN 
               IF( DMIN.EQ.DN ) THEN 
                  GAM = DN 
                  A2 = ZERO 
                  IF( Z( NN-5 ) .GT. Z( NN-7 ) )                        &
     &               RETURN                                             
                  B2 = Z( NN-5 ) / Z( NN-7 ) 
                  NP = NN - 9 
               ELSE 
                  NP = NN - 2*PP 
                  GAM = DN1 
                  IF( Z( NP-4 ) .GT. Z( NP-2 ) )                        &
     &               RETURN                                             
                  A2 = Z( NP-4 ) / Z( NP-2 ) 
                  IF( Z( NN-9 ) .GT. Z( NN-11 ) )                       &
     &               RETURN                                             
                  B2 = Z( NN-9 ) / Z( NN-11 ) 
                  NP = NN - 13 
               END IF 
!                                                                       
!              Approximate contribution to norm squared from I < NN-1.  
!                                                                       
               A2 = A2 + B2 
               DO 10 I4 = NP, 4*I0 - 1 + PP, -4 
                  IF( B2.EQ.ZERO )                                      &
     &               GO TO 20                                           
                  B1 = B2 
                  IF( Z( I4 ) .GT. Z( I4-2 ) )                          &
     &               RETURN                                             
                  B2 = B2*( Z( I4 ) / Z( I4-2 ) ) 
                  A2 = A2 + B2 
                  IF( HUNDRD*MAX( B2, B1 ).LT.A2 .OR. CNST1.LT.A2 )     &
     &               GO TO 20                                           
   10          CONTINUE 
   20          CONTINUE 
               A2 = CNST3*A2 
!                                                                       
!              Rayleigh quotient residual bound.                        
!                                                                       
               IF( A2.LT.CNST1 )                                        &
     &            S = GAM*( ONE-SQRT( A2 ) ) / ( ONE+A2 )               
            END IF 
         ELSE IF( DMIN.EQ.DN2 ) THEN 
!                                                                       
!           Case 5.                                                     
!                                                                       
            TTYPE = -5 
            S = QURTR*DMIN 
!                                                                       
!           Compute contribution to norm squared from I > NN-2.         
!                                                                       
            NP = NN - 2*PP 
            B1 = Z( NP-2 ) 
            B2 = Z( NP-6 ) 
            GAM = DN2 
            IF( Z( NP-8 ).GT.B2 .OR. Z( NP-4 ).GT.B1 )                  &
     &         RETURN                                                   
            A2 = ( Z( NP-8 ) / B2 )*( ONE+Z( NP-4 ) / B1 ) 
!                                                                       
!           Approximate contribution to norm squared from I < NN-2.     
!                                                                       
            IF( N0-I0.GT.2 ) THEN 
               B2 = Z( NN-13 ) / Z( NN-15 ) 
               A2 = A2 + B2 
               DO 30 I4 = NN - 17, 4*I0 - 1 + PP, -4 
                  IF( B2.EQ.ZERO )                                      &
     &               GO TO 40                                           
                  B1 = B2 
                  IF( Z( I4 ) .GT. Z( I4-2 ) )                          &
     &               RETURN                                             
                  B2 = B2*( Z( I4 ) / Z( I4-2 ) ) 
                  A2 = A2 + B2 
                  IF( HUNDRD*MAX( B2, B1 ).LT.A2 .OR. CNST1.LT.A2 )     &
     &               GO TO 40                                           
   30          CONTINUE 
   40          CONTINUE 
               A2 = CNST3*A2 
            END IF 
!                                                                       
            IF( A2.LT.CNST1 )                                           &
     &         S = GAM*( ONE-SQRT( A2 ) ) / ( ONE+A2 )                  
         ELSE 
!                                                                       
!           Case 6, no information to guide us.                         
!                                                                       
            IF( TTYPE.EQ.-6 ) THEN 
               G = G + THIRD*( ONE-G ) 
            ELSE IF( TTYPE.EQ.-18 ) THEN 
               G = QURTR*THIRD 
            ELSE 
               G = QURTR 
            END IF 
            S = G*DMIN 
            TTYPE = -6 
         END IF 
!                                                                       
      ELSE IF( N0IN.EQ.( N0+1 ) ) THEN 
!                                                                       
!        One eigenvalue just deflated. Use DMIN1, DN1 for DMIN and DN.  
!                                                                       
         IF( DMIN1.EQ.DN1 .AND. DMIN2.EQ.DN2 ) THEN 
!                                                                       
!           Cases 7 and 8.                                              
!                                                                       
            TTYPE = -7 
            S = THIRD*DMIN1 
            IF( Z( NN-5 ).GT.Z( NN-7 ) )                                &
     &         RETURN                                                   
            B1 = Z( NN-5 ) / Z( NN-7 ) 
            B2 = B1 
            IF( B2.EQ.ZERO )                                            &
     &         GO TO 60                                                 
            DO 50 I4 = 4*N0 - 9 + PP, 4*I0 - 1 + PP, -4 
               A2 = B1 
               IF( Z( I4 ).GT.Z( I4-2 ) )                               &
     &            RETURN                                                
               B1 = B1*( Z( I4 ) / Z( I4-2 ) ) 
               B2 = B2 + B1 
               IF( HUNDRD*MAX( B1, A2 ).LT.B2 )                         &
     &            GO TO 60                                              
   50       CONTINUE 
   60       CONTINUE 
            B2 = SQRT( CNST3*B2 ) 
            A2 = DMIN1 / ( ONE+B2**2 ) 
            GAP2 = HALF*DMIN2 - A2 
            IF( GAP2.GT.ZERO .AND. GAP2.GT.B2*A2 ) THEN 
               S = MAX( S, A2*( ONE-CNST2*A2*( B2 / GAP2 )*B2 ) ) 
            ELSE 
               S = MAX( S, A2*( ONE-CNST2*B2 ) ) 
               TTYPE = -8 
            END IF 
         ELSE 
!                                                                       
!           Case 9.                                                     
!                                                                       
            S = QURTR*DMIN1 
            IF( DMIN1.EQ.DN1 )                                          &
     &         S = HALF*DMIN1                                           
            TTYPE = -9 
         END IF 
!                                                                       
      ELSE IF( N0IN.EQ.( N0+2 ) ) THEN 
!                                                                       
!        Two eigenvalues deflated. Use DMIN2, DN2 for DMIN and DN.      
!                                                                       
!        Cases 10 and 11.                                               
!                                                                       
         IF( DMIN2.EQ.DN2 .AND. TWO*Z( NN-5 ).LT.Z( NN-7 ) ) THEN 
            TTYPE = -10 
            S = THIRD*DMIN2 
            IF( Z( NN-5 ).GT.Z( NN-7 ) )                                &
     &         RETURN                                                   
            B1 = Z( NN-5 ) / Z( NN-7 ) 
            B2 = B1 
            IF( B2.EQ.ZERO )                                            &
     &         GO TO 80                                                 
            DO 70 I4 = 4*N0 - 9 + PP, 4*I0 - 1 + PP, -4 
               IF( Z( I4 ).GT.Z( I4-2 ) )                               &
     &            RETURN                                                
               B1 = B1*( Z( I4 ) / Z( I4-2 ) ) 
               B2 = B2 + B1 
               IF( HUNDRD*B1.LT.B2 )                                    &
     &            GO TO 80                                              
   70       CONTINUE 
   80       CONTINUE 
            B2 = SQRT( CNST3*B2 ) 
            A2 = DMIN2 / ( ONE+B2**2 ) 
            GAP2 = Z( NN-7 ) + Z( NN-9 ) -                              &
     &             SQRT( Z( NN-11 ) )*SQRT( Z( NN-9 ) ) - A2            
            IF( GAP2.GT.ZERO .AND. GAP2.GT.B2*A2 ) THEN 
               S = MAX( S, A2*( ONE-CNST2*A2*( B2 / GAP2 )*B2 ) ) 
            ELSE 
               S = MAX( S, A2*( ONE-CNST2*B2 ) ) 
            END IF 
         ELSE 
            S = QURTR*DMIN2 
            TTYPE = -11 
         END IF 
      ELSE IF( N0IN.GT.( N0+2 ) ) THEN 
!                                                                       
!        Case 12, more than two eigenvalues deflated. No information.   
!                                                                       
         S = ZERO 
         TTYPE = -12 
      END IF 
!                                                                       
      TAU = S 
      RETURN 
!                                                                       
!     End of SLASQ4                                                     
!                                                                       
      END                                           
!> \brief <b> SLASQ5 computes one dqds transform in ping-pong form. Used
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLASQ5 + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SLASQ5( I0, N0, Z, PP, TAU, SIGMA, DMIN, DMIN1, DMIN2
!                          DNM1, DNM2, IEEE, EPS )                      
!                                                                       
!       .. Scalar Arguments ..                                          
!       LOGICAL            IEEE                                         
!       INTEGER            I0, N0, PP                                   
!       REAL               EPS, DMIN, DMIN1, DMIN2, DN, DNM1, DNM2, SIGM
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL               Z( * )                                       
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SLASQ5 computes one dqds transform in ping-pong form, one            
!> version for IEEE machines another for non IEEE machines.             
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] I0                                                        
!> \verbatim                                                            
!>          I0 is INTEGER                                               
!>        First index.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N0                                                        
!> \verbatim                                                            
!>          N0 is INTEGER                                               
!>        Last index.                                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] Z                                                         
!> \verbatim                                                            
!>          Z is REAL array, dimension ( 4*N )                          
!>        Z holds the qd array. EMIN is stored in Z(4*N0) to avoid      
!>        an extra argument.                                            
!> \endverbatim                                                         
!>                                                                      
!> \param[in] PP                                                        
!> \verbatim                                                            
!>          PP is INTEGER                                               
!>        PP=0 for ping, PP=1 for pong.                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TAU                                                       
!> \verbatim                                                            
!>          TAU is REAL                                                 
!>        This is the shift.                                            
!> \endverbatim                                                         
!>                                                                      
!> \param[in] SIGMA                                                     
!> \verbatim                                                            
!>          SIGMA is REAL                                               
!>        This is the accumulated shift up to this step.                
!> \endverbatim                                                         
!>                                                                      
!> \param[out] DMIN                                                     
!> \verbatim                                                            
!>          DMIN is REAL                                                
!>        Minimum value of d.                                           
!> \endverbatim                                                         
!>                                                                      
!> \param[out] DMIN1                                                    
!> \verbatim                                                            
!>          DMIN1 is REAL                                               
!>        Minimum value of d, excluding D( N0 ).                        
!> \endverbatim                                                         
!>                                                                      
!> \param[out] DMIN2                                                    
!> \verbatim                                                            
!>          DMIN2 is REAL                                               
!>        Minimum value of d, excluding D( N0 ) and D( N0-1 ).          
!> \endverbatim                                                         
!>                                                                      
!> \param[out] DN                                                       
!> \verbatim                                                            
!>          DN is REAL                                                  
!>        d(N0), the last value of d.                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[out] DNM1                                                     
!> \verbatim                                                            
!>          DNM1 is REAL                                                
!>        d(N0-1).                                                      
!> \endverbatim                                                         
!>                                                                      
!> \param[out] DNM2                                                     
!> \verbatim                                                            
!>          DNM2 is REAL                                                
!>        d(N0-2).                                                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IEEE                                                      
!> \verbatim                                                            
!>          IEEE is LOGICAL                                             
!>        Flag for IEEE or non IEEE arithmetic.                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] EPS                                                       
!> \verbatim                                                            
!>         EPS is REAL                                                  
!>        This is the value of epsilon used.                            
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup auxOTHERcomputational                                       
!                                                                       
!  =====================================================================
      SUBROUTINE SLASQ5( I0, N0, Z, PP, TAU, SIGMA, DMIN, DMIN1, DMIN2, &
     &                   DN, DNM1, DNM2, IEEE, EPS )                    
!                                                                       
!  -- LAPACK computational routine (version 3.7.0) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      LOGICAL            IEEE 
      INTEGER            I0, N0, PP 
      REAL               DMIN, DMIN1, DMIN2, DN, DNM1, DNM2, TAU,       &
     &                   SIGMA, EPS                                     
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               Z( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameter ..                                                   
      REAL               ZERO, HALF 
      PARAMETER          ( ZERO = 0.0E0, HALF = 0.5 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            J4, J4P2 
      REAL               D, EMIN, TEMP, DTHRESH 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MIN 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      IF( ( N0-I0-1 ).LE.0 )                                            &
     &   RETURN                                                         
!                                                                       
      DTHRESH = EPS*(SIGMA+TAU) 
      IF( TAU.LT.DTHRESH*HALF ) TAU = ZERO 
      IF( TAU.NE.ZERO ) THEN 
         J4 = 4*I0 + PP - 3 
         EMIN = Z( J4+4 ) 
         D = Z( J4 ) - TAU 
         DMIN = D 
         DMIN1 = -Z( J4 ) 
!                                                                       
         IF( IEEE ) THEN 
!                                                                       
!     Code for IEEE arithmetic.                                         
!                                                                       
            IF( PP.EQ.0 ) THEN 
               DO 10 J4 = 4*I0, 4*( N0-3 ), 4 
                  Z( J4-2 ) = D + Z( J4-1 ) 
                  TEMP = Z( J4+1 ) / Z( J4-2 ) 
                  D = D*TEMP - TAU 
                  DMIN = MIN( DMIN, D ) 
                  Z( J4 ) = Z( J4-1 )*TEMP 
                  EMIN = MIN( Z( J4 ), EMIN ) 
   10          CONTINUE 
            ELSE 
               DO 20 J4 = 4*I0, 4*( N0-3 ), 4 
                  Z( J4-3 ) = D + Z( J4 ) 
                  TEMP = Z( J4+2 ) / Z( J4-3 ) 
                  D = D*TEMP - TAU 
                  DMIN = MIN( DMIN, D ) 
                  Z( J4-1 ) = Z( J4 )*TEMP 
                  EMIN = MIN( Z( J4-1 ), EMIN ) 
   20          CONTINUE 
            END IF 
!                                                                       
!     Unroll last two steps.                                            
!                                                                       
            DNM2 = D 
            DMIN2 = DMIN 
            J4 = 4*( N0-2 ) - PP 
            J4P2 = J4 + 2*PP - 1 
            Z( J4-2 ) = DNM2 + Z( J4P2 ) 
            Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) ) 
            DNM1 = Z( J4P2+2 )*( DNM2 / Z( J4-2 ) ) - TAU 
            DMIN = MIN( DMIN, DNM1 ) 
!                                                                       
            DMIN1 = DMIN 
            J4 = J4 + 4 
            J4P2 = J4 + 2*PP - 1 
            Z( J4-2 ) = DNM1 + Z( J4P2 ) 
            Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) ) 
            DN = Z( J4P2+2 )*( DNM1 / Z( J4-2 ) ) - TAU 
            DMIN = MIN( DMIN, DN ) 
!                                                                       
         ELSE 
!                                                                       
!     Code for non IEEE arithmetic.                                     
!                                                                       
            IF( PP.EQ.0 ) THEN 
               DO 30 J4 = 4*I0, 4*( N0-3 ), 4 
                  Z( J4-2 ) = D + Z( J4-1 ) 
                  IF( D.LT.ZERO ) THEN 
                     RETURN 
                  ELSE 
                     Z( J4 ) = Z( J4+1 )*( Z( J4-1 ) / Z( J4-2 ) ) 
                     D = Z( J4+1 )*( D / Z( J4-2 ) ) - TAU 
                  END IF 
                  DMIN = MIN( DMIN, D ) 
                  EMIN = MIN( EMIN, Z( J4 ) ) 
   30          CONTINUE 
            ELSE 
               DO 40 J4 = 4*I0, 4*( N0-3 ), 4 
                  Z( J4-3 ) = D + Z( J4 ) 
                  IF( D.LT.ZERO ) THEN 
                     RETURN 
                  ELSE 
                     Z( J4-1 ) = Z( J4+2 )*( Z( J4 ) / Z( J4-3 ) ) 
                     D = Z( J4+2 )*( D / Z( J4-3 ) ) - TAU 
                  END IF 
                  DMIN = MIN( DMIN, D ) 
                  EMIN = MIN( EMIN, Z( J4-1 ) ) 
   40          CONTINUE 
            END IF 
!                                                                       
!     Unroll last two steps.                                            
!                                                                       
            DNM2 = D 
            DMIN2 = DMIN 
            J4 = 4*( N0-2 ) - PP 
            J4P2 = J4 + 2*PP - 1 
            Z( J4-2 ) = DNM2 + Z( J4P2 ) 
            IF( DNM2.LT.ZERO ) THEN 
               RETURN 
            ELSE 
               Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) ) 
               DNM1 = Z( J4P2+2 )*( DNM2 / Z( J4-2 ) ) - TAU 
            END IF 
            DMIN = MIN( DMIN, DNM1 ) 
!                                                                       
            DMIN1 = DMIN 
            J4 = J4 + 4 
            J4P2 = J4 + 2*PP - 1 
            Z( J4-2 ) = DNM1 + Z( J4P2 ) 
            IF( DNM1.LT.ZERO ) THEN 
               RETURN 
            ELSE 
               Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) ) 
               DN = Z( J4P2+2 )*( DNM1 / Z( J4-2 ) ) - TAU 
            END IF 
            DMIN = MIN( DMIN, DN ) 
!                                                                       
         END IF 
!                                                                       
      ELSE 
!     This is the version that sets d's to zero if they are small enough
         J4 = 4*I0 + PP - 3 
         EMIN = Z( J4+4 ) 
         D = Z( J4 ) - TAU 
         DMIN = D 
         DMIN1 = -Z( J4 ) 
         IF( IEEE ) THEN 
!                                                                       
!     Code for IEEE arithmetic.                                         
!                                                                       
            IF( PP.EQ.0 ) THEN 
               DO 50 J4 = 4*I0, 4*( N0-3 ), 4 
                  Z( J4-2 ) = D + Z( J4-1 ) 
                  TEMP = Z( J4+1 ) / Z( J4-2 ) 
                  D = D*TEMP - TAU 
                  IF( D.LT.DTHRESH ) D = ZERO 
                  DMIN = MIN( DMIN, D ) 
                  Z( J4 ) = Z( J4-1 )*TEMP 
                  EMIN = MIN( Z( J4 ), EMIN ) 
   50          CONTINUE 
            ELSE 
               DO 60 J4 = 4*I0, 4*( N0-3 ), 4 
                  Z( J4-3 ) = D + Z( J4 ) 
                  TEMP = Z( J4+2 ) / Z( J4-3 ) 
                  D = D*TEMP - TAU 
                  IF( D.LT.DTHRESH ) D = ZERO 
                  DMIN = MIN( DMIN, D ) 
                  Z( J4-1 ) = Z( J4 )*TEMP 
                  EMIN = MIN( Z( J4-1 ), EMIN ) 
   60          CONTINUE 
            END IF 
!                                                                       
!     Unroll last two steps.                                            
!                                                                       
            DNM2 = D 
            DMIN2 = DMIN 
            J4 = 4*( N0-2 ) - PP 
            J4P2 = J4 + 2*PP - 1 
            Z( J4-2 ) = DNM2 + Z( J4P2 ) 
            Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) ) 
            DNM1 = Z( J4P2+2 )*( DNM2 / Z( J4-2 ) ) - TAU 
            DMIN = MIN( DMIN, DNM1 ) 
!                                                                       
            DMIN1 = DMIN 
            J4 = J4 + 4 
            J4P2 = J4 + 2*PP - 1 
            Z( J4-2 ) = DNM1 + Z( J4P2 ) 
            Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) ) 
            DN = Z( J4P2+2 )*( DNM1 / Z( J4-2 ) ) - TAU 
            DMIN = MIN( DMIN, DN ) 
!                                                                       
         ELSE 
!                                                                       
!     Code for non IEEE arithmetic.                                     
!                                                                       
            IF( PP.EQ.0 ) THEN 
               DO 70 J4 = 4*I0, 4*( N0-3 ), 4 
                  Z( J4-2 ) = D + Z( J4-1 ) 
                  IF( D.LT.ZERO ) THEN 
                     RETURN 
                  ELSE 
                     Z( J4 ) = Z( J4+1 )*( Z( J4-1 ) / Z( J4-2 ) ) 
                     D = Z( J4+1 )*( D / Z( J4-2 ) ) - TAU 
                  END IF 
                  IF( D.LT.DTHRESH ) D = ZERO 
                  DMIN = MIN( DMIN, D ) 
                  EMIN = MIN( EMIN, Z( J4 ) ) 
   70          CONTINUE 
            ELSE 
               DO 80 J4 = 4*I0, 4*( N0-3 ), 4 
                  Z( J4-3 ) = D + Z( J4 ) 
                  IF( D.LT.ZERO ) THEN 
                     RETURN 
                  ELSE 
                     Z( J4-1 ) = Z( J4+2 )*( Z( J4 ) / Z( J4-3 ) ) 
                     D = Z( J4+2 )*( D / Z( J4-3 ) ) - TAU 
                  END IF 
                  IF( D.LT.DTHRESH ) D = ZERO 
                  DMIN = MIN( DMIN, D ) 
                  EMIN = MIN( EMIN, Z( J4-1 ) ) 
   80          CONTINUE 
            END IF 
!                                                                       
!     Unroll last two steps.                                            
!                                                                       
            DNM2 = D 
            DMIN2 = DMIN 
            J4 = 4*( N0-2 ) - PP 
            J4P2 = J4 + 2*PP - 1 
            Z( J4-2 ) = DNM2 + Z( J4P2 ) 
            IF( DNM2.LT.ZERO ) THEN 
               RETURN 
            ELSE 
               Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) ) 
               DNM1 = Z( J4P2+2 )*( DNM2 / Z( J4-2 ) ) - TAU 
            END IF 
            DMIN = MIN( DMIN, DNM1 ) 
!                                                                       
            DMIN1 = DMIN 
            J4 = J4 + 4 
            J4P2 = J4 + 2*PP - 1 
            Z( J4-2 ) = DNM1 + Z( J4P2 ) 
            IF( DNM1.LT.ZERO ) THEN 
               RETURN 
            ELSE 
               Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) ) 
               DN = Z( J4P2+2 )*( DNM1 / Z( J4-2 ) ) - TAU 
            END IF 
            DMIN = MIN( DMIN, DN ) 
!                                                                       
         END IF 
!                                                                       
      END IF 
      Z( J4+2 ) = DN 
      Z( 4*N0-PP ) = EMIN 
      RETURN 
!                                                                       
!     End of SLASQ5                                                     
!                                                                       
      END                                           
!> \brief \b SLASQ6 computes one dqd transform in ping-pong form. Used b
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLASQ6 + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SLASQ6( I0, N0, Z, PP, DMIN, DMIN1, DMIN2, DN,       
!                          DNM1, DNM2 )                                 
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            I0, N0, PP                                   
!       REAL               DMIN, DMIN1, DMIN2, DN, DNM1, DNM2           
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL               Z( * )                                       
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SLASQ6 computes one dqd (shift equal to zero) transform in           
!> ping-pong form, with protection against underflow and overflow.      
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] I0                                                        
!> \verbatim                                                            
!>          I0 is INTEGER                                               
!>        First index.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N0                                                        
!> \verbatim                                                            
!>          N0 is INTEGER                                               
!>        Last index.                                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] Z                                                         
!> \verbatim                                                            
!>          Z is REAL array, dimension ( 4*N )                          
!>        Z holds the qd array. EMIN is stored in Z(4*N0) to avoid      
!>        an extra argument.                                            
!> \endverbatim                                                         
!>                                                                      
!> \param[in] PP                                                        
!> \verbatim                                                            
!>          PP is INTEGER                                               
!>        PP=0 for ping, PP=1 for pong.                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[out] DMIN                                                     
!> \verbatim                                                            
!>          DMIN is REAL                                                
!>        Minimum value of d.                                           
!> \endverbatim                                                         
!>                                                                      
!> \param[out] DMIN1                                                    
!> \verbatim                                                            
!>          DMIN1 is REAL                                               
!>        Minimum value of d, excluding D( N0 ).                        
!> \endverbatim                                                         
!>                                                                      
!> \param[out] DMIN2                                                    
!> \verbatim                                                            
!>          DMIN2 is REAL                                               
!>        Minimum value of d, excluding D( N0 ) and D( N0-1 ).          
!> \endverbatim                                                         
!>                                                                      
!> \param[out] DN                                                       
!> \verbatim                                                            
!>          DN is REAL                                                  
!>        d(N0), the last value of d.                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[out] DNM1                                                     
!> \verbatim                                                            
!>          DNM1 is REAL                                                
!>        d(N0-1).                                                      
!> \endverbatim                                                         
!>                                                                      
!> \param[out] DNM2                                                     
!> \verbatim                                                            
!>          DNM2 is REAL                                                
!>        d(N0-2).                                                      
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup auxOTHERcomputational                                       
!                                                                       
!  =====================================================================
      SUBROUTINE SLASQ6( I0, N0, Z, PP, DMIN, DMIN1, DMIN2, DN,         &
     &                   DNM1, DNM2 )                                   
!                                                                       
!  -- LAPACK computational routine (version 3.7.0) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            I0, N0, PP 
      REAL               DMIN, DMIN1, DMIN2, DN, DNM1, DNM2 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               Z( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameter ..                                                   
      REAL               ZERO 
      PARAMETER          ( ZERO = 0.0E0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            J4, J4P2 
      REAL               D, EMIN, SAFMIN, TEMP 
!     ..                                                                
!     .. External Function ..                                           
      REAL               SLAMCH 
      EXTERNAL           SLAMCH 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MIN 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      IF( ( N0-I0-1 ).LE.0 )                                            &
     &   RETURN                                                         
!                                                                       
      SAFMIN = SLAMCH( 'Safe minimum' ) 
      J4 = 4*I0 + PP - 3 
      EMIN = Z( J4+4 ) 
      D = Z( J4 ) 
      DMIN = D 
!                                                                       
      IF( PP.EQ.0 ) THEN 
         DO 10 J4 = 4*I0, 4*( N0-3 ), 4 
            Z( J4-2 ) = D + Z( J4-1 ) 
            IF( Z( J4-2 ).EQ.ZERO ) THEN 
               Z( J4 ) = ZERO 
               D = Z( J4+1 ) 
               DMIN = D 
               EMIN = ZERO 
            ELSE IF( SAFMIN*Z( J4+1 ).LT.Z( J4-2 ) .AND.                &
     &               SAFMIN*Z( J4-2 ).LT.Z( J4+1 ) ) THEN               
               TEMP = Z( J4+1 ) / Z( J4-2 ) 
               Z( J4 ) = Z( J4-1 )*TEMP 
               D = D*TEMP 
            ELSE 
               Z( J4 ) = Z( J4+1 )*( Z( J4-1 ) / Z( J4-2 ) ) 
               D = Z( J4+1 )*( D / Z( J4-2 ) ) 
            END IF 
            DMIN = MIN( DMIN, D ) 
            EMIN = MIN( EMIN, Z( J4 ) ) 
   10    CONTINUE 
      ELSE 
         DO 20 J4 = 4*I0, 4*( N0-3 ), 4 
            Z( J4-3 ) = D + Z( J4 ) 
            IF( Z( J4-3 ).EQ.ZERO ) THEN 
               Z( J4-1 ) = ZERO 
               D = Z( J4+2 ) 
               DMIN = D 
               EMIN = ZERO 
            ELSE IF( SAFMIN*Z( J4+2 ).LT.Z( J4-3 ) .AND.                &
     &               SAFMIN*Z( J4-3 ).LT.Z( J4+2 ) ) THEN               
               TEMP = Z( J4+2 ) / Z( J4-3 ) 
               Z( J4-1 ) = Z( J4 )*TEMP 
               D = D*TEMP 
            ELSE 
               Z( J4-1 ) = Z( J4+2 )*( Z( J4 ) / Z( J4-3 ) ) 
               D = Z( J4+2 )*( D / Z( J4-3 ) ) 
            END IF 
            DMIN = MIN( DMIN, D ) 
            EMIN = MIN( EMIN, Z( J4-1 ) ) 
   20    CONTINUE 
      END IF 
!                                                                       
!     Unroll last two steps.                                            
!                                                                       
      DNM2 = D 
      DMIN2 = DMIN 
      J4 = 4*( N0-2 ) - PP 
      J4P2 = J4 + 2*PP - 1 
      Z( J4-2 ) = DNM2 + Z( J4P2 ) 
      IF( Z( J4-2 ).EQ.ZERO ) THEN 
         Z( J4 ) = ZERO 
         DNM1 = Z( J4P2+2 ) 
         DMIN = DNM1 
         EMIN = ZERO 
      ELSE IF( SAFMIN*Z( J4P2+2 ).LT.Z( J4-2 ) .AND.                    &
     &         SAFMIN*Z( J4-2 ).LT.Z( J4P2+2 ) ) THEN                   
         TEMP = Z( J4P2+2 ) / Z( J4-2 ) 
         Z( J4 ) = Z( J4P2 )*TEMP 
         DNM1 = DNM2*TEMP 
      ELSE 
         Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) ) 
         DNM1 = Z( J4P2+2 )*( DNM2 / Z( J4-2 ) ) 
      END IF 
      DMIN = MIN( DMIN, DNM1 ) 
!                                                                       
      DMIN1 = DMIN 
      J4 = J4 + 4 
      J4P2 = J4 + 2*PP - 1 
      Z( J4-2 ) = DNM1 + Z( J4P2 ) 
      IF( Z( J4-2 ).EQ.ZERO ) THEN 
         Z( J4 ) = ZERO 
         DN = Z( J4P2+2 ) 
         DMIN = DN 
         EMIN = ZERO 
      ELSE IF( SAFMIN*Z( J4P2+2 ).LT.Z( J4-2 ) .AND.                    &
     &         SAFMIN*Z( J4-2 ).LT.Z( J4P2+2 ) ) THEN                   
         TEMP = Z( J4P2+2 ) / Z( J4-2 ) 
         Z( J4 ) = Z( J4P2 )*TEMP 
         DN = DNM1*TEMP 
      ELSE 
         Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) ) 
         DN = Z( J4P2+2 )*( DNM1 / Z( J4-2 ) ) 
      END IF 
      DMIN = MIN( DMIN, DN ) 
!                                                                       
      Z( J4+2 ) = DN 
      Z( 4*N0-PP ) = EMIN 
      RETURN 
!                                                                       
!     End of SLASQ6                                                     
!                                                                       
      END                                           
!> \brief \b SLASRT sorts numbers in increasing or decreasing order.    
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLASRT + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SLASRT( ID, N, D, INFO )                             
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          ID                                           
!       INTEGER            INFO, N                                      
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL               D( * )                                       
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> Sort the numbers in D in increasing order (if ID = 'I') or           
!> in decreasing order (if ID = 'D' ).                                  
!>                                                                      
!> Use Quick Sort, reverting to Insertion sort on arrays of             
!> size <= 20. Dimension of STACK limits N to about 2**32.              
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] ID                                                        
!> \verbatim                                                            
!>          ID is CHARACTER*1                                           
!>          = 'I': sort D in increasing order;                          
!>          = 'D': sort D in decreasing order.                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The length of the array D.                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] D                                                     
!> \verbatim                                                            
!>          D is REAL array, dimension (N)                              
!>          On entry, the array to be sorted.                           
!>          On exit, D has been sorted into increasing order            
!>          (D(1) <= ... <= D(N) ) or into decreasing order             
!>          (D(1) >= ... >= D(N) ), depending on ID.                    
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0:  successful exit                                       
!>          < 0:  if INFO = -i, the i-th argument had an illegal value  
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2016                                                      
!                                                                       
!> \ingroup auxOTHERcomputational                                       
!                                                                       
!  =====================================================================
      SUBROUTINE SLASRT( ID, N, D, INFO ) 
!                                                                       
!  -- LAPACK computational routine (version 3.7.0) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2016                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          ID 
      INTEGER            INFO, N 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               D( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      INTEGER            SELECT 
      PARAMETER          ( SELECT = 20 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            DIR, ENDD, I, J, START, STKPNT 
      REAL               D1, D2, D3, DMNMX, TMP 
!     ..                                                                
!     .. Local Arrays ..                                                
      INTEGER            STACK( 2, 32 ) 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      EXTERNAL           LSAME 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           XERBLA 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0 
      DIR = -1 
      IF( LSAME( ID, 'D' ) ) THEN 
         DIR = 0 
      ELSE IF( LSAME( ID, 'I' ) ) THEN 
         DIR = 1 
      END IF 
      IF( DIR.EQ.-1 ) THEN 
         INFO = -1 
      ELSE IF( N.LT.0 ) THEN 
         INFO = -2 
      END IF 
      IF( INFO.NE.0 ) THEN 
         CALL XERBLA( 'SLASRT', -INFO ) 
         RETURN 
      END IF 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.LE.1 )                                                      &
     &   RETURN                                                         
!                                                                       
      STKPNT = 1 
      STACK( 1, 1 ) = 1 
      STACK( 2, 1 ) = N 
   10 CONTINUE 
      START = STACK( 1, STKPNT ) 
      ENDD = STACK( 2, STKPNT ) 
      STKPNT = STKPNT - 1 
      IF( ENDD-START.LE.SELECT .AND. ENDD-START.GT.0 ) THEN 
!                                                                       
!        Do Insertion sort on D( START:ENDD )                           
!                                                                       
         IF( DIR.EQ.0 ) THEN 
!                                                                       
!           Sort into decreasing order                                  
!                                                                       
            DO 30 I = START + 1, ENDD 
               DO 20 J = I, START + 1, -1 
                  IF( D( J ).GT.D( J-1 ) ) THEN 
                     DMNMX = D( J ) 
                     D( J ) = D( J-1 ) 
                     D( J-1 ) = DMNMX 
                  ELSE 
                     GO TO 30 
                  END IF 
   20          CONTINUE 
   30       CONTINUE 
!                                                                       
         ELSE 
!                                                                       
!           Sort into increasing order                                  
!                                                                       
            DO 50 I = START + 1, ENDD 
               DO 40 J = I, START + 1, -1 
                  IF( D( J ).LT.D( J-1 ) ) THEN 
                     DMNMX = D( J ) 
                     D( J ) = D( J-1 ) 
                     D( J-1 ) = DMNMX 
                  ELSE 
                     GO TO 50 
                  END IF 
   40          CONTINUE 
   50       CONTINUE 
!                                                                       
         END IF 
!                                                                       
      ELSE IF( ENDD-START.GT.SELECT ) THEN 
!                                                                       
!        Partition D( START:ENDD ) and stack parts, largest one first   
!                                                                       
!        Choose partition entry as median of 3                          
!                                                                       
         D1 = D( START ) 
         D2 = D( ENDD ) 
         I = ( START+ENDD ) / 2 
         D3 = D( I ) 
         IF( D1.LT.D2 ) THEN 
            IF( D3.LT.D1 ) THEN 
               DMNMX = D1 
            ELSE IF( D3.LT.D2 ) THEN 
               DMNMX = D3 
            ELSE 
               DMNMX = D2 
            END IF 
         ELSE 
            IF( D3.LT.D2 ) THEN 
               DMNMX = D2 
            ELSE IF( D3.LT.D1 ) THEN 
               DMNMX = D3 
            ELSE 
               DMNMX = D1 
            END IF 
         END IF 
!                                                                       
         IF( DIR.EQ.0 ) THEN 
!                                                                       
!           Sort into decreasing order                                  
!                                                                       
            I = START - 1 
            J = ENDD + 1 
   60       CONTINUE 
   70       CONTINUE 
            J = J - 1 
            IF( D( J ).LT.DMNMX )                                       &
     &         GO TO 70                                                 
   80       CONTINUE 
            I = I + 1 
            IF( D( I ).GT.DMNMX )                                       &
     &         GO TO 80                                                 
            IF( I.LT.J ) THEN 
               TMP = D( I ) 
               D( I ) = D( J ) 
               D( J ) = TMP 
               GO TO 60 
            END IF 
            IF( J-START.GT.ENDD-J-1 ) THEN 
               STKPNT = STKPNT + 1 
               STACK( 1, STKPNT ) = START 
               STACK( 2, STKPNT ) = J 
               STKPNT = STKPNT + 1 
               STACK( 1, STKPNT ) = J + 1 
               STACK( 2, STKPNT ) = ENDD 
            ELSE 
               STKPNT = STKPNT + 1 
               STACK( 1, STKPNT ) = J + 1 
               STACK( 2, STKPNT ) = ENDD 
               STKPNT = STKPNT + 1 
               STACK( 1, STKPNT ) = START 
               STACK( 2, STKPNT ) = J 
            END IF 
         ELSE 
!                                                                       
!           Sort into increasing order                                  
!                                                                       
            I = START - 1 
            J = ENDD + 1 
   90       CONTINUE 
  100       CONTINUE 
            J = J - 1 
            IF( D( J ).GT.DMNMX )                                       &
     &         GO TO 100                                                
  110       CONTINUE 
            I = I + 1 
            IF( D( I ).LT.DMNMX )                                       &
     &         GO TO 110                                                
            IF( I.LT.J ) THEN 
               TMP = D( I ) 
               D( I ) = D( J ) 
               D( J ) = TMP 
               GO TO 90 
            END IF 
            IF( J-START.GT.ENDD-J-1 ) THEN 
               STKPNT = STKPNT + 1 
               STACK( 1, STKPNT ) = START 
               STACK( 2, STKPNT ) = J 
               STKPNT = STKPNT + 1 
               STACK( 1, STKPNT ) = J + 1 
               STACK( 2, STKPNT ) = ENDD 
            ELSE 
               STKPNT = STKPNT + 1 
               STACK( 1, STKPNT ) = J + 1 
               STACK( 2, STKPNT ) = ENDD 
               STKPNT = STKPNT + 1 
               STACK( 1, STKPNT ) = START 
               STACK( 2, STKPNT ) = J 
            END IF 
         END IF 
      END IF 
      IF( STKPNT.GT.0 )                                                 &
     &   GO TO 10                                                       
      RETURN 
!                                                                       
!     End of SLASRT                                                     
!                                                                       
      END                                           
!> \brief \b SLASSQ updates a sum of squares represented in scaled form.
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLASSQ + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SLASSQ( N, X, INCX, SCALE, SUMSQ )                   
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            INCX, N                                      
!       REAL               SCALE, SUMSQ                                 
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL               X( * )                                       
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SLASSQ  returns the values  scl  and  smsq  such that                
!>                                                                      
!>    ( scl**2 )*smsq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq, 
!>                                                                      
!> where  x( i ) = X( 1 + ( i - 1 )*INCX ). The value of  sumsq  is     
!> assumed to be non-negative and  scl  returns the value               
!>                                                                      
!>    scl = max( scale, abs( x( i ) ) ).                                
!>                                                                      
!> scale and sumsq must be supplied in SCALE and SUMSQ and              
!> scl and smsq are overwritten on SCALE and SUMSQ respectively.        
!>                                                                      
!> The routine makes only one pass through the vector x.                
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The number of elements to be used from the vector X.        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] X                                                         
!> \verbatim                                                            
!>          X is REAL array, dimension (1+(N-1)*INCX)                   
!>          The vector for which a scaled sum of squares is computed.   
!>             x( i )  = X( 1 + ( i - 1 )*INCX ), 1 <= i <= n.          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCX                                                      
!> \verbatim                                                            
!>          INCX is INTEGER                                             
!>          The increment between successive values of the vector X.    
!>          INCX > 0.                                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] SCALE                                                 
!> \verbatim                                                            
!>          SCALE is REAL                                               
!>          On entry, the value  scale  in the equation above.          
!>          On exit, SCALE is overwritten with  scl , the scaling factor
!>          for the sum of squares.                                     
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] SUMSQ                                                 
!> \verbatim                                                            
!>          SUMSQ is REAL                                               
!>          On entry, the value  sumsq  in the equation above.          
!>          On exit, SUMSQ is overwritten with  smsq , the basic sum of 
!>          squares from which  scl  has been factored out.             
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!  =====================================================================
      SUBROUTINE SLASSQ( N, X, INCX, SCALE, SUMSQ ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            INCX, N 
      REAL               SCALE, SUMSQ 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               X( * ) 
!     ..                                                                
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Parameters ..                                                  
      REAL               ZERO 
      PARAMETER          ( ZERO = 0.0E+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            IX 
      REAL               ABSXI 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            SISNAN 
      EXTERNAL           SISNAN 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      IF( N.GT.0 ) THEN 
         DO 10 IX = 1, 1 + ( N-1 )*INCX, INCX 
            ABSXI = ABS( X( IX ) ) 
            IF( ABSXI.GT.ZERO.OR.SISNAN( ABSXI ) ) THEN 
               IF( SCALE.LT.ABSXI ) THEN 
                  SUMSQ = 1 + SUMSQ*( SCALE / ABSXI )**2 
                  SCALE = ABSXI 
               ELSE 
                  SUMSQ = SUMSQ + ( ABSXI / SCALE )**2 
               END IF 
            END IF 
   10    CONTINUE 
      END IF 
      RETURN 
!                                                                       
!     End of SLASSQ                                                     
!                                                                       
      END                                           
!> \brief \b SLATRD reduces the first nb rows and columns of a symmetric
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SLATRD + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SLATRD( UPLO, N, NB, A, LDA, E, TAU, W, LDW )        
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          UPLO                                         
!       INTEGER            LDA, LDW, N, NB                              
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL               A( LDA, * ), E( * ), TAU( * ), W( LDW, * )   
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SLATRD reduces NB rows and columns of a real symmetric matrix A to   
!> symmetric tridiagonal form by an orthogonal similarity               
!> transformation Q**T * A * Q, and returns the matrices V and W which a
!> needed to apply the transformation to the unreduced part of A.       
!>                                                                      
!> If UPLO = 'U', SLATRD reduces the last NB rows and columns of a      
!> matrix, of which the upper triangle is supplied;                     
!> if UPLO = 'L', SLATRD reduces the first NB rows and columns of a     
!> matrix, of which the lower triangle is supplied.                     
!>                                                                      
!> This is an auxiliary routine called by SSYTRD.                       
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] UPLO                                                      
!> \verbatim                                                            
!>          UPLO is CHARACTER*1                                         
!>          Specifies whether the upper or lower triangular part of the 
!>          symmetric matrix A is stored:                               
!>          = 'U': Upper triangular                                     
!>          = 'L': Lower triangular                                     
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix A.                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] NB                                                        
!> \verbatim                                                            
!>          NB is INTEGER                                               
!>          The number of rows and columns to be reduced.               
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] A                                                     
!> \verbatim                                                            
!>          A is REAL array, dimension (LDA,N)                          
!>          On entry, the symmetric matrix A.  If UPLO = 'U', the leadin
!>          n-by-n upper triangular part of A contains the upper        
!>          triangular part of the matrix A, and the strictly lower     
!>          triangular part of A is not referenced.  If UPLO = 'L', the 
!>          leading n-by-n lower triangular part of A contains the lower
!>          triangular part of the matrix A, and the strictly upper     
!>          triangular part of A is not referenced.                     
!>          On exit:                                                    
!>          if UPLO = 'U', the last NB columns have been reduced to     
!>            tridiagonal form, with the diagonal elements overwriting  
!>            the diagonal elements of A; the elements above the diagona
!>            with the array TAU, represent the orthogonal matrix Q as a
!>            product of elementary reflectors;                         
!>          if UPLO = 'L', the first NB columns have been reduced to    
!>            tridiagonal form, with the diagonal elements overwriting  
!>            the diagonal elements of A; the elements below the diagona
!>            with the array TAU, represent the  orthogonal matrix Q as 
!>            product of elementary reflectors.                         
!>          See Further Details.                                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>          The leading dimension of the array A.  LDA >= (1,N).        
!> \endverbatim                                                         
!>                                                                      
!> \param[out] E                                                        
!> \verbatim                                                            
!>          E is REAL array, dimension (N-1)                            
!>          If UPLO = 'U', E(n-nb:n-1) contains the superdiagonal       
!>          elements of the last NB columns of the reduced matrix;      
!>          if UPLO = 'L', E(1:nb) contains the subdiagonal elements of 
!>          the first NB columns of the reduced matrix.                 
!> \endverbatim                                                         
!>                                                                      
!> \param[out] TAU                                                      
!> \verbatim                                                            
!>          TAU is REAL array, dimension (N-1)                          
!>          The scalar factors of the elementary reflectors, stored in  
!>          TAU(n-nb:n-1) if UPLO = 'U', and in TAU(1:nb) if UPLO = 'L'.
!>          See Further Details.                                        
!> \endverbatim                                                         
!>                                                                      
!> \param[out] W                                                        
!> \verbatim                                                            
!>          W is REAL array, dimension (LDW,NB)                         
!>          The n-by-nb matrix W required to update the unreduced part  
!>          of A.                                                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDW                                                       
!> \verbatim                                                            
!>          LDW is INTEGER                                              
!>          The leading dimension of the array W. LDW >= max(1,N).      
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup doubleOTHERauxiliary                                        
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  If UPLO = 'U', the matrix Q is represented as a product of elementar
!>  reflectors                                                          
!>                                                                      
!>     Q = H(n) H(n-1) . . . H(n-nb+1).                                 
!>                                                                      
!>  Each H(i) has the form                                              
!>                                                                      
!>     H(i) = I - tau * v * v**T                                        
!>                                                                      
!>  where tau is a real scalar, and v is a real vector with             
!>  v(i:n) = 0 and v(i-1) = 1; v(1:i-1) is stored on exit in A(1:i-1,i),
!>  and tau in TAU(i-1).                                                
!>                                                                      
!>  If UPLO = 'L', the matrix Q is represented as a product of elementar
!>  reflectors                                                          
!>                                                                      
!>     Q = H(1) H(2) . . . H(nb).                                       
!>                                                                      
!>  Each H(i) has the form                                              
!>                                                                      
!>     H(i) = I - tau * v * v**T                                        
!>                                                                      
!>  where tau is a real scalar, and v is a real vector with             
!>  v(1:i) = 0 and v(i+1) = 1; v(i+1:n) is stored on exit in A(i+1:n,i),
!>  and tau in TAU(i).                                                  
!>                                                                      
!>  The elements of the vectors v together form the n-by-nb matrix V    
!>  which is needed, with W, to apply the transformation to the unreduce
!>  part of the matrix, using a symmetric rank-2k update of the form:   
!>  A := A - V*W**T - W*V**T.                                           
!>                                                                      
!>  The contents of A on exit are illustrated by the following examples 
!>  with n = 5 and nb = 2:                                              
!>                                                                      
!>  if UPLO = 'U':                       if UPLO = 'L':                 
!>                                                                      
!>    (  a   a   a   v4  v5 )              (  d                  )      
!>    (      a   a   v4  v5 )              (  1   d              )      
!>    (          a   1   v5 )              (  v1  1   a          )      
!>    (              d   1  )              (  v1  v2  a   a      )      
!>    (                  d  )              (  v1  v2  a   a   a  )      
!>                                                                      
!>  where d denotes a diagonal element of the reduced matrix, a denotes 
!>  an element of the original matrix that is unchanged, and vi denotes 
!>  an element of the vector defining H(i).                             
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE SLATRD( UPLO, N, NB, A, LDA, E, TAU, W, LDW ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          UPLO 
      INTEGER            LDA, LDW, N, NB 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               A( LDA, * ), E( * ), TAU( * ), W( LDW, * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ZERO, ONE, HALF 
      PARAMETER          ( ZERO = 0.0E+0, ONE = 1.0E+0, HALF = 0.5E+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I, IW 
      REAL               ALPHA 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           SAXPY, SGEMV, SLARFG, SSCAL, SSYMV 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      REAL               SDOT 
      EXTERNAL           LSAME, SDOT 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MIN 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.LE.0 )                                                      &
     &   RETURN                                                         
!                                                                       
      IF( LSAME( UPLO, 'U' ) ) THEN 
!                                                                       
!        Reduce last NB columns of upper triangle                       
!                                                                       
         DO 10 I = N, N - NB + 1, -1 
            IW = I - N + NB 
            IF( I.LT.N ) THEN 
!                                                                       
!              Update A(1:i,i)                                          
!                                                                       
               CALL SGEMV( 'No transpose', I, N-I, -ONE, A( 1, I+1 ),   &
     &                     LDA, W( I, IW+1 ), LDW, ONE, A( 1, I ), 1 )  
               CALL SGEMV( 'No transpose', I, N-I, -ONE, W( 1, IW+1 ),  &
     &                     LDW, A( I, I+1 ), LDA, ONE, A( 1, I ), 1 )   
            END IF 
            IF( I.GT.1 ) THEN 
!                                                                       
!              Generate elementary reflector H(i) to annihilate         
!              A(1:i-2,i)                                               
!                                                                       
               CALL SLARFG( I-1, A( I-1, I ), A( 1, I ), 1, TAU( I-1 ) ) 
               E( I-1 ) = A( I-1, I ) 
               A( I-1, I ) = ONE 
!                                                                       
!              Compute W(1:i-1,i)                                       
!                                                                       
               CALL SSYMV( 'Upper', I-1, ONE, A, LDA, A( 1, I ), 1,     &
     &                     ZERO, W( 1, IW ), 1 )                        
               IF( I.LT.N ) THEN 
                  CALL SGEMV( 'Transpose', I-1, N-I, ONE, W( 1, IW+1 ), &
     &                        LDW, A( 1, I ), 1, ZERO, W( I+1, IW ), 1 )
                  CALL SGEMV( 'No transpose', I-1, N-I, -ONE,           &
     &                        A( 1, I+1 ), LDA, W( I+1, IW ), 1, ONE,   &
     &                        W( 1, IW ), 1 )                           
                  CALL SGEMV( 'Transpose', I-1, N-I, ONE, A( 1, I+1 ),  &
     &                        LDA, A( 1, I ), 1, ZERO, W( I+1, IW ), 1 )
                  CALL SGEMV( 'No transpose', I-1, N-I, -ONE,           &
     &                        W( 1, IW+1 ), LDW, W( I+1, IW ), 1, ONE,  &
     &                        W( 1, IW ), 1 )                           
               END IF 
               CALL SSCAL( I-1, TAU( I-1 ), W( 1, IW ), 1 ) 
               ALPHA = -HALF*TAU( I-1 )*SDOT( I-1, W( 1, IW ), 1,       &
     &                 A( 1, I ), 1 )                                   
               CALL SAXPY( I-1, ALPHA, A( 1, I ), 1, W( 1, IW ), 1 ) 
            END IF 
!                                                                       
   10    CONTINUE 
      ELSE 
!                                                                       
!        Reduce first NB columns of lower triangle                      
!                                                                       
         DO 20 I = 1, NB 
!                                                                       
!           Update A(i:n,i)                                             
!                                                                       
            CALL SGEMV( 'No transpose', N-I+1, I-1, -ONE, A( I, 1 ),    &
     &                  LDA, W( I, 1 ), LDW, ONE, A( I, I ), 1 )        
            CALL SGEMV( 'No transpose', N-I+1, I-1, -ONE, W( I, 1 ),    &
     &                  LDW, A( I, 1 ), LDA, ONE, A( I, I ), 1 )        
            IF( I.LT.N ) THEN 
!                                                                       
!              Generate elementary reflector H(i) to annihilate         
!              A(i+2:n,i)                                               
!                                                                       
               CALL SLARFG( N-I, A( I+1, I ), A( MIN( I+2, N ), I ), 1, &
     &                      TAU( I ) )                                  
               E( I ) = A( I+1, I ) 
               A( I+1, I ) = ONE 
!                                                                       
!              Compute W(i+1:n,i)                                       
!                                                                       
               CALL SSYMV( 'Lower', N-I, ONE, A( I+1, I+1 ), LDA,       &
     &                     A( I+1, I ), 1, ZERO, W( I+1, I ), 1 )       
               CALL SGEMV( 'Transpose', N-I, I-1, ONE, W( I+1, 1 ), LDW,&
     &                     A( I+1, I ), 1, ZERO, W( 1, I ), 1 )         
               CALL SGEMV( 'No transpose', N-I, I-1, -ONE, A( I+1, 1 ), &
     &                     LDA, W( 1, I ), 1, ONE, W( I+1, I ), 1 )     
               CALL SGEMV( 'Transpose', N-I, I-1, ONE, A( I+1, 1 ), LDA,&
     &                     A( I+1, I ), 1, ZERO, W( 1, I ), 1 )         
               CALL SGEMV( 'No transpose', N-I, I-1, -ONE, W( I+1, 1 ), &
     &                     LDW, W( 1, I ), 1, ONE, W( I+1, I ), 1 )     
               CALL SSCAL( N-I, TAU( I ), W( I+1, I ), 1 ) 
               ALPHA = -HALF*TAU( I )*SDOT( N-I, W( I+1, I ), 1,        &
     &                 A( I+1, I ), 1 )                                 
               CALL SAXPY( N-I, ALPHA, A( I+1, I ), 1, W( I+1, I ), 1 ) 
            END IF 
!                                                                       
   20    CONTINUE 
      END IF 
!                                                                       
      RETURN 
!                                                                       
!     End of SLATRD                                                     
!                                                                       
      END                                           
!> \brief \b SNRM2                                                      
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       REAL FUNCTION SNRM2(N,X,INCX)                                   
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER INCX,N                                                  
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL X(*)                                                       
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SNRM2 returns the euclidean norm of a vector via the function        
!> name, so that                                                        
!>                                                                      
!>    SNRM2 := sqrt( x'*x ).                                            
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>         number of elements in input vector(s)                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] X                                                         
!> \verbatim                                                            
!>          X is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) )    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCX                                                      
!> \verbatim                                                            
!>          INCX is INTEGER                                             
!>         storage spacing between elements of SX                       
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date November 2017                                                  
!                                                                       
!> \ingroup single_blas_level1                                          
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  -- This version written on 25-October-1982.                         
!>     Modified on 14-October-1993 to inline the call to SLASSQ.        
!>     Sven Hammarling, Nag Ltd.                                        
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      REAL FUNCTION SNRM2(N,X,INCX) 
!                                                                       
!  -- Reference BLAS level1 routine (version 3.8.0) --                  
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     November 2017                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER INCX,N 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL X(*) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL ONE,ZERO 
      PARAMETER (ONE=1.0E+0,ZERO=0.0E+0) 
!     ..                                                                
!     .. Local Scalars ..                                               
      REAL ABSXI,NORM,SCALE,SSQ 
      INTEGER IX 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC ABS,SQRT 
!     ..                                                                
      IF (N.LT.1 .OR. INCX.LT.1) THEN 
          NORM = ZERO 
      ELSE IF (N.EQ.1) THEN 
          NORM = ABS(X(1)) 
      ELSE 
          SCALE = ZERO 
          SSQ = ONE 
!        The following loop is equivalent to this call to the LAPACK    
!        auxiliary routine:                                             
!        CALL SLASSQ( N, X, INCX, SCALE, SSQ )                          
!                                                                       
          DO 10 IX = 1,1 + (N-1)*INCX,INCX 
              IF (X(IX).NE.ZERO) THEN 
                  ABSXI = ABS(X(IX)) 
                  IF (SCALE.LT.ABSXI) THEN 
                      SSQ = ONE + SSQ* (SCALE/ABSXI)**2 
                      SCALE = ABSXI 
                  ELSE 
                      SSQ = SSQ + (ABSXI/SCALE)**2 
                  END IF 
              END IF 
   10     CONTINUE 
          NORM = SCALE*SQRT(SSQ) 
      END IF 
!                                                                       
      SNRM2 = NORM 
      RETURN 
!                                                                       
!     End of SNRM2.                                                     
!                                                                       
      END                                           
!> \brief \b SORM2L multiplies a general matrix by the orthogonal matrix
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SORM2L + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SORM2L( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,   
!                          WORK, INFO )                                 
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          SIDE, TRANS                                  
!       INTEGER            INFO, K, LDA, LDC, M, N                      
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL               A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SORM2L overwrites the general real m by n matrix C with              
!>                                                                      
!>       Q * C  if SIDE = 'L' and TRANS = 'N', or                       
!>                                                                      
!>       Q**T * C  if SIDE = 'L' and TRANS = 'T', or                    
!>                                                                      
!>       C * Q  if SIDE = 'R' and TRANS = 'N', or                       
!>                                                                      
!>       C * Q**T if SIDE = 'R' and TRANS = 'T',                        
!>                                                                      
!> where Q is a real orthogonal matrix defined as the product of k      
!> elementary reflectors                                                
!>                                                                      
!>       Q = H(k) . . . H(2) H(1)                                       
!>                                                                      
!> as returned by SGEQLF. Q is of order m if SIDE = 'L' and of order n  
!> if SIDE = 'R'.                                                       
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] SIDE                                                      
!> \verbatim                                                            
!>          SIDE is CHARACTER*1                                         
!>          = 'L': apply Q or Q**T from the Left                        
!>          = 'R': apply Q or Q**T from the Right                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TRANS                                                     
!> \verbatim                                                            
!>          TRANS is CHARACTER*1                                        
!>          = 'N': apply Q  (No transpose)                              
!>          = 'T': apply Q**T (Transpose)                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The number of rows of the matrix C. M >= 0.                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The number of columns of the matrix C. N >= 0.              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] K                                                         
!> \verbatim                                                            
!>          K is INTEGER                                                
!>          The number of elementary reflectors whose product defines   
!>          the matrix Q.                                               
!>          If SIDE = 'L', M >= K >= 0;                                 
!>          if SIDE = 'R', N >= K >= 0.                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is REAL array, dimension (LDA,K)                          
!>          The i-th column must contain the vector which defines the   
!>          elementary reflector H(i), for i = 1,2,...,k, as returned by
!>          SGEQLF in the last k columns of its array argument A.       
!>          A is modified by the routine but restored on exit.          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>          The leading dimension of the array A.                       
!>          If SIDE = 'L', LDA >= max(1,M);                             
!>          if SIDE = 'R', LDA >= max(1,N).                             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TAU                                                       
!> \verbatim                                                            
!>          TAU is REAL array, dimension (K)                            
!>          TAU(i) must contain the scalar factor of the elementary     
!>          reflector H(i), as returned by SGEQLF.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] C                                                     
!> \verbatim                                                            
!>          C is REAL array, dimension (LDC,N)                          
!>          On entry, the m by n matrix C.                              
!>          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDC                                                       
!> \verbatim                                                            
!>          LDC is INTEGER                                              
!>          The leading dimension of the array C. LDC >= max(1,M).      
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is REAL array, dimension                               
!>                                   (N) if SIDE = 'L',                 
!>                                   (M) if SIDE = 'R'                  
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0: successful exit                                        
!>          < 0: if INFO = -i, the i-th argument had an illegal value   
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup realOTHERcomputational                                      
!                                                                       
!  =====================================================================
      SUBROUTINE SORM2L( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,     &
     &                   WORK, INFO )                                   
!                                                                       
!  -- LAPACK computational routine (version 3.7.0) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          SIDE, TRANS 
      INTEGER            INFO, K, LDA, LDC, M, N 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ONE 
      PARAMETER          ( ONE = 1.0E+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            LEFT, NOTRAN 
      INTEGER            I, I1, I2, I3, MI, NI, NQ 
      REAL               AII 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      EXTERNAL           LSAME 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           SLARF, XERBLA 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input arguments                                          
!                                                                       
      INFO = 0 
      LEFT = LSAME( SIDE, 'L' ) 
      NOTRAN = LSAME( TRANS, 'N' ) 
!                                                                       
!     NQ is the order of Q                                              
!                                                                       
      IF( LEFT ) THEN 
         NQ = M 
      ELSE 
         NQ = N 
      END IF 
      IF( .NOT.LEFT .AND. .NOT.LSAME( SIDE, 'R' ) ) THEN 
         INFO = -1 
      ELSE IF( .NOT.NOTRAN .AND. .NOT.LSAME( TRANS, 'T' ) ) THEN 
         INFO = -2 
      ELSE IF( M.LT.0 ) THEN 
         INFO = -3 
      ELSE IF( N.LT.0 ) THEN 
         INFO = -4 
      ELSE IF( K.LT.0 .OR. K.GT.NQ ) THEN 
         INFO = -5 
      ELSE IF( LDA.LT.MAX( 1, NQ ) ) THEN 
         INFO = -7 
      ELSE IF( LDC.LT.MAX( 1, M ) ) THEN 
         INFO = -10 
      END IF 
      IF( INFO.NE.0 ) THEN 
         CALL XERBLA( 'SORM2L', -INFO ) 
         RETURN 
      END IF 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( M.EQ.0 .OR. N.EQ.0 .OR. K.EQ.0 )                              &
     &   RETURN                                                         
!                                                                       
      IF( ( LEFT .AND. NOTRAN ) .OR. ( .NOT.LEFT .AND. .NOT.NOTRAN ) )  &
     &     THEN                                                         
         I1 = 1 
         I2 = K 
         I3 = 1 
      ELSE 
         I1 = K 
         I2 = 1 
         I3 = -1 
      END IF 
!                                                                       
      IF( LEFT ) THEN 
         NI = N 
      ELSE 
         MI = M 
      END IF 
!                                                                       
      DO 10 I = I1, I2, I3 
         IF( LEFT ) THEN 
!                                                                       
!           H(i) is applied to C(1:m-k+i,1:n)                           
!                                                                       
            MI = M - K + I 
         ELSE 
!                                                                       
!           H(i) is applied to C(1:m,1:n-k+i)                           
!                                                                       
            NI = N - K + I 
         END IF 
!                                                                       
!        Apply H(i)                                                     
!                                                                       
         AII = A( NQ-K+I, I ) 
         A( NQ-K+I, I ) = ONE 
         CALL SLARF( SIDE, MI, NI, A( 1, I ), 1, TAU( I ), C, LDC,      &
     &               WORK )                                             
         A( NQ-K+I, I ) = AII 
   10 END DO 
      RETURN 
!                                                                       
!     End of SORM2L                                                     
!                                                                       
      END                                           
!> \brief \b SORM2R multiplies a general matrix by the orthogonal matrix
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SORM2R + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SORM2R( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,   
!                          WORK, INFO )                                 
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          SIDE, TRANS                                  
!       INTEGER            INFO, K, LDA, LDC, M, N                      
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL               A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SORM2R overwrites the general real m by n matrix C with              
!>                                                                      
!>       Q * C  if SIDE = 'L' and TRANS = 'N', or                       
!>                                                                      
!>       Q**T* C  if SIDE = 'L' and TRANS = 'T', or                     
!>                                                                      
!>       C * Q  if SIDE = 'R' and TRANS = 'N', or                       
!>                                                                      
!>       C * Q**T if SIDE = 'R' and TRANS = 'T',                        
!>                                                                      
!> where Q is a real orthogonal matrix defined as the product of k      
!> elementary reflectors                                                
!>                                                                      
!>       Q = H(1) H(2) . . . H(k)                                       
!>                                                                      
!> as returned by SGEQRF. Q is of order m if SIDE = 'L' and of order n  
!> if SIDE = 'R'.                                                       
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] SIDE                                                      
!> \verbatim                                                            
!>          SIDE is CHARACTER*1                                         
!>          = 'L': apply Q or Q**T from the Left                        
!>          = 'R': apply Q or Q**T from the Right                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TRANS                                                     
!> \verbatim                                                            
!>          TRANS is CHARACTER*1                                        
!>          = 'N': apply Q  (No transpose)                              
!>          = 'T': apply Q**T (Transpose)                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The number of rows of the matrix C. M >= 0.                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The number of columns of the matrix C. N >= 0.              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] K                                                         
!> \verbatim                                                            
!>          K is INTEGER                                                
!>          The number of elementary reflectors whose product defines   
!>          the matrix Q.                                               
!>          If SIDE = 'L', M >= K >= 0;                                 
!>          if SIDE = 'R', N >= K >= 0.                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is REAL array, dimension (LDA,K)                          
!>          The i-th column must contain the vector which defines the   
!>          elementary reflector H(i), for i = 1,2,...,k, as returned by
!>          SGEQRF in the first k columns of its array argument A.      
!>          A is modified by the routine but restored on exit.          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>          The leading dimension of the array A.                       
!>          If SIDE = 'L', LDA >= max(1,M);                             
!>          if SIDE = 'R', LDA >= max(1,N).                             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TAU                                                       
!> \verbatim                                                            
!>          TAU is REAL array, dimension (K)                            
!>          TAU(i) must contain the scalar factor of the elementary     
!>          reflector H(i), as returned by SGEQRF.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] C                                                     
!> \verbatim                                                            
!>          C is REAL array, dimension (LDC,N)                          
!>          On entry, the m by n matrix C.                              
!>          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDC                                                       
!> \verbatim                                                            
!>          LDC is INTEGER                                              
!>          The leading dimension of the array C. LDC >= max(1,M).      
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is REAL array, dimension                               
!>                                   (N) if SIDE = 'L',                 
!>                                   (M) if SIDE = 'R'                  
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0: successful exit                                        
!>          < 0: if INFO = -i, the i-th argument had an illegal value   
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup realOTHERcomputational                                      
!                                                                       
!  =====================================================================
      SUBROUTINE SORM2R( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,     &
     &                   WORK, INFO )                                   
!                                                                       
!  -- LAPACK computational routine (version 3.7.0) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          SIDE, TRANS 
      INTEGER            INFO, K, LDA, LDC, M, N 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ONE 
      PARAMETER          ( ONE = 1.0E+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            LEFT, NOTRAN 
      INTEGER            I, I1, I2, I3, IC, JC, MI, NI, NQ 
      REAL               AII 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      EXTERNAL           LSAME 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           SLARF, XERBLA 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input arguments                                          
!                                                                       
      INFO = 0 
      LEFT = LSAME( SIDE, 'L' ) 
      NOTRAN = LSAME( TRANS, 'N' ) 
!                                                                       
!     NQ is the order of Q                                              
!                                                                       
      IF( LEFT ) THEN 
         NQ = M 
      ELSE 
         NQ = N 
      END IF 
      IF( .NOT.LEFT .AND. .NOT.LSAME( SIDE, 'R' ) ) THEN 
         INFO = -1 
      ELSE IF( .NOT.NOTRAN .AND. .NOT.LSAME( TRANS, 'T' ) ) THEN 
         INFO = -2 
      ELSE IF( M.LT.0 ) THEN 
         INFO = -3 
      ELSE IF( N.LT.0 ) THEN 
         INFO = -4 
      ELSE IF( K.LT.0 .OR. K.GT.NQ ) THEN 
         INFO = -5 
      ELSE IF( LDA.LT.MAX( 1, NQ ) ) THEN 
         INFO = -7 
      ELSE IF( LDC.LT.MAX( 1, M ) ) THEN 
         INFO = -10 
      END IF 
      IF( INFO.NE.0 ) THEN 
         CALL XERBLA( 'SORM2R', -INFO ) 
         RETURN 
      END IF 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( M.EQ.0 .OR. N.EQ.0 .OR. K.EQ.0 )                              &
     &   RETURN                                                         
!                                                                       
      IF( ( LEFT .AND. .NOT.NOTRAN ) .OR. ( .NOT.LEFT .AND. NOTRAN ) )  &
     &     THEN                                                         
         I1 = 1 
         I2 = K 
         I3 = 1 
      ELSE 
         I1 = K 
         I2 = 1 
         I3 = -1 
      END IF 
!                                                                       
      IF( LEFT ) THEN 
         NI = N 
         JC = 1 
      ELSE 
         MI = M 
         IC = 1 
      END IF 
!                                                                       
      DO 10 I = I1, I2, I3 
         IF( LEFT ) THEN 
!                                                                       
!           H(i) is applied to C(i:m,1:n)                               
!                                                                       
            MI = M - I + 1 
            IC = I 
         ELSE 
!                                                                       
!           H(i) is applied to C(1:m,i:n)                               
!                                                                       
            NI = N - I + 1 
            JC = I 
         END IF 
!                                                                       
!        Apply H(i)                                                     
!                                                                       
         AII = A( I, I ) 
         A( I, I ) = ONE 
         CALL SLARF( SIDE, MI, NI, A( I, I ), 1, TAU( I ), C( IC, JC ), &
     &               LDC, WORK )                                        
         A( I, I ) = AII 
   10 END DO 
      RETURN 
!                                                                       
!     End of SORM2R                                                     
!                                                                       
      END                                           
!> \brief \b SORMQL                                                     
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SORMQL + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SORMQL( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,   
!                          WORK, LWORK, INFO )                          
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          SIDE, TRANS                                  
!       INTEGER            INFO, K, LDA, LDC, LWORK, M, N               
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL               A( LDA, * ), C( LDC, * ), TAU( * ),          
!      $                   WORK( * )                                    
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SORMQL overwrites the general real M-by-N matrix C with              
!>                                                                      
!>                 SIDE = 'L'     SIDE = 'R'                            
!> TRANS = 'N':      Q * C          C * Q                               
!> TRANS = 'T':      Q**T * C       C * Q**T                            
!>                                                                      
!> where Q is a real orthogonal matrix defined as the product of k      
!> elementary reflectors                                                
!>                                                                      
!>       Q = H(k) . . . H(2) H(1)                                       
!>                                                                      
!> as returned by SGEQLF. Q is of order M if SIDE = 'L' and of order N  
!> if SIDE = 'R'.                                                       
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] SIDE                                                      
!> \verbatim                                                            
!>          SIDE is CHARACTER*1                                         
!>          = 'L': apply Q or Q**T from the Left;                       
!>          = 'R': apply Q or Q**T from the Right.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TRANS                                                     
!> \verbatim                                                            
!>          TRANS is CHARACTER*1                                        
!>          = 'N':  No transpose, apply Q;                              
!>          = 'T':  Transpose, apply Q**T.                              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The number of rows of the matrix C. M >= 0.                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The number of columns of the matrix C. N >= 0.              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] K                                                         
!> \verbatim                                                            
!>          K is INTEGER                                                
!>          The number of elementary reflectors whose product defines   
!>          the matrix Q.                                               
!>          If SIDE = 'L', M >= K >= 0;                                 
!>          if SIDE = 'R', N >= K >= 0.                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is REAL array, dimension (LDA,K)                          
!>          The i-th column must contain the vector which defines the   
!>          elementary reflector H(i), for i = 1,2,...,k, as returned by
!>          SGEQLF in the last k columns of its array argument A.       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>          The leading dimension of the array A.                       
!>          If SIDE = 'L', LDA >= max(1,M);                             
!>          if SIDE = 'R', LDA >= max(1,N).                             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TAU                                                       
!> \verbatim                                                            
!>          TAU is REAL array, dimension (K)                            
!>          TAU(i) must contain the scalar factor of the elementary     
!>          reflector H(i), as returned by SGEQLF.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] C                                                     
!> \verbatim                                                            
!>          C is REAL array, dimension (LDC,N)                          
!>          On entry, the M-by-N matrix C.                              
!>          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDC                                                       
!> \verbatim                                                            
!>          LDC is INTEGER                                              
!>          The leading dimension of the array C. LDC >= max(1,M).      
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is REAL array, dimension (MAX(1,LWORK))                
!>          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LWORK                                                     
!> \verbatim                                                            
!>          LWORK is INTEGER                                            
!>          The dimension of the array WORK.                            
!>          If SIDE = 'L', LWORK >= max(1,N);                           
!>          if SIDE = 'R', LWORK >= max(1,M).                           
!>          For good performance, LWORK should generally be larger.     
!>                                                                      
!>          If LWORK = -1, then a workspace query is assumed; the routin
!>          only calculates the optimal size of the WORK array, returns 
!>          this value as the first entry of the WORK array, and no erro
!>          message related to LWORK is issued by XERBLA.               
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0:  successful exit                                       
!>          < 0:  if INFO = -i, the i-th argument had an illegal value  
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup realOTHERcomputational                                      
!                                                                       
!  =====================================================================
      SUBROUTINE SORMQL( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,     &
     &                   WORK, LWORK, INFO )                            
!                                                                       
!  -- LAPACK computational routine (version 3.7.0) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          SIDE, TRANS 
      INTEGER            INFO, K, LDA, LDC, LWORK, M, N 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               A( LDA, * ), C( LDC, * ), TAU( * ),            &
     &                   WORK( * )                                      
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      INTEGER            NBMAX, LDT, TSIZE 
      PARAMETER          ( NBMAX = 64, LDT = NBMAX+1,                   &
     &                     TSIZE = LDT*NBMAX )                          
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            LEFT, LQUERY, NOTRAN 
      INTEGER            I, I1, I2, I3, IB, IINFO, IWT, LDWORK, LWKOPT, &
     &                   MI, NB, NBMIN, NI, NQ, NW                      
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      INTEGER            ILAENV 
      EXTERNAL           LSAME, ILAENV 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           SLARFB, SLARFT, SORM2L, XERBLA 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX, MIN 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input arguments                                          
!                                                                       
      INFO = 0 
      LEFT = LSAME( SIDE, 'L' ) 
      NOTRAN = LSAME( TRANS, 'N' ) 
      LQUERY = ( LWORK.EQ.-1 ) 
!                                                                       
!     NQ is the order of Q and NW is the minimum dimension of WORK      
!                                                                       
      IF( LEFT ) THEN 
         NQ = M 
         NW = MAX( 1, N ) 
      ELSE 
         NQ = N 
         NW = MAX( 1, M ) 
      END IF 
      IF( .NOT.LEFT .AND. .NOT.LSAME( SIDE, 'R' ) ) THEN 
         INFO = -1 
      ELSE IF( .NOT.NOTRAN .AND. .NOT.LSAME( TRANS, 'T' ) ) THEN 
         INFO = -2 
      ELSE IF( M.LT.0 ) THEN 
         INFO = -3 
      ELSE IF( N.LT.0 ) THEN 
         INFO = -4 
      ELSE IF( K.LT.0 .OR. K.GT.NQ ) THEN 
         INFO = -5 
      ELSE IF( LDA.LT.MAX( 1, NQ ) ) THEN 
         INFO = -7 
      ELSE IF( LDC.LT.MAX( 1, M ) ) THEN 
         INFO = -10 
      ELSE IF( LWORK.LT.NW .AND. .NOT.LQUERY ) THEN 
         INFO = -12 
      END IF 
!                                                                       
      IF( INFO.EQ.0 ) THEN 
!                                                                       
!     Compute the workspace requirements                                
!                                                                       
         IF( M.EQ.0 .OR. N.EQ.0 ) THEN 
            LWKOPT = 1 
         ELSE 
            NB = MIN( NBMAX, ILAENV( 1, 'SORMQL', SIDE // TRANS, M, N,  &
     &                               K, -1 ) )                          
            LWKOPT = NW*NB + TSIZE 
         END IF 
         WORK( 1 ) = LWKOPT 
      END IF 
!                                                                       
      IF( INFO.NE.0 ) THEN 
         CALL XERBLA( 'SORMQL', -INFO ) 
         RETURN 
      ELSE IF( LQUERY ) THEN 
         RETURN 
      END IF 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( M.EQ.0 .OR. N.EQ.0 ) THEN 
         RETURN 
      END IF 
!                                                                       
      NBMIN = 2 
      LDWORK = NW 
      IF( NB.GT.1 .AND. NB.LT.K ) THEN 
         IF( LWORK.LT.NW*NB+TSIZE ) THEN 
            NB = (LWORK-TSIZE) / LDWORK 
            NBMIN = MAX( 2, ILAENV( 2, 'SORMQL', SIDE // TRANS, M, N, K,&
     &              -1 ) )                                              
         END IF 
      END IF 
!                                                                       
      IF( NB.LT.NBMIN .OR. NB.GE.K ) THEN 
!                                                                       
!        Use unblocked code                                             
!                                                                       
         CALL SORM2L( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC, WORK,  &
     &                IINFO )                                           
      ELSE 
!                                                                       
!        Use blocked code                                               
!                                                                       
         IWT = 1 + NW*NB 
         IF( ( LEFT .AND. NOTRAN ) .OR.                                 &
     &       ( .NOT.LEFT .AND. .NOT.NOTRAN ) ) THEN                     
            I1 = 1 
            I2 = K 
            I3 = NB 
         ELSE 
            I1 = ( ( K-1 ) / NB )*NB + 1 
            I2 = 1 
            I3 = -NB 
         END IF 
!                                                                       
         IF( LEFT ) THEN 
            NI = N 
         ELSE 
            MI = M 
         END IF 
!                                                                       
         DO 10 I = I1, I2, I3 
            IB = MIN( NB, K-I+1 ) 
!                                                                       
!           Form the triangular factor of the block reflector           
!           H = H(i+ib-1) . . . H(i+1) H(i)                             
!                                                                       
            CALL SLARFT( 'Backward', 'Columnwise', NQ-K+I+IB-1, IB,     &
     &                   A( 1, I ), LDA, TAU( I ), WORK( IWT ), LDT )   
            IF( LEFT ) THEN 
!                                                                       
!              H or H**T is applied to C(1:m-k+i+ib-1,1:n)              
!                                                                       
               MI = M - K + I + IB - 1 
            ELSE 
!                                                                       
!              H or H**T is applied to C(1:m,1:n-k+i+ib-1)              
!                                                                       
               NI = N - K + I + IB - 1 
            END IF 
!                                                                       
!           Apply H or H**T                                             
!                                                                       
            CALL SLARFB( SIDE, TRANS, 'Backward', 'Columnwise', MI, NI, &
     &                   IB, A( 1, I ), LDA, WORK( IWT ), LDT, C, LDC,  &
     &                   WORK, LDWORK )                                 
   10    CONTINUE 
      END IF 
      WORK( 1 ) = LWKOPT 
      RETURN 
!                                                                       
!     End of SORMQL                                                     
!                                                                       
      END                                           
!> \brief \b SORMQR                                                     
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SORMQR + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SORMQR( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,   
!                          WORK, LWORK, INFO )                          
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          SIDE, TRANS                                  
!       INTEGER            INFO, K, LDA, LDC, LWORK, M, N               
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL               A( LDA, * ), C( LDC, * ), TAU( * ),          
!      $                   WORK( * )                                    
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SORMQR overwrites the general real M-by-N matrix C with              
!>                                                                      
!>                 SIDE = 'L'     SIDE = 'R'                            
!> TRANS = 'N':      Q * C          C * Q                               
!> TRANS = 'T':      Q**T * C       C * Q**T                            
!>                                                                      
!> where Q is a real orthogonal matrix defined as the product of k      
!> elementary reflectors                                                
!>                                                                      
!>       Q = H(1) H(2) . . . H(k)                                       
!>                                                                      
!> as returned by SGEQRF. Q is of order M if SIDE = 'L' and of order N  
!> if SIDE = 'R'.                                                       
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] SIDE                                                      
!> \verbatim                                                            
!>          SIDE is CHARACTER*1                                         
!>          = 'L': apply Q or Q**T from the Left;                       
!>          = 'R': apply Q or Q**T from the Right.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TRANS                                                     
!> \verbatim                                                            
!>          TRANS is CHARACTER*1                                        
!>          = 'N':  No transpose, apply Q;                              
!>          = 'T':  Transpose, apply Q**T.                              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The number of rows of the matrix C. M >= 0.                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The number of columns of the matrix C. N >= 0.              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] K                                                         
!> \verbatim                                                            
!>          K is INTEGER                                                
!>          The number of elementary reflectors whose product defines   
!>          the matrix Q.                                               
!>          If SIDE = 'L', M >= K >= 0;                                 
!>          if SIDE = 'R', N >= K >= 0.                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is REAL array, dimension (LDA,K)                          
!>          The i-th column must contain the vector which defines the   
!>          elementary reflector H(i), for i = 1,2,...,k, as returned by
!>          SGEQRF in the first k columns of its array argument A.      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>          The leading dimension of the array A.                       
!>          If SIDE = 'L', LDA >= max(1,M);                             
!>          if SIDE = 'R', LDA >= max(1,N).                             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TAU                                                       
!> \verbatim                                                            
!>          TAU is REAL array, dimension (K)                            
!>          TAU(i) must contain the scalar factor of the elementary     
!>          reflector H(i), as returned by SGEQRF.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] C                                                     
!> \verbatim                                                            
!>          C is REAL array, dimension (LDC,N)                          
!>          On entry, the M-by-N matrix C.                              
!>          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDC                                                       
!> \verbatim                                                            
!>          LDC is INTEGER                                              
!>          The leading dimension of the array C. LDC >= max(1,M).      
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is REAL array, dimension (MAX(1,LWORK))                
!>          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LWORK                                                     
!> \verbatim                                                            
!>          LWORK is INTEGER                                            
!>          The dimension of the array WORK.                            
!>          If SIDE = 'L', LWORK >= max(1,N);                           
!>          if SIDE = 'R', LWORK >= max(1,M).                           
!>          For good performance, LWORK should generally be larger.     
!>                                                                      
!>          If LWORK = -1, then a workspace query is assumed; the routin
!>          only calculates the optimal size of the WORK array, returns 
!>          this value as the first entry of the WORK array, and no erro
!>          message related to LWORK is issued by XERBLA.               
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0:  successful exit                                       
!>          < 0:  if INFO = -i, the i-th argument had an illegal value  
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup realOTHERcomputational                                      
!                                                                       
!  =====================================================================
      SUBROUTINE SORMQR( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,     &
     &                   WORK, LWORK, INFO )                            
!                                                                       
!  -- LAPACK computational routine (version 3.7.0) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          SIDE, TRANS 
      INTEGER            INFO, K, LDA, LDC, LWORK, M, N 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               A( LDA, * ), C( LDC, * ), TAU( * ),            &
     &                   WORK( * )                                      
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      INTEGER            NBMAX, LDT, TSIZE 
      PARAMETER          ( NBMAX = 64, LDT = NBMAX+1,                   &
     &                     TSIZE = LDT*NBMAX )                          
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            LEFT, LQUERY, NOTRAN 
      INTEGER            I, I1, I2, I3, IB, IC, IINFO, IWT, JC, LDWORK, &
     &                   LWKOPT, MI, NB, NBMIN, NI, NQ, NW              
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      INTEGER            ILAENV 
      EXTERNAL           LSAME, ILAENV 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           SLARFB, SLARFT, SORM2R, XERBLA 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX, MIN 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input arguments                                          
!                                                                       
      INFO = 0 
      LEFT = LSAME( SIDE, 'L' ) 
      NOTRAN = LSAME( TRANS, 'N' ) 
      LQUERY = ( LWORK.EQ.-1 ) 
!                                                                       
!     NQ is the order of Q and NW is the minimum dimension of WORK      
!                                                                       
      IF( LEFT ) THEN 
         NQ = M 
         NW = N 
      ELSE 
         NQ = N 
         NW = M 
      END IF 
      IF( .NOT.LEFT .AND. .NOT.LSAME( SIDE, 'R' ) ) THEN 
         INFO = -1 
      ELSE IF( .NOT.NOTRAN .AND. .NOT.LSAME( TRANS, 'T' ) ) THEN 
         INFO = -2 
      ELSE IF( M.LT.0 ) THEN 
         INFO = -3 
      ELSE IF( N.LT.0 ) THEN 
         INFO = -4 
      ELSE IF( K.LT.0 .OR. K.GT.NQ ) THEN 
         INFO = -5 
      ELSE IF( LDA.LT.MAX( 1, NQ ) ) THEN 
         INFO = -7 
      ELSE IF( LDC.LT.MAX( 1, M ) ) THEN 
         INFO = -10 
      ELSE IF( LWORK.LT.MAX( 1, NW ) .AND. .NOT.LQUERY ) THEN 
         INFO = -12 
      END IF 
!                                                                       
      IF( INFO.EQ.0 ) THEN 
!                                                                       
!        Compute the workspace requirements                             
!                                                                       
         NB = MIN( NBMAX, ILAENV( 1, 'SORMQR', SIDE // TRANS, M, N, K,  &
     &        -1 ) )                                                    
         LWKOPT = MAX( 1, NW )*NB + TSIZE 
         WORK( 1 ) = LWKOPT 
      END IF 
!                                                                       
      IF( INFO.NE.0 ) THEN 
         CALL XERBLA( 'SORMQR', -INFO ) 
         RETURN 
      ELSE IF( LQUERY ) THEN 
         RETURN 
      END IF 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( M.EQ.0 .OR. N.EQ.0 .OR. K.EQ.0 ) THEN 
         WORK( 1 ) = 1 
         RETURN 
      END IF 
!                                                                       
      NBMIN = 2 
      LDWORK = NW 
      IF( NB.GT.1 .AND. NB.LT.K ) THEN 
         IF( LWORK.LT.NW*NB+TSIZE ) THEN 
            NB = (LWORK-TSIZE) / LDWORK 
            NBMIN = MAX( 2, ILAENV( 2, 'SORMQR', SIDE // TRANS, M, N, K,&
     &              -1 ) )                                              
         END IF 
      END IF 
!                                                                       
      IF( NB.LT.NBMIN .OR. NB.GE.K ) THEN 
!                                                                       
!        Use unblocked code                                             
!                                                                       
         CALL SORM2R( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC, WORK,  &
     &                IINFO )                                           
      ELSE 
!                                                                       
!        Use blocked code                                               
!                                                                       
         IWT = 1 + NW*NB 
         IF( ( LEFT .AND. .NOT.NOTRAN ) .OR.                            &
     &       ( .NOT.LEFT .AND. NOTRAN ) ) THEN                          
            I1 = 1 
            I2 = K 
            I3 = NB 
         ELSE 
            I1 = ( ( K-1 ) / NB )*NB + 1 
            I2 = 1 
            I3 = -NB 
         END IF 
!                                                                       
         IF( LEFT ) THEN 
            NI = N 
            JC = 1 
         ELSE 
            MI = M 
            IC = 1 
         END IF 
!                                                                       
         DO 10 I = I1, I2, I3 
            IB = MIN( NB, K-I+1 ) 
!                                                                       
!           Form the triangular factor of the block reflector           
!           H = H(i) H(i+1) . . . H(i+ib-1)                             
!                                                                       
            CALL SLARFT( 'Forward', 'Columnwise', NQ-I+1, IB, A( I, I ),&
     &                   LDA, TAU( I ), WORK( IWT ), LDT )              
            IF( LEFT ) THEN 
!                                                                       
!              H or H**T is applied to C(i:m,1:n)                       
!                                                                       
               MI = M - I + 1 
               IC = I 
            ELSE 
!                                                                       
!              H or H**T is applied to C(1:m,i:n)                       
!                                                                       
               NI = N - I + 1 
               JC = I 
            END IF 
!                                                                       
!           Apply H or H**T                                             
!                                                                       
            CALL SLARFB( SIDE, TRANS, 'Forward', 'Columnwise', MI, NI,  &
     &                   IB, A( I, I ), LDA, WORK( IWT ), LDT,          &
     &                   C( IC, JC ), LDC, WORK, LDWORK )               
   10    CONTINUE 
      END IF 
      WORK( 1 ) = LWKOPT 
      RETURN 
!                                                                       
!     End of SORMQR                                                     
!                                                                       
      END                                           
!> \brief \b SORMTR                                                     
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SORMTR + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SORMTR( SIDE, UPLO, TRANS, M, N, A, LDA, TAU, C, LDC,
!                          WORK, LWORK, INFO )                          
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          SIDE, TRANS, UPLO                            
!       INTEGER            INFO, LDA, LDC, LWORK, M, N                  
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL               A( LDA, * ), C( LDC, * ), TAU( * ),          
!      $                   WORK( * )                                    
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SORMTR overwrites the general real M-by-N matrix C with              
!>                                                                      
!>                 SIDE = 'L'     SIDE = 'R'                            
!> TRANS = 'N':      Q * C          C * Q                               
!> TRANS = 'T':      Q**T * C       C * Q**T                            
!>                                                                      
!> where Q is a real orthogonal matrix of order nq, with nq = m if      
!> SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of  
!> nq-1 elementary reflectors, as returned by SSYTRD:                   
!>                                                                      
!> if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);                          
!>                                                                      
!> if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).                          
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] SIDE                                                      
!> \verbatim                                                            
!>          SIDE is CHARACTER*1                                         
!>          = 'L': apply Q or Q**T from the Left;                       
!>          = 'R': apply Q or Q**T from the Right.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] UPLO                                                      
!> \verbatim                                                            
!>          UPLO is CHARACTER*1                                         
!>          = 'U': Upper triangle of A contains elementary reflectors   
!>                 from SSYTRD;                                         
!>          = 'L': Lower triangle of A contains elementary reflectors   
!>                 from SSYTRD.                                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TRANS                                                     
!> \verbatim                                                            
!>          TRANS is CHARACTER*1                                        
!>          = 'N':  No transpose, apply Q;                              
!>          = 'T':  Transpose, apply Q**T.                              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The number of rows of the matrix C. M >= 0.                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The number of columns of the matrix C. N >= 0.              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is REAL array, dimension                                  
!>                               (LDA,M) if SIDE = 'L'                  
!>                               (LDA,N) if SIDE = 'R'                  
!>          The vectors which define the elementary reflectors, as      
!>          returned by SSYTRD.                                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>          The leading dimension of the array A.                       
!>          LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TAU                                                       
!> \verbatim                                                            
!>          TAU is REAL array, dimension                                
!>                               (M-1) if SIDE = 'L'                    
!>                               (N-1) if SIDE = 'R'                    
!>          TAU(i) must contain the scalar factor of the elementary     
!>          reflector H(i), as returned by SSYTRD.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] C                                                     
!> \verbatim                                                            
!>          C is REAL array, dimension (LDC,N)                          
!>          On entry, the M-by-N matrix C.                              
!>          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDC                                                       
!> \verbatim                                                            
!>          LDC is INTEGER                                              
!>          The leading dimension of the array C. LDC >= max(1,M).      
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is REAL array, dimension (MAX(1,LWORK))                
!>          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LWORK                                                     
!> \verbatim                                                            
!>          LWORK is INTEGER                                            
!>          The dimension of the array WORK.                            
!>          If SIDE = 'L', LWORK >= max(1,N);                           
!>          if SIDE = 'R', LWORK >= max(1,M).                           
!>          For optimum performance LWORK >= N*NB if SIDE = 'L', and    
!>          LWORK >= M*NB if SIDE = 'R', where NB is the optimal        
!>          blocksize.                                                  
!>                                                                      
!>          If LWORK = -1, then a workspace query is assumed; the routin
!>          only calculates the optimal size of the WORK array, returns 
!>          this value as the first entry of the WORK array, and no erro
!>          message related to LWORK is issued by XERBLA.               
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0:  successful exit                                       
!>          < 0:  if INFO = -i, the i-th argument had an illegal value  
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup realOTHERcomputational                                      
!                                                                       
!  =====================================================================
      SUBROUTINE SORMTR( SIDE, UPLO, TRANS, M, N, A, LDA, TAU, C, LDC,  &
     &                   WORK, LWORK, INFO )                            
!                                                                       
!  -- LAPACK computational routine (version 3.7.0) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          SIDE, TRANS, UPLO 
      INTEGER            INFO, LDA, LDC, LWORK, M, N 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               A( LDA, * ), C( LDC, * ), TAU( * ),            &
     &                   WORK( * )                                      
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Local Scalars ..                                               
      LOGICAL            LEFT, LQUERY, UPPER 
      INTEGER            I1, I2, IINFO, LWKOPT, MI, NI, NB, NQ, NW 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      INTEGER            ILAENV 
      EXTERNAL           ILAENV, LSAME 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           SORMQL, SORMQR, XERBLA 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input arguments                                          
!                                                                       
      INFO = 0 
      LEFT = LSAME( SIDE, 'L' ) 
      UPPER = LSAME( UPLO, 'U' ) 
      LQUERY = ( LWORK.EQ.-1 ) 
!                                                                       
!     NQ is the order of Q and NW is the minimum dimension of WORK      
!                                                                       
      IF( LEFT ) THEN 
         NQ = M 
         NW = N 
      ELSE 
         NQ = N 
         NW = M 
      END IF 
      IF( .NOT.LEFT .AND. .NOT.LSAME( SIDE, 'R' ) ) THEN 
         INFO = -1 
      ELSE IF( .NOT.UPPER .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN 
         INFO = -2 
      ELSE IF( .NOT.LSAME( TRANS, 'N' ) .AND. .NOT.LSAME( TRANS, 'T' ) )&
     &          THEN                                                    
         INFO = -3 
      ELSE IF( M.LT.0 ) THEN 
         INFO = -4 
      ELSE IF( N.LT.0 ) THEN 
         INFO = -5 
      ELSE IF( LDA.LT.MAX( 1, NQ ) ) THEN 
         INFO = -7 
      ELSE IF( LDC.LT.MAX( 1, M ) ) THEN 
         INFO = -10 
      ELSE IF( LWORK.LT.MAX( 1, NW ) .AND. .NOT.LQUERY ) THEN 
         INFO = -12 
      END IF 
!                                                                       
      IF( INFO.EQ.0 ) THEN 
         IF( UPPER ) THEN 
            IF( LEFT ) THEN 
               NB = ILAENV( 1, 'SORMQL', SIDE // TRANS, M-1, N, M-1,    &
     &                      -1 )                                        
            ELSE 
               NB = ILAENV( 1, 'SORMQL', SIDE // TRANS, M, N-1, N-1,    &
     &                      -1 )                                        
            END IF 
         ELSE 
            IF( LEFT ) THEN 
               NB = ILAENV( 1, 'SORMQR', SIDE // TRANS, M-1, N, M-1,    &
     &                      -1 )                                        
            ELSE 
               NB = ILAENV( 1, 'SORMQR', SIDE // TRANS, M, N-1, N-1,    &
     &                      -1 )                                        
            END IF 
         END IF 
         LWKOPT = MAX( 1, NW )*NB 
         WORK( 1 ) = LWKOPT 
      END IF 
!                                                                       
      IF( INFO.NE.0 ) THEN 
         CALL XERBLA( 'SORMTR', -INFO ) 
         RETURN 
      ELSE IF( LQUERY ) THEN 
         RETURN 
      END IF 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( M.EQ.0 .OR. N.EQ.0 .OR. NQ.EQ.1 ) THEN 
         WORK( 1 ) = 1 
         RETURN 
      END IF 
!                                                                       
      IF( LEFT ) THEN 
         MI = M - 1 
         NI = N 
      ELSE 
         MI = M 
         NI = N - 1 
      END IF 
!                                                                       
      IF( UPPER ) THEN 
!                                                                       
!        Q was determined by a call to SSYTRD with UPLO = 'U'           
!                                                                       
         CALL SORMQL( SIDE, TRANS, MI, NI, NQ-1, A( 1, 2 ), LDA, TAU, C,&
     &                LDC, WORK, LWORK, IINFO )                         
      ELSE 
!                                                                       
!        Q was determined by a call to SSYTRD with UPLO = 'L'           
!                                                                       
         IF( LEFT ) THEN 
            I1 = 2 
            I2 = 1 
         ELSE 
            I1 = 1 
            I2 = 2 
         END IF 
         CALL SORMQR( SIDE, TRANS, MI, NI, NQ-1, A( 2, 1 ), LDA, TAU,   &
     &                C( I1, I2 ), LDC, WORK, LWORK, IINFO )            
      END IF 
      WORK( 1 ) = LWKOPT 
      RETURN 
!                                                                       
!     End of SORMTR                                                     
!                                                                       
      END                                           
!> \brief \b SSCAL                                                      
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SSCAL(N,SA,SX,INCX)                                  
!                                                                       
!       .. Scalar Arguments ..                                          
!       REAL SA                                                         
!       INTEGER INCX,N                                                  
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL SX(*)                                                      
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>    SSCAL scales a vector by a constant.                              
!>    uses unrolled loops for increment equal to 1.                     
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>         number of elements in input vector(s)                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] SA                                                        
!> \verbatim                                                            
!>          SA is REAL                                                  
!>           On entry, SA specifies the scalar alpha.                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] SX                                                    
!> \verbatim                                                            
!>          SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) )   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCX                                                      
!> \verbatim                                                            
!>          INCX is INTEGER                                             
!>         storage spacing between elements of SX                       
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date November 2017                                                  
!                                                                       
!> \ingroup single_blas_level1                                          
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>     jack dongarra, linpack, 3/11/78.                                 
!>     modified 3/93 to return if incx .le. 0.                          
!>     modified 12/3/93, array(1) declarations changed to array(*)      
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE SSCAL(N,SA,SX,INCX) 
!                                                                       
!  -- Reference BLAS level1 routine (version 3.8.0) --                  
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     November 2017                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      REAL SA 
      INTEGER INCX,N 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL SX(*) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Local Scalars ..                                               
      INTEGER I,M,MP1,NINCX 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC MOD 
!     ..                                                                
      IF (N.LE.0 .OR. INCX.LE.0) RETURN 
      IF (INCX.EQ.1) THEN 
!                                                                       
!        code for increment equal to 1                                  
!                                                                       
!                                                                       
!        clean-up loop                                                  
!                                                                       
         M = MOD(N,5) 
         IF (M.NE.0) THEN 
            DO I = 1,M 
               SX(I) = SA*SX(I) 
            END DO 
            IF (N.LT.5) RETURN 
         END IF 
         MP1 = M + 1 
         DO I = MP1,N,5 
            SX(I) = SA*SX(I) 
            SX(I+1) = SA*SX(I+1) 
            SX(I+2) = SA*SX(I+2) 
            SX(I+3) = SA*SX(I+3) 
            SX(I+4) = SA*SX(I+4) 
         END DO 
      ELSE 
!                                                                       
!        code for increment not equal to 1                              
!                                                                       
         NINCX = N*INCX 
         DO I = 1,NINCX,INCX 
            SX(I) = SA*SX(I) 
         END DO 
      END IF 
      RETURN 
!> \brief \b SSTEBZ                                                     
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SSTEBZ + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SSTEBZ( RANGE, ORDER, N, VL, VU, IL, IU, ABSTOL, D, E
!                          M, NSPLIT, W, IBLOCK, ISPLIT, WORK, IWORK,   
!                          INFO )                                       
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          ORDER, RANGE                                 
!       INTEGER            IL, INFO, IU, M, N, NSPLIT                   
!       REAL               ABSTOL, VL, VU                               
!       ..                                                              
!       .. Array Arguments ..                                           
!       INTEGER            IBLOCK( * ), ISPLIT( * ), IWORK( * )         
!       REAL               D( * ), E( * ), W( * ), WORK( * )            
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SSTEBZ computes the eigenvalues of a symmetric tridiagonal           
!> matrix T.  The user may ask for all eigenvalues, all eigenvalues     
!> in the half-open interval (VL, VU], or the IL-th through IU-th       
!> eigenvalues.                                                         
!>                                                                      
!> To avoid overflow, the matrix must be scaled so that its             
!> largest element is no greater than overflow**(1/2) * underflow**(1/4)
!> accuracy, it should not be much smaller than that.                   
!>                                                                      
!> See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal        
!> Matrix", Report CS41, Computer Science Dept., Stanford               
!> University, July 21, 1966.                                           
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] RANGE                                                     
!> \verbatim                                                            
!>          RANGE is CHARACTER*1                                        
!>          = 'A': ("All")   all eigenvalues will be found.             
!>          = 'V': ("Value") all eigenvalues in the half-open interval  
!>                           (VL, VU] will be found.                    
!>          = 'I': ("Index") the IL-th through IU-th eigenvalues (of the
!>                           entire matrix) will be found.              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ORDER                                                     
!> \verbatim                                                            
!>          ORDER is CHARACTER*1                                        
!>          = 'B': ("By Block") the eigenvalues will be grouped by      
!>                              split-off block (see IBLOCK, ISPLIT) and
!>                              ordered from smallest to largest within 
!>                              the block.                              
!>          = 'E': ("Entire matrix")                                    
!>                              the eigenvalues for the entire matrix   
!>                              will be ordered from smallest to        
!>                              largest.                                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the tridiagonal matrix T.  N >= 0.             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] VL                                                        
!> \verbatim                                                            
!>          VL is REAL                                                  
!>                                                                      
!>          If RANGE='V', the lower bound of the interval to            
!>          be searched for eigenvalues.  Eigenvalues less than or equal
!>          to VL, or greater than VU, will not be returned.  VL < VU.  
!>          Not referenced if RANGE = 'A' or 'I'.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] VU                                                        
!> \verbatim                                                            
!>          VU is REAL                                                  
!>                                                                      
!>          If RANGE='V', the upper bound of the interval to            
!>          be searched for eigenvalues.  Eigenvalues less than or equal
!>          to VL, or greater than VU, will not be returned.  VL < VU.  
!>          Not referenced if RANGE = 'A' or 'I'.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IL                                                        
!> \verbatim                                                            
!>          IL is INTEGER                                               
!>                                                                      
!>          If RANGE='I', the index of the                              
!>          smallest eigenvalue to be returned.                         
!>          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.   
!>          Not referenced if RANGE = 'A' or 'V'.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IU                                                        
!> \verbatim                                                            
!>          IU is INTEGER                                               
!>                                                                      
!>          If RANGE='I', the index of the                              
!>          largest eigenvalue to be returned.                          
!>          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.   
!>          Not referenced if RANGE = 'A' or 'V'.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ABSTOL                                                    
!> \verbatim                                                            
!>          ABSTOL is REAL                                              
!>          The absolute tolerance for the eigenvalues.  An eigenvalue  
!>          (or cluster) is considered to be located if it has been     
!>          determined to lie in an interval whose width is ABSTOL or   
!>          less.  If ABSTOL is less than or equal to zero, then ULP*|T|
!>          will be used, where |T| means the 1-norm of T.              
!>                                                                      
!>          Eigenvalues will be computed most accurately when ABSTOL is 
!>          set to twice the underflow threshold 2*SLAMCH('S'), not zero
!> \endverbatim                                                         
!>                                                                      
!> \param[in] D                                                         
!> \verbatim                                                            
!>          D is REAL array, dimension (N)                              
!>          The n diagonal elements of the tridiagonal matrix T.        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] E                                                         
!> \verbatim                                                            
!>          E is REAL array, dimension (N-1)                            
!>          The (n-1) off-diagonal elements of the tridiagonal matrix T.
!> \endverbatim                                                         
!>                                                                      
!> \param[out] M                                                        
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The actual number of eigenvalues found. 0 <= M <= N.        
!>          (See also the description of INFO=2,3.)                     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] NSPLIT                                                   
!> \verbatim                                                            
!>          NSPLIT is INTEGER                                           
!>          The number of diagonal blocks in the matrix T.              
!>          1 <= NSPLIT <= N.                                           
!> \endverbatim                                                         
!>                                                                      
!> \param[out] W                                                        
!> \verbatim                                                            
!>          W is REAL array, dimension (N)                              
!>          On exit, the first M elements of W will contain the         
!>          eigenvalues.  (SSTEBZ may use the remaining N-M elements as 
!>          workspace.)                                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[out] IBLOCK                                                   
!> \verbatim                                                            
!>          IBLOCK is INTEGER array, dimension (N)                      
!>          At each row/column j where E(j) is zero or small, the       
!>          matrix T is considered to split into a block diagonal       
!>          matrix.  On exit, if INFO = 0, IBLOCK(i) specifies to which 
!>          block (from 1 to the number of blocks) the eigenvalue W(i)  
!>          belongs.  (SSTEBZ may use the remaining N-M elements as     
!>          workspace.)                                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[out] ISPLIT                                                   
!> \verbatim                                                            
!>          ISPLIT is INTEGER array, dimension (N)                      
!>          The splitting points, at which T breaks up into submatrices.
!>          The first submatrix consists of rows/columns 1 to ISPLIT(1),
!>          the second of rows/columns ISPLIT(1)+1 through ISPLIT(2),   
!>          etc., and the NSPLIT-th consists of rows/columns            
!>          ISPLIT(NSPLIT-1)+1 through ISPLIT(NSPLIT)=N.                
!>          (Only the first NSPLIT elements will actually be used, but  
!>          since the user cannot know a priori what value NSPLIT will  
!>          have, N words must be reserved for ISPLIT.)                 
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is REAL array, dimension (4*N)                         
!> \endverbatim                                                         
      END                                           
!>                                                                      
!> \param[out] IWORK                                                    
!> \verbatim                                                            
!>          IWORK is INTEGER array, dimension (3*N)                     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0:  successful exit                                       
!>          < 0:  if INFO = -i, the i-th argument had an illegal value  
!>          > 0:  some or all of the eigenvalues failed to converge or  
!>                were not computed:                                    
!>                =1 or 3: Bisection failed to converge for some        
!>                        eigenvalues; these eigenvalues are flagged by 
!>                        negative block number.  The effect is that the
!>                        eigenvalues may not be as accurate as the     
!>                        absolute and relative tolerances.  This is    
!>                        generally caused by unexpectedly inaccurate   
!>                        arithmetic.                                   
!>                =2 or 3: RANGE='I' only: Not all of the eigenvalues   
!>                        IL:IU were found.                             
!>                        Effect: M < IU+1-IL                           
!>                        Cause:  non-monotonic arithmetic, causing the 
!>                                Sturm sequence to be non-monotonic.   
!>                        Cure:   recalculate, using RANGE='A', and pick
!>                                out eigenvalues IL:IU.  In some cases,
!>                                increasing the PARAMETER "FUDGE" may  
!>                                make things work.                     
!>                = 4:    RANGE='I', and the Gershgorin interval        
!>                        initially used was too small.  No eigenvalues 
!>                        were computed.                                
!>                        Probable cause: your machine has sloppy       
!>                                        floating-point arithmetic.    
!>                        Cure: Increase the PARAMETER "FUDGE",         
!>                              recompile, and try again.               
!> \endverbatim                                                         
!                                                                       
!> \par Internal Parameters:                                            
!  =========================                                            
!>                                                                      
!> \verbatim                                                            
!>  RELFAC  REAL, default = 2.0e0                                       
!>          The relative tolerance.  An interval (a,b] lies within      
!>          "relative tolerance" if  b-a < RELFAC*ulp*max(|a|,|b|),     
!>          where "ulp" is the machine precision (distance from 1 to    
!>          the next larger floating point number.)                     
!>                                                                      
!>  FUDGE   REAL, default = 2                                           
!>          A "fudge factor" to widen the Gershgorin intervals.  Ideally
!>          a value of 1 should work, but on machines with sloppy       
!>          arithmetic, this needs to be larger.  The default for       
!>          publicly released versions should be large enough to handle 
!>          the worst machine around.  Note that this has no effect     
!>          on accuracy of the solution.                                
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2016                                                      
!                                                                       
!> \ingroup auxOTHERcomputational                                       
!                                                                       
!  =====================================================================
      SUBROUTINE SSTEBZ( RANGE, ORDER, N, VL, VU, IL, IU, ABSTOL, D, E, &
     &                   M, NSPLIT, W, IBLOCK, ISPLIT, WORK, IWORK,     &
     &                   INFO )                                         
!                                                                       
!  -- LAPACK computational routine (version 3.7.0) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2016                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          ORDER, RANGE 
      INTEGER            IL, INFO, IU, M, N, NSPLIT 
      REAL               ABSTOL, VL, VU 
!     ..                                                                
!     .. Array Arguments ..                                             
      INTEGER            IBLOCK( * ), ISPLIT( * ), IWORK( * ) 
      REAL               D( * ), E( * ), W( * ), WORK( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ZERO, ONE, TWO, HALF 
      PARAMETER          ( ZERO = 0.0E0, ONE = 1.0E0, TWO = 2.0E0,      &
     &                   HALF = 1.0E0 / TWO )                           
      REAL               FUDGE, RELFAC 
      PARAMETER          ( FUDGE = 2.1E0, RELFAC = 2.0E0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            NCNVRG, TOOFEW 
      INTEGER            IB, IBEGIN, IDISCL, IDISCU, IE, IEND, IINFO,   &
     &                   IM, IN, IOFF, IORDER, IOUT, IRANGE, ITMAX,     &
     &                   ITMP1, IW, IWOFF, J, JB, JDISC, JE, NB, NWL,   &
     &                   NWU                                            
      REAL               ATOLI, BNORM, GL, GU, PIVMIN, RTOLI, SAFEMN,   &
     &                   TMP1, TMP2, TNORM, ULP, WKILL, WL, WLU, WU, WUL
!     ..                                                                
!     .. Local Arrays ..                                                
      INTEGER            IDUMMA( 1 ) 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      INTEGER            ILAENV 
      REAL               SLAMCH 
      EXTERNAL           LSAME, ILAENV, SLAMCH 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           SLAEBZ, XERBLA 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, INT, LOG, MAX, MIN, SQRT 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      INFO = 0 
!                                                                       
!     Decode RANGE                                                      
!                                                                       
      IF( LSAME( RANGE, 'A' ) ) THEN 
         IRANGE = 1 
      ELSE IF( LSAME( RANGE, 'V' ) ) THEN 
         IRANGE = 2 
      ELSE IF( LSAME( RANGE, 'I' ) ) THEN 
         IRANGE = 3 
      ELSE 
         IRANGE = 0 
      END IF 
!                                                                       
!     Decode ORDER                                                      
!                                                                       
      IF( LSAME( ORDER, 'B' ) ) THEN 
         IORDER = 2 
      ELSE IF( LSAME( ORDER, 'E' ) ) THEN 
         IORDER = 1 
      ELSE 
         IORDER = 0 
      END IF 
!                                                                       
!     Check for Errors                                                  
!                                                                       
      IF( IRANGE.LE.0 ) THEN 
         INFO = -1 
      ELSE IF( IORDER.LE.0 ) THEN 
         INFO = -2 
      ELSE IF( N.LT.0 ) THEN 
         INFO = -3 
      ELSE IF( IRANGE.EQ.2 ) THEN 
         IF( VL.GE.VU ) INFO = -5 
      ELSE IF( IRANGE.EQ.3 .AND. ( IL.LT.1 .OR. IL.GT.MAX( 1, N ) ) )   &
     &          THEN                                                    
         INFO = -6 
      ELSE IF( IRANGE.EQ.3 .AND. ( IU.LT.MIN( N, IL ) .OR. IU.GT.N ) )  &
     &          THEN                                                    
         INFO = -7 
      END IF 
!                                                                       
      IF( INFO.NE.0 ) THEN 
         CALL XERBLA( 'SSTEBZ', -INFO ) 
         RETURN 
      END IF 
!                                                                       
!     Initialize error flags                                            
!                                                                       
      INFO = 0 
      NCNVRG = .FALSE. 
      TOOFEW = .FALSE. 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      M = 0 
      IF( N.EQ.0 )                                                      &
     &   RETURN                                                         
!                                                                       
!     Simplifications:                                                  
!                                                                       
      IF( IRANGE.EQ.3 .AND. IL.EQ.1 .AND. IU.EQ.N )                     &
     &   IRANGE = 1                                                     
!                                                                       
!     Get machine constants                                             
!     NB is the minimum vector length for vector bisection, or 0        
!     if only scalar is to be done.                                     
!                                                                       
      SAFEMN = SLAMCH( 'S' ) 
      ULP = SLAMCH( 'P' ) 
      RTOLI = ULP*RELFAC 
      NB = ILAENV( 1, 'SSTEBZ', ' ', N, -1, -1, -1 ) 
      IF( NB.LE.1 )                                                     &
     &   NB = 0                                                         
!                                                                       
!     Special Case when N=1                                             
!                                                                       
      IF( N.EQ.1 ) THEN 
         NSPLIT = 1 
         ISPLIT( 1 ) = 1 
         IF( IRANGE.EQ.2 .AND. ( VL.GE.D( 1 ) .OR. VU.LT.D( 1 ) ) ) THEN 
            M = 0 
         ELSE 
            W( 1 ) = D( 1 ) 
            IBLOCK( 1 ) = 1 
            M = 1 
         END IF 
         RETURN 
      END IF 
!                                                                       
!     Compute Splitting Points                                          
!                                                                       
      NSPLIT = 1 
      WORK( N ) = ZERO 
      PIVMIN = ONE 
!                                                                       
      DO 10 J = 2, N 
         TMP1 = E( J-1 )**2 
         IF( ABS( D( J )*D( J-1 ) )*ULP**2+SAFEMN.GT.TMP1 ) THEN 
            ISPLIT( NSPLIT ) = J - 1 
            NSPLIT = NSPLIT + 1 
            WORK( J-1 ) = ZERO 
         ELSE 
            WORK( J-1 ) = TMP1 
            PIVMIN = MAX( PIVMIN, TMP1 ) 
         END IF 
   10 END DO 
      ISPLIT( NSPLIT ) = N 
      PIVMIN = PIVMIN*SAFEMN 
!                                                                       
!     Compute Interval and ATOLI                                        
!                                                                       
      IF( IRANGE.EQ.3 ) THEN 
!                                                                       
!        RANGE='I': Compute the interval containing eigenvalues         
!                   IL through IU.                                      
!                                                                       
!        Compute Gershgorin interval for entire (split) matrix          
!        and use it as the initial interval                             
!                                                                       
         GU = D( 1 ) 
         GL = D( 1 ) 
         TMP1 = ZERO 
!                                                                       
         DO 20 J = 1, N - 1 
            TMP2 = SQRT( WORK( J ) ) 
            GU = MAX( GU, D( J )+TMP1+TMP2 ) 
            GL = MIN( GL, D( J )-TMP1-TMP2 ) 
            TMP1 = TMP2 
   20    CONTINUE 
!                                                                       
         GU = MAX( GU, D( N )+TMP1 ) 
         GL = MIN( GL, D( N )-TMP1 ) 
         TNORM = MAX( ABS( GL ), ABS( GU ) ) 
         GL = GL - FUDGE*TNORM*ULP*N - FUDGE*TWO*PIVMIN 
         GU = GU + FUDGE*TNORM*ULP*N + FUDGE*PIVMIN 
!                                                                       
!        Compute Iteration parameters                                   
!                                                                       
         ITMAX = INT( ( LOG( TNORM+PIVMIN )-LOG( PIVMIN ) ) /           &
     &           LOG( TWO ) ) + 2                                       
         IF( ABSTOL.LE.ZERO ) THEN 
            ATOLI = ULP*TNORM 
         ELSE 
            ATOLI = ABSTOL 
         END IF 
!                                                                       
         WORK( N+1 ) = GL 
         WORK( N+2 ) = GL 
         WORK( N+3 ) = GU 
         WORK( N+4 ) = GU 
         WORK( N+5 ) = GL 
         WORK( N+6 ) = GU 
         IWORK( 1 ) = -1 
         IWORK( 2 ) = -1 
         IWORK( 3 ) = N + 1 
         IWORK( 4 ) = N + 1 
         IWORK( 5 ) = IL - 1 
         IWORK( 6 ) = IU 
!                                                                       
         CALL SLAEBZ( 3, ITMAX, N, 2, 2, NB, ATOLI, RTOLI, PIVMIN, D, E,&
     &                WORK, IWORK( 5 ), WORK( N+1 ), WORK( N+5 ), IOUT, &
     &                IWORK, W, IBLOCK, IINFO )                         
!                                                                       
         IF( IWORK( 6 ).EQ.IU ) THEN 
            WL = WORK( N+1 ) 
            WLU = WORK( N+3 ) 
            NWL = IWORK( 1 ) 
            WU = WORK( N+4 ) 
            WUL = WORK( N+2 ) 
            NWU = IWORK( 4 ) 
         ELSE 
            WL = WORK( N+2 ) 
            WLU = WORK( N+4 ) 
            NWL = IWORK( 2 ) 
            WU = WORK( N+3 ) 
            WUL = WORK( N+1 ) 
            NWU = IWORK( 3 ) 
         END IF 
!                                                                       
         IF( NWL.LT.0 .OR. NWL.GE.N .OR. NWU.LT.1 .OR. NWU.GT.N ) THEN 
            INFO = 4 
            RETURN 
         END IF 
      ELSE 
!                                                                       
!        RANGE='A' or 'V' -- Set ATOLI                                  
!                                                                       
         TNORM = MAX( ABS( D( 1 ) )+ABS( E( 1 ) ),                      &
     &           ABS( D( N ) )+ABS( E( N-1 ) ) )                        
!                                                                       
         DO 30 J = 2, N - 1 
            TNORM = MAX( TNORM, ABS( D( J ) )+ABS( E( J-1 ) )+          &
     &              ABS( E( J ) ) )                                     
   30    CONTINUE 
!                                                                       
         IF( ABSTOL.LE.ZERO ) THEN 
            ATOLI = ULP*TNORM 
         ELSE 
            ATOLI = ABSTOL 
         END IF 
!                                                                       
         IF( IRANGE.EQ.2 ) THEN 
            WL = VL 
            WU = VU 
         ELSE 
            WL = ZERO 
            WU = ZERO 
         END IF 
      END IF 
!                                                                       
!     Find Eigenvalues -- Loop Over Blocks and recompute NWL and NWU.   
!     NWL accumulates the number of eigenvalues .le. WL,                
!     NWU accumulates the number of eigenvalues .le. WU                 
!                                                                       
      M = 0 
      IEND = 0 
      INFO = 0 
      NWL = 0 
      NWU = 0 
!                                                                       
      DO 70 JB = 1, NSPLIT 
         IOFF = IEND 
         IBEGIN = IOFF + 1 
         IEND = ISPLIT( JB ) 
         IN = IEND - IOFF 
!                                                                       
         IF( IN.EQ.1 ) THEN 
!                                                                       
!           Special Case -- IN=1                                        
!                                                                       
            IF( IRANGE.EQ.1 .OR. WL.GE.D( IBEGIN )-PIVMIN )             &
     &         NWL = NWL + 1                                            
            IF( IRANGE.EQ.1 .OR. WU.GE.D( IBEGIN )-PIVMIN )             &
     &         NWU = NWU + 1                                            
            IF( IRANGE.EQ.1 .OR. ( WL.LT.D( IBEGIN )-PIVMIN .AND. WU.GE.&
     &          D( IBEGIN )-PIVMIN ) ) THEN                             
               M = M + 1 
               W( M ) = D( IBEGIN ) 
               IBLOCK( M ) = JB 
            END IF 
         ELSE 
!                                                                       
!           General Case -- IN > 1                                      
!                                                                       
!           Compute Gershgorin Interval                                 
!           and use it as the initial interval                          
!                                                                       
            GU = D( IBEGIN ) 
            GL = D( IBEGIN ) 
            TMP1 = ZERO 
!                                                                       
            DO 40 J = IBEGIN, IEND - 1 
               TMP2 = ABS( E( J ) ) 
               GU = MAX( GU, D( J )+TMP1+TMP2 ) 
               GL = MIN( GL, D( J )-TMP1-TMP2 ) 
               TMP1 = TMP2 
   40       CONTINUE 
!                                                                       
            GU = MAX( GU, D( IEND )+TMP1 ) 
            GL = MIN( GL, D( IEND )-TMP1 ) 
            BNORM = MAX( ABS( GL ), ABS( GU ) ) 
            GL = GL - FUDGE*BNORM*ULP*IN - FUDGE*PIVMIN 
            GU = GU + FUDGE*BNORM*ULP*IN + FUDGE*PIVMIN 
!                                                                       
!           Compute ATOLI for the current submatrix                     
!                                                                       
            IF( ABSTOL.LE.ZERO ) THEN 
               ATOLI = ULP*MAX( ABS( GL ), ABS( GU ) ) 
            ELSE 
               ATOLI = ABSTOL 
            END IF 
!                                                                       
            IF( IRANGE.GT.1 ) THEN 
               IF( GU.LT.WL ) THEN 
                  NWL = NWL + IN 
                  NWU = NWU + IN 
                  GO TO 70 
               END IF 
               GL = MAX( GL, WL ) 
               GU = MIN( GU, WU ) 
               IF( GL.GE.GU )                                           &
     &            GO TO 70                                              
            END IF 
!                                                                       
!           Set Up Initial Interval                                     
!                                                                       
            WORK( N+1 ) = GL 
            WORK( N+IN+1 ) = GU 
            CALL SLAEBZ( 1, 0, IN, IN, 1, NB, ATOLI, RTOLI, PIVMIN,     &
     &                   D( IBEGIN ), E( IBEGIN ), WORK( IBEGIN ),      &
     &                   IDUMMA, WORK( N+1 ), WORK( N+2*IN+1 ), IM,     &
     &                   IWORK, W( M+1 ), IBLOCK( M+1 ), IINFO )        
!                                                                       
            NWL = NWL + IWORK( 1 ) 
            NWU = NWU + IWORK( IN+1 ) 
            IWOFF = M - IWORK( 1 ) 
!                                                                       
!           Compute Eigenvalues                                         
!                                                                       
            ITMAX = INT( ( LOG( GU-GL+PIVMIN )-LOG( PIVMIN ) ) /        &
     &              LOG( TWO ) ) + 2                                    
            CALL SLAEBZ( 2, ITMAX, IN, IN, 1, NB, ATOLI, RTOLI, PIVMIN, &
     &                   D( IBEGIN ), E( IBEGIN ), WORK( IBEGIN ),      &
     &                   IDUMMA, WORK( N+1 ), WORK( N+2*IN+1 ), IOUT,   &
     &                   IWORK, W( M+1 ), IBLOCK( M+1 ), IINFO )        
!                                                                       
!           Copy Eigenvalues Into W and IBLOCK                          
!           Use -JB for block number for unconverged eigenvalues.       
!                                                                       
            DO 60 J = 1, IOUT 
               TMP1 = HALF*( WORK( J+N )+WORK( J+IN+N ) ) 
!                                                                       
!              Flag non-convergence.                                    
!                                                                       
               IF( J.GT.IOUT-IINFO ) THEN 
                  NCNVRG = .TRUE. 
                  IB = -JB 
               ELSE 
                  IB = JB 
               END IF 
               DO 50 JE = IWORK( J ) + 1 + IWOFF,                       &
     &                 IWORK( J+IN ) + IWOFF                            
                  W( JE ) = TMP1 
                  IBLOCK( JE ) = IB 
   50          CONTINUE 
   60       CONTINUE 
!                                                                       
            M = M + IM 
         END IF 
   70 END DO 
!                                                                       
!     If RANGE='I', then (WL,WU) contains eigenvalues NWL+1,...,NWU     
!     If NWL+1 < IL or NWU > IU, discard extra eigenvalues.             
!                                                                       
      IF( IRANGE.EQ.3 ) THEN 
         IM = 0 
         IDISCL = IL - 1 - NWL 
         IDISCU = NWU - IU 
!                                                                       
         IF( IDISCL.GT.0 .OR. IDISCU.GT.0 ) THEN 
            DO 80 JE = 1, M 
               IF( W( JE ).LE.WLU .AND. IDISCL.GT.0 ) THEN 
                  IDISCL = IDISCL - 1 
               ELSE IF( W( JE ).GE.WUL .AND. IDISCU.GT.0 ) THEN 
                  IDISCU = IDISCU - 1 
               ELSE 
                  IM = IM + 1 
                  W( IM ) = W( JE ) 
                  IBLOCK( IM ) = IBLOCK( JE ) 
               END IF 
   80       CONTINUE 
            M = IM 
         END IF 
         IF( IDISCL.GT.0 .OR. IDISCU.GT.0 ) THEN 
!                                                                       
!           Code to deal with effects of bad arithmetic:                
!           Some low eigenvalues to be discarded are not in (WL,WLU],   
!           or high eigenvalues to be discarded are not in (WUL,WU]     
!           so just kill off the smallest IDISCL/largest IDISCU         
!           eigenvalues, by simply finding the smallest/largest         
!           eigenvalue(s).                                              
!                                                                       
!           (If N(w) is monotone non-decreasing, this should never      
!               happen.)                                                
!                                                                       
            IF( IDISCL.GT.0 ) THEN 
               WKILL = WU 
               DO 100 JDISC = 1, IDISCL 
                  IW = 0 
                  DO 90 JE = 1, M 
                     IF( IBLOCK( JE ).NE.0 .AND.                        &
     &                   ( W( JE ).LT.WKILL .OR. IW.EQ.0 ) ) THEN       
                        IW = JE 
                        WKILL = W( JE ) 
                     END IF 
   90             CONTINUE 
                  IBLOCK( IW ) = 0 
  100          CONTINUE 
            END IF 
            IF( IDISCU.GT.0 ) THEN 
!                                                                       
               WKILL = WL 
               DO 120 JDISC = 1, IDISCU 
                  IW = 0 
                  DO 110 JE = 1, M 
                     IF( IBLOCK( JE ).NE.0 .AND.                        &
     &                   ( W( JE ).GT.WKILL .OR. IW.EQ.0 ) ) THEN       
                        IW = JE 
                        WKILL = W( JE ) 
                     END IF 
  110             CONTINUE 
                  IBLOCK( IW ) = 0 
  120          CONTINUE 
            END IF 
            IM = 0 
            DO 130 JE = 1, M 
               IF( IBLOCK( JE ).NE.0 ) THEN 
                  IM = IM + 1 
                  W( IM ) = W( JE ) 
                  IBLOCK( IM ) = IBLOCK( JE ) 
               END IF 
  130       CONTINUE 
            M = IM 
         END IF 
         IF( IDISCL.LT.0 .OR. IDISCU.LT.0 ) THEN 
            TOOFEW = .TRUE. 
         END IF 
      END IF 
!                                                                       
!     If ORDER='B', do nothing -- the eigenvalues are already sorted    
!        by block.                                                      
!     If ORDER='E', sort the eigenvalues from smallest to largest       
!                                                                       
      IF( IORDER.EQ.1 .AND. NSPLIT.GT.1 ) THEN 
         DO 150 JE = 1, M - 1 
            IE = 0 
            TMP1 = W( JE ) 
            DO 140 J = JE + 1, M 
               IF( W( J ).LT.TMP1 ) THEN 
                  IE = J 
                  TMP1 = W( J ) 
               END IF 
  140       CONTINUE 
!                                                                       
            IF( IE.NE.0 ) THEN 
               ITMP1 = IBLOCK( IE ) 
               W( IE ) = W( JE ) 
               IBLOCK( IE ) = IBLOCK( JE ) 
               W( JE ) = TMP1 
               IBLOCK( JE ) = ITMP1 
            END IF 
  150    CONTINUE 
      END IF 
!                                                                       
      INFO = 0 
      IF( NCNVRG )                                                      &
     &   INFO = INFO + 1                                                
      IF( TOOFEW )                                                      &
     &   INFO = INFO + 2                                                
      RETURN 
!                                                                       
!     End of SSTEBZ                                                     
!                                                                       
      END                                           
!> \brief \b SSTEIN                                                     
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SSTEIN + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SSTEIN( N, D, E, M, W, IBLOCK, ISPLIT, Z, LDZ, WORK, 
!                          IWORK, IFAIL, INFO )                         
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            INFO, LDZ, M, N                              
!       ..                                                              
!       .. Array Arguments ..                                           
!       INTEGER            IBLOCK( * ), IFAIL( * ), ISPLIT( * ),        
!      $                   IWORK( * )                                   
!       REAL               D( * ), E( * ), W( * ), WORK( * ), Z( LDZ, * 
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SSTEIN computes the eigenvectors of a real symmetric tridiagonal     
!> matrix T corresponding to specified eigenvalues, using inverse       
!> iteration.                                                           
!>                                                                      
!> The maximum number of iterations allowed for each eigenvector is     
!> specified by an internal parameter MAXITS (currently set to 5).      
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix.  N >= 0.                           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] D                                                         
!> \verbatim                                                            
!>          D is REAL array, dimension (N)                              
!>          The n diagonal elements of the tridiagonal matrix T.        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] E                                                         
!> \verbatim                                                            
!>          E is REAL array, dimension (N-1)                            
!>          The (n-1) subdiagonal elements of the tridiagonal matrix    
!>          T, in elements 1 to N-1.                                    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The number of eigenvectors to be found.  0 <= M <= N.       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] W                                                         
!> \verbatim                                                            
!>          W is REAL array, dimension (N)                              
!>          The first M elements of W contain the eigenvalues for       
!>          which eigenvectors are to be computed.  The eigenvalues     
!>          should be grouped by split-off block and ordered from       
!>          smallest to largest within the block.  ( The output array   
!>          W from SSTEBZ with ORDER = 'B' is expected here. )          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IBLOCK                                                    
!> \verbatim                                                            
!>          IBLOCK is INTEGER array, dimension (N)                      
!>          The submatrix indices associated with the corresponding     
!>          eigenvalues in W; IBLOCK(i)=1 if eigenvalue W(i) belongs to 
!>          the first submatrix from the top, =2 if W(i) belongs to     
!>          the second submatrix, etc.  ( The output array IBLOCK       
!>          from SSTEBZ is expected here. )                             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ISPLIT                                                    
!> \verbatim                                                            
!>          ISPLIT is INTEGER array, dimension (N)                      
!>          The splitting points, at which T breaks up into submatrices.
!>          The first submatrix consists of rows/columns 1 to           
!>          ISPLIT( 1 ), the second of rows/columns ISPLIT( 1 )+1       
!>          through ISPLIT( 2 ), etc.                                   
!>          ( The output array ISPLIT from SSTEBZ is expected here. )   
!> \endverbatim                                                         
!>                                                                      
!> \param[out] Z                                                        
!> \verbatim                                                            
!>          Z is REAL array, dimension (LDZ, M)                         
!>          The computed eigenvectors.  The eigenvector associated      
!>          with the eigenvalue W(i) is stored in the i-th column of    
!>          Z.  Any vector which fails to converge is set to its current
!>          iterate after MAXITS iterations.                            
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDZ                                                       
!> \verbatim                                                            
!>          LDZ is INTEGER                                              
!>          The leading dimension of the array Z.  LDZ >= max(1,N).     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is REAL array, dimension (5*N)                         
!> \endverbatim                                                         
!>                                                                      
!> \param[out] IWORK                                                    
!> \verbatim                                                            
!>          IWORK is INTEGER array, dimension (N)                       
!> \endverbatim                                                         
!>                                                                      
!> \param[out] IFAIL                                                    
!> \verbatim                                                            
!>          IFAIL is INTEGER array, dimension (M)                       
!>          On normal exit, all elements of IFAIL are zero.             
!>          If one or more eigenvectors fail to converge after          
!>          MAXITS iterations, then their indices are stored in         
!>          array IFAIL.                                                
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0: successful exit.                                       
!>          < 0: if INFO = -i, the i-th argument had an illegal value   
!>          > 0: if INFO = i, then i eigenvectors failed to converge    
!>               in MAXITS iterations.  Their indices are stored in     
!>               array IFAIL.                                           
!> \endverbatim                                                         
!                                                                       
!> \par Internal Parameters:                                            
!  =========================                                            
!>                                                                      
!> \verbatim                                                            
!>  MAXITS  INTEGER, default = 5                                        
!>          The maximum number of iterations performed.                 
!>                                                                      
!>  EXTRA   INTEGER, default = 2                                        
!>          The number of iterations performed after norm growth        
!>          criterion is satisfied, should be at least 1.               
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup realOTHERcomputational                                      
!                                                                       
!  =====================================================================
      SUBROUTINE SSTEIN( N, D, E, M, W, IBLOCK, ISPLIT, Z, LDZ, WORK,   &
     &                   IWORK, IFAIL, INFO )                           
!                                                                       
!  -- LAPACK computational routine (version 3.7.0) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            INFO, LDZ, M, N 
!     ..                                                                
!     .. Array Arguments ..                                             
      INTEGER            IBLOCK( * ), IFAIL( * ), ISPLIT( * ),          &
     &                   IWORK( * )                                     
      REAL               D( * ), E( * ), W( * ), WORK( * ), Z( LDZ, * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ZERO, ONE, TEN, ODM3, ODM1 
      PARAMETER          ( ZERO = 0.0E+0, ONE = 1.0E+0, TEN = 1.0E+1,   &
     &                   ODM3 = 1.0E-3, ODM1 = 1.0E-1 )                 
      INTEGER            MAXITS, EXTRA 
      PARAMETER          ( MAXITS = 5, EXTRA = 2 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            B1, BLKSIZ, BN, GPIND, I, IINFO, INDRV1,       &
     &                   INDRV2, INDRV3, INDRV4, INDRV5, ITS, J, J1,    &
     &                   JBLK, JMAX, NBLK, NRMCHK                       
      REAL               CTR, EPS, EPS1, NRM, ONENRM, ORTOL, PERTOL,    &
     &                   SCL, SEP, STPCRT, TOL, XJ, XJM                 
!     ..                                                                
!     .. Local Arrays ..                                                
      INTEGER            ISEED( 4 ) 
!     ..                                                                
!     .. External Functions ..                                          
      INTEGER            ISAMAX 
      REAL               SDOT, SLAMCH, SNRM2 
      EXTERNAL           ISAMAX, SDOT, SLAMCH, SNRM2 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           SAXPY, SCOPY, SLAGTF, SLAGTS, SLARNV, SSCAL,   &
     &                   XERBLA                                         
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, MAX, SQRT 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0 
      DO 10 I = 1, M 
         IFAIL( I ) = 0 
   10 END DO 
!                                                                       
      IF( N.LT.0 ) THEN 
         INFO = -1 
      ELSE IF( M.LT.0 .OR. M.GT.N ) THEN 
         INFO = -4 
      ELSE IF( LDZ.LT.MAX( 1, N ) ) THEN 
         INFO = -9 
      ELSE 
         DO 20 J = 2, M 
            IF( IBLOCK( J ).LT.IBLOCK( J-1 ) ) THEN 
               INFO = -6 
               GO TO 30 
            END IF 
            IF( IBLOCK( J ).EQ.IBLOCK( J-1 ) .AND. W( J ).LT.W( J-1 ) ) &
     &           THEN                                                   
               INFO = -5 
               GO TO 30 
            END IF 
   20    CONTINUE 
   30    CONTINUE 
      END IF 
!                                                                       
      IF( INFO.NE.0 ) THEN 
         CALL XERBLA( 'SSTEIN', -INFO ) 
         RETURN 
      END IF 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.EQ.0 .OR. M.EQ.0 ) THEN 
         RETURN 
      ELSE IF( N.EQ.1 ) THEN 
         Z( 1, 1 ) = ONE 
         RETURN 
      END IF 
!                                                                       
!     Get machine constants.                                            
!                                                                       
      EPS = SLAMCH( 'Precision' ) 
!                                                                       
!     Initialize seed for random number generator SLARNV.               
!                                                                       
      DO 40 I = 1, 4 
         ISEED( I ) = 1 
   40 END DO 
!                                                                       
!     Initialize pointers.                                              
!                                                                       
      INDRV1 = 0 
      INDRV2 = INDRV1 + N 
      INDRV3 = INDRV2 + N 
      INDRV4 = INDRV3 + N 
      INDRV5 = INDRV4 + N 
!                                                                       
!     Compute eigenvectors of matrix blocks.                            
!                                                                       
      J1 = 1 
      DO 160 NBLK = 1, IBLOCK( M ) 
!                                                                       
!        Find starting and ending indices of block nblk.                
!                                                                       
         IF( NBLK.EQ.1 ) THEN 
            B1 = 1 
         ELSE 
            B1 = ISPLIT( NBLK-1 ) + 1 
         END IF 
         BN = ISPLIT( NBLK ) 
         BLKSIZ = BN - B1 + 1 
         IF( BLKSIZ.EQ.1 )                                              &
     &      GO TO 60                                                    
         GPIND = J1 
!                                                                       
!        Compute reorthogonalization criterion and stopping criterion.  
!                                                                       
         ONENRM = ABS( D( B1 ) ) + ABS( E( B1 ) ) 
         ONENRM = MAX( ONENRM, ABS( D( BN ) )+ABS( E( BN-1 ) ) ) 
         DO 50 I = B1 + 1, BN - 1 
            ONENRM = MAX( ONENRM, ABS( D( I ) )+ABS( E( I-1 ) )+        &
     &               ABS( E( I ) ) )                                    
   50    CONTINUE 
         ORTOL = ODM3*ONENRM 
!                                                                       
         STPCRT = SQRT( ODM1 / BLKSIZ ) 
!                                                                       
!        Loop through eigenvalues of block nblk.                        
!                                                                       
   60    CONTINUE 
         JBLK = 0 
         DO 150 J = J1, M 
            IF( IBLOCK( J ).NE.NBLK ) THEN 
               J1 = J 
               GO TO 160 
            END IF 
            JBLK = JBLK + 1 
            XJ = W( J ) 
!                                                                       
!           Skip all the work if the block size is one.                 
!                                                                       
            IF( BLKSIZ.EQ.1 ) THEN 
               WORK( INDRV1+1 ) = ONE 
               GO TO 120 
            END IF 
!                                                                       
!           If eigenvalues j and j-1 are too close, add a relatively    
!           small perturbation.                                         
!                                                                       
            IF( JBLK.GT.1 ) THEN 
               EPS1 = ABS( EPS*XJ ) 
               PERTOL = TEN*EPS1 
               SEP = XJ - XJM 
               IF( SEP.LT.PERTOL )                                      &
     &            XJ = XJM + PERTOL                                     
            END IF 
!                                                                       
            ITS = 0 
            NRMCHK = 0 
!                                                                       
!           Get random starting vector.                                 
!                                                                       
            CALL SLARNV( 2, ISEED, BLKSIZ, WORK( INDRV1+1 ) ) 
!                                                                       
!           Copy the matrix T so it won't be destroyed in factorization.
!                                                                       
            CALL SCOPY( BLKSIZ, D( B1 ), 1, WORK( INDRV4+1 ), 1 ) 
            CALL SCOPY( BLKSIZ-1, E( B1 ), 1, WORK( INDRV2+2 ), 1 ) 
            CALL SCOPY( BLKSIZ-1, E( B1 ), 1, WORK( INDRV3+1 ), 1 ) 
!                                                                       
!           Compute LU factors with partial pivoting  ( PT = LU )       
!                                                                       
            TOL = ZERO 
            CALL SLAGTF( BLKSIZ, WORK( INDRV4+1 ), XJ, WORK( INDRV2+2 ),&
     &                   WORK( INDRV3+1 ), TOL, WORK( INDRV5+1 ), IWORK,&
     &                   IINFO )                                        
!                                                                       
!           Update iteration count.                                     
!                                                                       
   70       CONTINUE 
            ITS = ITS + 1 
            IF( ITS.GT.MAXITS )                                         &
     &         GO TO 100                                                
!                                                                       
!           Normalize and scale the righthand side vector Pb.           
!                                                                       
            JMAX = ISAMAX( BLKSIZ, WORK( INDRV1+1 ), 1 ) 
            SCL = BLKSIZ*ONENRM*MAX( EPS,                               &
     &            ABS( WORK( INDRV4+BLKSIZ ) ) ) /                      &
     &            ABS( WORK( INDRV1+JMAX ) )                            
            CALL SSCAL( BLKSIZ, SCL, WORK( INDRV1+1 ), 1 ) 
!                                                                       
!           Solve the system LU = Pb.                                   
!                                                                       
            CALL SLAGTS( -1, BLKSIZ, WORK( INDRV4+1 ), WORK( INDRV2+2 ),&
     &                   WORK( INDRV3+1 ), WORK( INDRV5+1 ), IWORK,     &
     &                   WORK( INDRV1+1 ), TOL, IINFO )                 
!                                                                       
!           Reorthogonalize by modified Gram-Schmidt if eigenvalues are 
!           close enough.                                               
!                                                                       
            IF( JBLK.EQ.1 )                                             &
     &         GO TO 90                                                 
            IF( ABS( XJ-XJM ).GT.ORTOL )                                &
     &         GPIND = J                                                
            IF( GPIND.NE.J ) THEN 
               DO 80 I = GPIND, J - 1 
                  CTR = -SDOT( BLKSIZ, WORK( INDRV1+1 ), 1, Z( B1, I ), &
     &                  1 )                                             
                  CALL SAXPY( BLKSIZ, CTR, Z( B1, I ), 1,               &
     &                        WORK( INDRV1+1 ), 1 )                     
   80          CONTINUE 
            END IF 
!                                                                       
!           Check the infinity norm of the iterate.                     
!                                                                       
   90       CONTINUE 
            JMAX = ISAMAX( BLKSIZ, WORK( INDRV1+1 ), 1 ) 
            NRM = ABS( WORK( INDRV1+JMAX ) ) 
!                                                                       
!           Continue for additional iterations after norm reaches       
!           stopping criterion.                                         
!                                                                       
            IF( NRM.LT.STPCRT )                                         &
     &         GO TO 70                                                 
            NRMCHK = NRMCHK + 1 
            IF( NRMCHK.LT.EXTRA+1 )                                     &
     &         GO TO 70                                                 
!                                                                       
            GO TO 110 
!                                                                       
!           If stopping criterion was not satisfied, update info and    
!           store eigenvector number in array ifail.                    
!                                                                       
  100       CONTINUE 
            INFO = INFO + 1 
            IFAIL( INFO ) = J 
!                                                                       
!           Accept iterate as jth eigenvector.                          
!                                                                       
  110       CONTINUE 
            SCL = ONE / SNRM2( BLKSIZ, WORK( INDRV1+1 ), 1 ) 
            JMAX = ISAMAX( BLKSIZ, WORK( INDRV1+1 ), 1 ) 
            IF( WORK( INDRV1+JMAX ).LT.ZERO )                           &
     &         SCL = -SCL                                               
            CALL SSCAL( BLKSIZ, SCL, WORK( INDRV1+1 ), 1 ) 
  120       CONTINUE 
            DO 130 I = 1, N 
               Z( I, J ) = ZERO 
  130       CONTINUE 
            DO 140 I = 1, BLKSIZ 
               Z( B1+I-1, J ) = WORK( INDRV1+I ) 
  140       CONTINUE 
!                                                                       
!           Save the shift to check eigenvalue spacing at next          
!           iteration.                                                  
!                                                                       
            XJM = XJ 
!                                                                       
  150    CONTINUE 
  160 END DO 
!                                                                       
      RETURN 
!                                                                       
!     End of SSTEIN                                                     
!                                                                       
!> \brief \b SSTEMR                                                     
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SSTEMR + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SSTEMR( JOBZ, RANGE, N, D, E, VL, VU, IL, IU,        
!                          M, W, Z, LDZ, NZC, ISUPPZ, TRYRAC, WORK, LWOR
!                          IWORK, LIWORK, INFO )                        
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          JOBZ, RANGE                                  
!       LOGICAL            TRYRAC                                       
!       INTEGER            IL, INFO, IU, LDZ, NZC, LIWORK, LWORK, M, N  
!       REAL               VL, VU                                       
!       ..                                                              
!       .. Array Arguments ..                                           
!       INTEGER            ISUPPZ( * ), IWORK( * )                      
!       REAL               D( * ), E( * ), W( * ), WORK( * )            
!       REAL               Z( LDZ, * )                                  
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SSTEMR computes selected eigenvalues and, optionally, eigenvectors   
!> of a real symmetric tridiagonal matrix T. Any such unreduced matrix h
!> a well defined set of pairwise different real eigenvalues, the corres
!> real eigenvectors are pairwise orthogonal.                           
!>                                                                      
!> The spectrum may be computed either completely or partially by specif
!> either an interval (VL,VU] or a range of indices IL:IU for the desire
!> eigenvalues.                                                         
!>                                                                      
!> Depending on the number of desired eigenvalues, these are computed ei
!> by bisection or the dqds algorithm. Numerically orthogonal eigenvecto
!> computed by the use of various suitable L D L^T factorizations near c
!> of close eigenvalues (referred to as RRRs, Relatively Robust         
!> Representations). An informal sketch of the algorithm follows.       
!>                                                                      
!> For each unreduced block (submatrix) of T,                           
!>    (a) Compute T - sigma I  = L D L^T, so that L and D               
!>        define all the wanted eigenvalues to high relative accuracy.  
!>        This means that small relative changes in the entries of D and
!>        cause only small relative changes in the eigenvalues and      
!>        eigenvectors. The standard (unfactored) representation of the 
!>        tridiagonal matrix T does not have this property in general.  
!>    (b) Compute the eigenvalues to suitable accuracy.                 
!>        If the eigenvectors are desired, the algorithm attains full   
!>        accuracy of the computed eigenvalues only right before        
!>        the corresponding vectors have to be computed, see steps c) an
!>    (c) For each cluster of close eigenvalues, select a new           
!>        shift close to the cluster, find a new factorization, and refi
!>        the shifted eigenvalues to suitable accuracy.                 
!>    (d) For each eigenvalue with a large enough relative separation co
!>        the corresponding eigenvector by forming a rank revealing twis
!>        factorization. Go back to (c) for any clusters that remain.   
!>                                                                      
!> For more details, see:                                               
!> - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representat
!>   to compute orthogonal eigenvectors of symmetric tridiagonal matrice
!>   Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
!> - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors an
!>   Relative Gaps," SIAM Journal on Matrix Analysis and Applications, V
!>   2004.  Also LAPACK Working Note 154.                               
!> - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric        
!>   tridiagonal eigenvalue/eigenvector problem",                       
!>   Computer Science Division Technical Report No. UCB/CSD-97-971,     
!>   UC Berkeley, May 1997.                                             
!>                                                                      
!> Further Details                                                      
!> 1.SSTEMR works only on machines which follow IEEE-754                
!> floating-point standard in their handling of infinities and NaNs.    
!> This permits the use of efficient inner loops avoiding a check for   
!> zero divisors.                                                       
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] JOBZ                                                      
!> \verbatim                                                            
!>          JOBZ is CHARACTER*1                                         
!>          = 'N':  Compute eigenvalues only;                           
!>          = 'V':  Compute eigenvalues and eigenvectors.               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] RANGE                                                     
!> \verbatim                                                            
!>          RANGE is CHARACTER*1                                        
!>          = 'A': all eigenvalues will be found.                       
!>          = 'V': all eigenvalues in the half-open interval (VL,VU]    
!>                 will be found.                                       
!>          = 'I': the IL-th through IU-th eigenvalues will be found.   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix.  N >= 0.                           
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] D                                                     
!> \verbatim                                                            
!>          D is REAL array, dimension (N)                              
!>          On entry, the N diagonal elements of the tridiagonal matrix 
!>          T. On exit, D is overwritten.                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] E                                                     
!> \verbatim                                                            
!>          E is REAL array, dimension (N)                              
!>          On entry, the (N-1) subdiagonal elements of the tridiagonal 
!>          matrix T in elements 1 to N-1 of E. E(N) need not be set on 
!>          input, but is used internally as workspace.                 
!>          On exit, E is overwritten.                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] VL                                                        
!> \verbatim                                                            
!>          VL is REAL                                                  
!>                                                                      
!>          If RANGE='V', the lower bound of the interval to            
!>          be searched for eigenvalues. VL < VU.                       
!>          Not referenced if RANGE = 'A' or 'I'.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] VU                                                        
!> \verbatim                                                            
!>          VU is REAL                                                  
!>                                                                      
!>          If RANGE='V', the upper bound of the interval to            
!>          be searched for eigenvalues. VL < VU.                       
!>          Not referenced if RANGE = 'A' or 'I'.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IL                                                        
!> \verbatim                                                            
!>          IL is INTEGER                                               
!>                                                                      
!>          If RANGE='I', the index of the                              
!>          smallest eigenvalue to be returned.                         
!>          1 <= IL <= IU <= N, if N > 0.                               
!>          Not referenced if RANGE = 'A' or 'V'.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IU                                                        
!> \verbatim                                                            
!>          IU is INTEGER                                               
!>                                                                      
!>          If RANGE='I', the index of the                              
!>          largest eigenvalue to be returned.                          
!>          1 <= IL <= IU <= N, if N > 0.                               
!>          Not referenced if RANGE = 'A' or 'V'.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[out] M                                                        
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The total number of eigenvalues found.  0 <= M <= N.        
!>          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] W                                                        
!> \verbatim                                                            
!>          W is REAL array, dimension (N)                              
!>          The first M elements contain the selected eigenvalues in    
!>          ascending order.                                            
!> \endverbatim                                                         
!>                                                                      
!> \param[out] Z                                                        
!> \verbatim                                                            
!>          Z is REAL array, dimension (LDZ, max(1,M) )                 
!>          If JOBZ = 'V', and if INFO = 0, then the first M columns of 
!>          contain the orthonormal eigenvectors of the matrix T        
!>          corresponding to the selected eigenvalues, with the i-th    
!>          column of Z holding the eigenvector associated with W(i).   
!>          If JOBZ = 'N', then Z is not referenced.                    
!>          Note: the user must ensure that at least max(1,M) columns ar
!>          supplied in the array Z; if RANGE = 'V', the exact value of 
!>          is not known in advance and can be computed with a workspace
!>          query by setting NZC = -1, see below.                       
!> \endverbatim                                                         
!>                                                                      
      END                                           
!> \param[in] LDZ                                                       
!> \verbatim                                                            
!>          LDZ is INTEGER                                              
!>          The leading dimension of the array Z.  LDZ >= 1, and if     
!>          JOBZ = 'V', then LDZ >= max(1,N).                           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] NZC                                                       
!> \verbatim                                                            
!>          NZC is INTEGER                                              
!>          The number of eigenvectors to be held in the array Z.       
!>          If RANGE = 'A', then NZC >= max(1,N).                       
!>          If RANGE = 'V', then NZC >= the number of eigenvalues in (VL
!>          If RANGE = 'I', then NZC >= IU-IL+1.                        
!>          If NZC = -1, then a workspace query is assumed; the         
!>          routine calculates the number of columns of the array Z that
!>          are needed to hold the eigenvectors.                        
!>          This value is returned as the first entry of the Z array, an
!>          no error message related to NZC is issued by XERBLA.        
!> \endverbatim                                                         
!>                                                                      
!> \param[out] ISUPPZ                                                   
!> \verbatim                                                            
!>          ISUPPZ is INTEGER array, dimension ( 2*max(1,M) )           
!>          The support of the eigenvectors in Z, i.e., the indices     
!>          indicating the nonzero elements in Z. The i-th computed eige
!>          is nonzero only in elements ISUPPZ( 2*i-1 ) through         
!>          ISUPPZ( 2*i ). This is relevant in the case when the matrix 
!>          is split. ISUPPZ is only accessed when JOBZ is 'V' and N > 0
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] TRYRAC                                                
!> \verbatim                                                            
!>          TRYRAC is LOGICAL                                           
!>          If TRYRAC = .TRUE., indicates that the code should check whe
!>          the tridiagonal matrix defines its eigenvalues to high relat
!>          accuracy.  If so, the code uses relative-accuracy preserving
!>          algorithms that might be (a bit) slower depending on the mat
!>          If the matrix does not define its eigenvalues to high relati
!>          accuracy, the code can uses possibly faster algorithms.     
!>          If TRYRAC = .FALSE., the code is not required to guarantee  
!>          relatively accurate eigenvalues and can use the fastest poss
!>          techniques.                                                 
!>          On exit, a .TRUE. TRYRAC will be set to .FALSE. if the matri
!>          does not define its eigenvalues to high relative accuracy.  
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is REAL array, dimension (LWORK)                       
!>          On exit, if INFO = 0, WORK(1) returns the optimal           
!>          (and minimal) LWORK.                                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LWORK                                                     
!> \verbatim                                                            
!>          LWORK is INTEGER                                            
!>          The dimension of the array WORK. LWORK >= max(1,18*N)       
!>          if JOBZ = 'V', and LWORK >= max(1,12*N) if JOBZ = 'N'.      
!>          If LWORK = -1, then a workspace query is assumed; the routin
!>          only calculates the optimal size of the WORK array, returns 
!>          this value as the first entry of the WORK array, and no erro
!>          message related to LWORK is issued by XERBLA.               
!> \endverbatim                                                         
!>                                                                      
!> \param[out] IWORK                                                    
!> \verbatim                                                            
!>          IWORK is INTEGER array, dimension (LIWORK)                  
!>          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LIWORK                                                    
!> \verbatim                                                            
!>          LIWORK is INTEGER                                           
!>          The dimension of the array IWORK.  LIWORK >= max(1,10*N)    
!>          if the eigenvectors are desired, and LIWORK >= max(1,8*N)   
!>          if only the eigenvalues are to be computed.                 
!>          If LIWORK = -1, then a workspace query is assumed; the      
!>          routine only calculates the optimal size of the IWORK array,
!>          returns this value as the first entry of the IWORK array, an
!>          no error message related to LIWORK is issued by XERBLA.     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          On exit, INFO                                               
!>          = 0:  successful exit                                       
!>          < 0:  if INFO = -i, the i-th argument had an illegal value  
!>          > 0:  if INFO = 1X, internal error in SLARRE,               
!>                if INFO = 2X, internal error in SLARRV.               
!>                Here, the digit X = ABS( IINFO ) < 10, where IINFO is 
!>                the nonzero error code returned by SLARRE or          
!>                SLARRV, respectively.                                 
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2016                                                      
!                                                                       
!> \ingroup realOTHERcomputational                                      
!                                                                       
!> \par Contributors:                                                   
!  ==================                                                   
!>                                                                      
!> Beresford Parlett, University of California, Berkeley, USA \n        
!> Jim Demmel, University of California, Berkeley, USA \n               
!> Inderjit Dhillon, University of Texas, Austin, USA \n                
!> Osni Marques, LBNL/NERSC, USA \n                                     
!> Christof Voemel, University of California, Berkeley, USA             
!                                                                       
!  =====================================================================
      SUBROUTINE SSTEMR( JOBZ, RANGE, N, D, E, VL, VU, IL, IU,          &
     &                   M, W, Z, LDZ, NZC, ISUPPZ, TRYRAC, WORK, LWORK,&
     &                   IWORK, LIWORK, INFO )                          
!                                                                       
!  -- LAPACK computational routine (version 3.7.1) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2016                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          JOBZ, RANGE 
      LOGICAL            TRYRAC 
      INTEGER            IL, INFO, IU, LDZ, NZC, LIWORK, LWORK, M, N 
      REAL               VL, VU 
!     ..                                                                
!     .. Array Arguments ..                                             
      INTEGER            ISUPPZ( * ), IWORK( * ) 
      REAL               D( * ), E( * ), W( * ), WORK( * ) 
      REAL               Z( LDZ, * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ZERO, ONE, FOUR, MINRGP 
      PARAMETER          ( ZERO = 0.0E0, ONE = 1.0E0,                   &
     &                     FOUR = 4.0E0,                                &
     &                     MINRGP = 3.0E-3 )                            
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            ALLEIG, INDEIG, LQUERY, VALEIG, WANTZ, ZQUERY 
      INTEGER            I, IBEGIN, IEND, IFIRST, IIL, IINDBL, IINDW,   &
     &                   IINDWK, IINFO, IINSPL, IIU, ILAST, IN, INDD,   &
     &                   INDE2, INDERR, INDGP, INDGRS, INDWRK, ITMP,    &
     &                   ITMP2, J, JBLK, JJ, LIWMIN, LWMIN, NSPLIT,     &
     &                   NZCMIN, OFFSET, WBEGIN, WEND                   
      REAL               BIGNUM, CS, EPS, PIVMIN, R1, R2, RMAX, RMIN,   &
     &                   RTOL1, RTOL2, SAFMIN, SCALE, SMLNUM, SN,       &
     &                   THRESH, TMP, TNRM, WL, WU                      
!     ..                                                                
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      REAL               SLAMCH, SLANST 
      EXTERNAL           LSAME, SLAMCH, SLANST 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           SCOPY, SLAE2, SLAEV2, SLARRC, SLARRE, SLARRJ,  &
     &                   SLARRR, SLARRV, SLASRT, SSCAL, SSWAP, XERBLA   
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX, MIN, SQRT 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      WANTZ = LSAME( JOBZ, 'V' ) 
      ALLEIG = LSAME( RANGE, 'A' ) 
      VALEIG = LSAME( RANGE, 'V' ) 
      INDEIG = LSAME( RANGE, 'I' ) 
!                                                                       
      LQUERY = ( ( LWORK.EQ.-1 ).OR.( LIWORK.EQ.-1 ) ) 
      ZQUERY = ( NZC.EQ.-1 ) 
                                                                        
!     SSTEMR needs WORK of size 6*N, IWORK of size 3*N.                 
!     In addition, SLARRE needs WORK of size 6*N, IWORK of size 5*N.    
!     Furthermore, SLARRV needs WORK of size 12*N, IWORK of size 7*N.   
      IF( WANTZ ) THEN 
         LWMIN = 18*N 
         LIWMIN = 10*N 
      ELSE 
!        need less workspace if only the eigenvalues are wanted         
         LWMIN = 12*N 
         LIWMIN = 8*N 
      ENDIF 
                                                                        
      WL = ZERO 
      WU = ZERO 
      IIL = 0 
      IIU = 0 
      NSPLIT = 0 
                                                                        
      IF( VALEIG ) THEN 
!        We do not reference VL, VU in the cases RANGE = 'I','A'        
!        The interval (WL, WU] contains all the wanted eigenvalues.     
!        It is either given by the user or computed in SLARRE.          
         WL = VL 
         WU = VU 
      ELSEIF( INDEIG ) THEN 
!        We do not reference IL, IU in the cases RANGE = 'V','A'        
         IIL = IL 
         IIU = IU 
      ENDIF 
!                                                                       
      INFO = 0 
      IF( .NOT.( WANTZ .OR. LSAME( JOBZ, 'N' ) ) ) THEN 
         INFO = -1 
      ELSE IF( .NOT.( ALLEIG .OR. VALEIG .OR. INDEIG ) ) THEN 
         INFO = -2 
      ELSE IF( N.LT.0 ) THEN 
         INFO = -3 
      ELSE IF( VALEIG .AND. N.GT.0 .AND. WU.LE.WL ) THEN 
         INFO = -7 
      ELSE IF( INDEIG .AND. ( IIL.LT.1 .OR. IIL.GT.N ) ) THEN 
         INFO = -8 
      ELSE IF( INDEIG .AND. ( IIU.LT.IIL .OR. IIU.GT.N ) ) THEN 
         INFO = -9 
      ELSE IF( LDZ.LT.1 .OR. ( WANTZ .AND. LDZ.LT.N ) ) THEN 
         INFO = -13 
      ELSE IF( LWORK.LT.LWMIN .AND. .NOT.LQUERY ) THEN 
         INFO = -17 
      ELSE IF( LIWORK.LT.LIWMIN .AND. .NOT.LQUERY ) THEN 
         INFO = -19 
      END IF 
!                                                                       
!     Get machine constants.                                            
!                                                                       
      SAFMIN = SLAMCH( 'Safe minimum' ) 
      EPS = SLAMCH( 'Precision' ) 
      SMLNUM = SAFMIN / EPS 
      BIGNUM = ONE / SMLNUM 
      RMIN = SQRT( SMLNUM ) 
      RMAX = MIN( SQRT( BIGNUM ), ONE / SQRT( SQRT( SAFMIN ) ) ) 
!                                                                       
      IF( INFO.EQ.0 ) THEN 
         WORK( 1 ) = LWMIN 
         IWORK( 1 ) = LIWMIN 
!                                                                       
         IF( WANTZ .AND. ALLEIG ) THEN 
            NZCMIN = N 
         ELSE IF( WANTZ .AND. VALEIG ) THEN 
            CALL SLARRC( 'T', N, VL, VU, D, E, SAFMIN,                  &
     &                            NZCMIN, ITMP, ITMP2, INFO )           
         ELSE IF( WANTZ .AND. INDEIG ) THEN 
            NZCMIN = IIU-IIL+1 
         ELSE 
!           WANTZ .EQ. FALSE.                                           
            NZCMIN = 0 
         ENDIF 
         IF( ZQUERY .AND. INFO.EQ.0 ) THEN 
            Z( 1,1 ) = NZCMIN 
         ELSE IF( NZC.LT.NZCMIN .AND. .NOT.ZQUERY ) THEN 
            INFO = -14 
         END IF 
      END IF 
                                                                        
      IF( INFO.NE.0 ) THEN 
!                                                                       
         CALL XERBLA( 'SSTEMR', -INFO ) 
!                                                                       
         RETURN 
      ELSE IF( LQUERY .OR. ZQUERY ) THEN 
         RETURN 
      END IF 
!                                                                       
!     Handle N = 0, 1, and 2 cases immediately                          
!                                                                       
      M = 0 
      IF( N.EQ.0 )                                                      &
     &   RETURN                                                         
!                                                                       
      IF( N.EQ.1 ) THEN 
         IF( ALLEIG .OR. INDEIG ) THEN 
            M = 1 
            W( 1 ) = D( 1 ) 
         ELSE 
            IF( WL.LT.D( 1 ) .AND. WU.GE.D( 1 ) ) THEN 
               M = 1 
               W( 1 ) = D( 1 ) 
            END IF 
         END IF 
         IF( WANTZ.AND.(.NOT.ZQUERY) ) THEN 
            Z( 1, 1 ) = ONE 
            ISUPPZ(1) = 1 
            ISUPPZ(2) = 1 
         END IF 
         RETURN 
      END IF 
!                                                                       
      IF( N.EQ.2 ) THEN 
         IF( .NOT.WANTZ ) THEN 
            CALL SLAE2( D(1), E(1), D(2), R1, R2 ) 
         ELSE IF( WANTZ.AND.(.NOT.ZQUERY) ) THEN 
            CALL SLAEV2( D(1), E(1), D(2), R1, R2, CS, SN ) 
         END IF 
         IF( ALLEIG.OR.                                                 &
     &      (VALEIG.AND.(R2.GT.WL).AND.                                 &
     &                  (R2.LE.WU)).OR.                                 &
     &      (INDEIG.AND.(IIL.EQ.1)) ) THEN                              
            M = M+1 
            W( M ) = R2 
            IF( WANTZ.AND.(.NOT.ZQUERY) ) THEN 
               Z( 1, M ) = -SN 
               Z( 2, M ) = CS 
!              Note: At most one of SN and CS can be zero.              
               IF (SN.NE.ZERO) THEN 
                  IF (CS.NE.ZERO) THEN 
                     ISUPPZ(2*M-1) = 1 
                     ISUPPZ(2*M) = 2 
                  ELSE 
                     ISUPPZ(2*M-1) = 1 
                     ISUPPZ(2*M) = 1 
                  END IF 
               ELSE 
                  ISUPPZ(2*M-1) = 2 
                  ISUPPZ(2*M) = 2 
               END IF 
            ENDIF 
         ENDIF 
         IF( ALLEIG.OR.                                                 &
     &      (VALEIG.AND.(R1.GT.WL).AND.                                 &
     &                  (R1.LE.WU)).OR.                                 &
     &      (INDEIG.AND.(IIU.EQ.2)) ) THEN                              
            M = M+1 
            W( M ) = R1 
            IF( WANTZ.AND.(.NOT.ZQUERY) ) THEN 
               Z( 1, M ) = CS 
               Z( 2, M ) = SN 
!              Note: At most one of SN and CS can be zero.              
               IF (SN.NE.ZERO) THEN 
                  IF (CS.NE.ZERO) THEN 
                     ISUPPZ(2*M-1) = 1 
                     ISUPPZ(2*M) = 2 
                  ELSE 
                     ISUPPZ(2*M-1) = 1 
                     ISUPPZ(2*M) = 1 
                  END IF 
               ELSE 
                  ISUPPZ(2*M-1) = 2 
                  ISUPPZ(2*M) = 2 
               END IF 
            ENDIF 
         ENDIF 
      ELSE 
                                                                        
!     Continue with general N                                           
                                                                        
         INDGRS = 1 
         INDERR = 2*N + 1 
         INDGP = 3*N + 1 
         INDD = 4*N + 1 
         INDE2 = 5*N + 1 
         INDWRK = 6*N + 1 
!                                                                       
         IINSPL = 1 
         IINDBL = N + 1 
         IINDW = 2*N + 1 
         IINDWK = 3*N + 1 
!                                                                       
!        Scale matrix to allowable range, if necessary.                 
!        The allowable range is related to the PIVMIN parameter; see the
!        comments in SLARRD.  The preference for scaling small values   
!        up is heuristic; we expect users' matrices not to be close to t
!        RMAX threshold.                                                
!                                                                       
         SCALE = ONE 
         TNRM = SLANST( 'M', N, D, E ) 
         IF( TNRM.GT.ZERO .AND. TNRM.LT.RMIN ) THEN 
            SCALE = RMIN / TNRM 
         ELSE IF( TNRM.GT.RMAX ) THEN 
            SCALE = RMAX / TNRM 
         END IF 
         IF( SCALE.NE.ONE ) THEN 
            CALL SSCAL( N, SCALE, D, 1 ) 
            CALL SSCAL( N-1, SCALE, E, 1 ) 
            TNRM = TNRM*SCALE 
            IF( VALEIG ) THEN 
!              If eigenvalues in interval have to be found,             
!              scale (WL, WU] accordingly                               
               WL = WL*SCALE 
               WU = WU*SCALE 
            ENDIF 
         END IF 
!                                                                       
!        Compute the desired eigenvalues of the tridiagonal after splitt
!        into smaller subblocks if the corresponding off-diagonal elemen
!        are small                                                      
!        THRESH is the splitting parameter for SLARRE                   
!        A negative THRESH forces the old splitting criterion based on t
!        size of the off-diagonal. A positive THRESH switches to splitti
!        which preserves relative accuracy.                             
!                                                                       
         IF( TRYRAC ) THEN 
!           Test whether the matrix warrants the more expensive relative
            CALL SLARRR( N, D, E, IINFO ) 
         ELSE 
!           The user does not care about relative accurately eigenvalues
            IINFO = -1 
         ENDIF 
!        Set the splitting criterion                                    
         IF (IINFO.EQ.0) THEN 
            THRESH = EPS 
         ELSE 
            THRESH = -EPS 
!           relative accuracy is desired but T does not guarantee it    
            TRYRAC = .FALSE. 
         ENDIF 
!                                                                       
         IF( TRYRAC ) THEN 
!           Copy original diagonal, needed to guarantee relative accurac
            CALL SCOPY(N,D,1,WORK(INDD),1) 
         ENDIF 
!        Store the squares of the offdiagonal values of T               
         DO 5 J = 1, N-1 
            WORK( INDE2+J-1 ) = E(J)**2 
    5 END DO 
                                                                        
!        Set the tolerance parameters for bisection                     
         IF( .NOT.WANTZ ) THEN 
!           SLARRE computes the eigenvalues to full precision.          
            RTOL1 = FOUR * EPS 
            RTOL2 = FOUR * EPS 
         ELSE 
!           SLARRE computes the eigenvalues to less than full precision.
!           SLARRV will refine the eigenvalue approximations, and we can
!           need less accurate initial bisection in SLARRE.             
!           Note: these settings do only affect the subset case and SLAR
            RTOL1 = MAX( SQRT(EPS)*5.0E-2, FOUR * EPS ) 
            RTOL2 = MAX( SQRT(EPS)*5.0E-3, FOUR * EPS ) 
         ENDIF 
         CALL SLARRE( RANGE, N, WL, WU, IIL, IIU, D, E,                 &
     &             WORK(INDE2), RTOL1, RTOL2, THRESH, NSPLIT,           &
     &             IWORK( IINSPL ), M, W, WORK( INDERR ),               &
     &             WORK( INDGP ), IWORK( IINDBL ),                      &
     &             IWORK( IINDW ), WORK( INDGRS ), PIVMIN,              &
     &             WORK( INDWRK ), IWORK( IINDWK ), IINFO )             
         IF( IINFO.NE.0 ) THEN 
            INFO = 10 + ABS( IINFO ) 
            RETURN 
         END IF 
!        Note that if RANGE .NE. 'V', SLARRE computes bounds on the desi
!        part of the spectrum. All desired eigenvalues are contained in 
!        (WL,WU]                                                        
                                                                        
                                                                        
         IF( WANTZ ) THEN 
!                                                                       
!           Compute the desired eigenvectors corresponding to the comput
!           eigenvalues                                                 
!                                                                       
            CALL SLARRV( N, WL, WU, D, E,                               &
     &                PIVMIN, IWORK( IINSPL ), M,                       &
     &                1, M, MINRGP, RTOL1, RTOL2,                       &
     &                W, WORK( INDERR ), WORK( INDGP ), IWORK( IINDBL ),&
     &                IWORK( IINDW ), WORK( INDGRS ), Z, LDZ,           &
     &                ISUPPZ, WORK( INDWRK ), IWORK( IINDWK ), IINFO )  
            IF( IINFO.NE.0 ) THEN 
               INFO = 20 + ABS( IINFO ) 
               RETURN 
            END IF 
         ELSE 
!           SLARRE computes eigenvalues of the (shifted) root representa
!           SLARRV returns the eigenvalues of the unshifted matrix.     
!           However, if the eigenvectors are not desired by the user, we
!           to apply the corresponding shifts from SLARRE to obtain the 
!           eigenvalues of the original matrix.                         
            DO 20 J = 1, M 
               ITMP = IWORK( IINDBL+J-1 ) 
               W( J ) = W( J ) + E( IWORK( IINSPL+ITMP-1 ) ) 
   20    CONTINUE 
         END IF 
!                                                                       
                                                                        
         IF ( TRYRAC ) THEN 
!           Refine computed eigenvalues so that they are relatively accu
!           with respect to the original matrix T.                      
            IBEGIN = 1 
            WBEGIN = 1 
            DO 39  JBLK = 1, IWORK( IINDBL+M-1 ) 
               IEND = IWORK( IINSPL+JBLK-1 ) 
               IN = IEND - IBEGIN + 1 
               WEND = WBEGIN - 1 
!              check if any eigenvalues have to be refined in this block
   36       CONTINUE 
               IF( WEND.LT.M ) THEN 
                  IF( IWORK( IINDBL+WEND ).EQ.JBLK ) THEN 
                     WEND = WEND + 1 
                     GO TO 36 
                  END IF 
               END IF 
               IF( WEND.LT.WBEGIN ) THEN 
                  IBEGIN = IEND + 1 
                  GO TO 39 
               END IF 
                                                                        
               OFFSET = IWORK(IINDW+WBEGIN-1)-1 
               IFIRST = IWORK(IINDW+WBEGIN-1) 
               ILAST = IWORK(IINDW+WEND-1) 
               RTOL2 = FOUR * EPS 
               CALL SLARRJ( IN,                                         &
     &                   WORK(INDD+IBEGIN-1), WORK(INDE2+IBEGIN-1),     &
     &                   IFIRST, ILAST, RTOL2, OFFSET, W(WBEGIN),       &
     &                   WORK( INDERR+WBEGIN-1 ),                       &
     &                   WORK( INDWRK ), IWORK( IINDWK ), PIVMIN,       &
     &                   TNRM, IINFO )                                  
               IBEGIN = IEND + 1 
               WBEGIN = WEND + 1 
   39    CONTINUE 
         ENDIF 
!                                                                       
!        If matrix was scaled, then rescale eigenvalues appropriately.  
!                                                                       
         IF( SCALE.NE.ONE ) THEN 
            CALL SSCAL( M, ONE / SCALE, W, 1 ) 
         END IF 
      END IF 
!                                                                       
!     If eigenvalues are not in increasing order, then sort them,       
!     possibly along with eigenvectors.                                 
!                                                                       
      IF( NSPLIT.GT.1 .OR. N.EQ.2 ) THEN 
         IF( .NOT. WANTZ ) THEN 
            CALL SLASRT( 'I', M, W, IINFO ) 
            IF( IINFO.NE.0 ) THEN 
               INFO = 3 
               RETURN 
            END IF 
         ELSE 
            DO 60 J = 1, M - 1 
               I = 0 
               TMP = W( J ) 
               DO 50 JJ = J + 1, M 
                  IF( W( JJ ).LT.TMP ) THEN 
                     I = JJ 
                     TMP = W( JJ ) 
                  END IF 
   50          CONTINUE 
               IF( I.NE.0 ) THEN 
                  W( I ) = W( J ) 
                  W( J ) = TMP 
                  IF( WANTZ ) THEN 
                     CALL SSWAP( N, Z( 1, I ), 1, Z( 1, J ), 1 ) 
                     ITMP = ISUPPZ( 2*I-1 ) 
                     ISUPPZ( 2*I-1 ) = ISUPPZ( 2*J-1 ) 
                     ISUPPZ( 2*J-1 ) = ITMP 
                     ITMP = ISUPPZ( 2*I ) 
                     ISUPPZ( 2*I ) = ISUPPZ( 2*J ) 
                     ISUPPZ( 2*J ) = ITMP 
                  END IF 
               END IF 
   60       CONTINUE 
         END IF 
      ENDIF 
!                                                                       
!                                                                       
      WORK( 1 ) = LWMIN 
      IWORK( 1 ) = LIWMIN 
      RETURN 
!                                                                       
!     End of SSTEMR                                                     
!                                                                       
      END                                           
!> \brief \b SSTERF                                                     
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SSTERF + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SSTERF( N, D, E, INFO )                              
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            INFO, N                                      
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL               D( * ), E( * )                               
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SSTERF computes all eigenvalues of a symmetric tridiagonal matrix    
!> using the Pal-Walker-Kahan variant of the QL or QR algorithm.        
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix.  N >= 0.                           
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] D                                                     
!> \verbatim                                                            
!>          D is REAL array, dimension (N)                              
!>          On entry, the n diagonal elements of the tridiagonal matrix.
!>          On exit, if INFO = 0, the eigenvalues in ascending order.   
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] E                                                     
!> \verbatim                                                            
!>          E is REAL array, dimension (N-1)                            
!>          On entry, the (n-1) subdiagonal elements of the tridiagonal 
!>          matrix.                                                     
!>          On exit, E has been destroyed.                              
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0:  successful exit                                       
!>          < 0:  if INFO = -i, the i-th argument had an illegal value  
!>          > 0:  the algorithm failed to find all of the eigenvalues in
!>                a total of 30*N iterations; if INFO = i, then i       
!>                elements of E have not converged to zero.             
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup auxOTHERcomputational                                       
!                                                                       
!  =====================================================================
      SUBROUTINE SSTERF( N, D, E, INFO ) 
!                                                                       
!  -- LAPACK computational routine (version 3.7.0) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            INFO, N 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               D( * ), E( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ZERO, ONE, TWO, THREE 
      PARAMETER          ( ZERO = 0.0E0, ONE = 1.0E0, TWO = 2.0E0,      &
     &                   THREE = 3.0E0 )                                
      INTEGER            MAXIT 
      PARAMETER          ( MAXIT = 30 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I, ISCALE, JTOT, L, L1, LEND, LENDSV, LSV, M,  &
     &                   NMAXIT                                         
      REAL               ALPHA, ANORM, BB, C, EPS, EPS2, GAMMA, OLDC,   &
     &                   OLDGAM, P, R, RT1, RT2, RTE, S, SAFMAX, SAFMIN,&
     &                   SIGMA, SSFMAX, SSFMIN                          
!     ..                                                                
!     .. External Functions ..                                          
      REAL               SLAMCH, SLANST, SLAPY2 
      EXTERNAL           SLAMCH, SLANST, SLAPY2 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           SLAE2, SLASCL, SLASRT, XERBLA 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, SIGN, SQRT 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.LT.0 ) THEN 
         INFO = -1 
         CALL XERBLA( 'SSTERF', -INFO ) 
         RETURN 
      END IF 
      IF( N.LE.1 )                                                      &
     &   RETURN                                                         
!                                                                       
!     Determine the unit roundoff for this environment.                 
!                                                                       
      EPS = SLAMCH( 'E' ) 
      EPS2 = EPS**2 
      SAFMIN = SLAMCH( 'S' ) 
      SAFMAX = ONE / SAFMIN 
      SSFMAX = SQRT( SAFMAX ) / THREE 
      SSFMIN = SQRT( SAFMIN ) / EPS2 
!                                                                       
!     Compute the eigenvalues of the tridiagonal matrix.                
!                                                                       
      NMAXIT = N*MAXIT 
      SIGMA = ZERO 
      JTOT = 0 
!                                                                       
!     Determine where the matrix splits and choose QL or QR iteration   
!     for each block, according to whether top or bottom diagonal       
!     element is smaller.                                               
!                                                                       
      L1 = 1 
!                                                                       
   10 CONTINUE 
      IF( L1.GT.N )                                                     &
     &   GO TO 170                                                      
      IF( L1.GT.1 )                                                     &
     &   E( L1-1 ) = ZERO                                               
      DO 20 M = L1, N - 1 
         IF( ABS( E( M ) ).LE.( SQRT( ABS( D( M ) ) )*                  &
     &       SQRT( ABS( D( M+1 ) ) ) )*EPS ) THEN                       
            E( M ) = ZERO 
            GO TO 30 
         END IF 
   20 END DO 
      M = N 
!                                                                       
   30 CONTINUE 
      L = L1 
      LSV = L 
      LEND = M 
      LENDSV = LEND 
      L1 = M + 1 
      IF( LEND.EQ.L )                                                   &
     &   GO TO 10                                                       
!                                                                       
!     Scale submatrix in rows and columns L to LEND                     
!                                                                       
      ANORM = SLANST( 'M', LEND-L+1, D( L ), E( L ) ) 
      ISCALE = 0 
      IF( ANORM.EQ.ZERO )                                               &
     &   GO TO 10                                                       
      IF( ANORM.GT.SSFMAX ) THEN 
         ISCALE = 1 
         CALL SLASCL( 'G', 0, 0, ANORM, SSFMAX, LEND-L+1, 1, D( L ), N, &
     &                INFO )                                            
         CALL SLASCL( 'G', 0, 0, ANORM, SSFMAX, LEND-L, 1, E( L ), N,   &
     &                INFO )                                            
      ELSE IF( ANORM.LT.SSFMIN ) THEN 
         ISCALE = 2 
         CALL SLASCL( 'G', 0, 0, ANORM, SSFMIN, LEND-L+1, 1, D( L ), N, &
     &                INFO )                                            
         CALL SLASCL( 'G', 0, 0, ANORM, SSFMIN, LEND-L, 1, E( L ), N,   &
     &                INFO )                                            
      END IF 
!                                                                       
      DO 40 I = L, LEND - 1 
         E( I ) = E( I )**2 
   40 END DO 
!                                                                       
!     Choose between QL and QR iteration                                
!                                                                       
      IF( ABS( D( LEND ) ).LT.ABS( D( L ) ) ) THEN 
         LEND = LSV 
         L = LENDSV 
      END IF 
!                                                                       
      IF( LEND.GE.L ) THEN 
!                                                                       
!        QL Iteration                                                   
!                                                                       
!        Look for small subdiagonal element.                            
!                                                                       
   50    CONTINUE 
         IF( L.NE.LEND ) THEN 
            DO 60 M = L, LEND - 1 
               IF( ABS( E( M ) ).LE.EPS2*ABS( D( M )*D( M+1 ) ) )       &
     &            GO TO 70                                              
   60       CONTINUE 
         END IF 
         M = LEND 
!                                                                       
   70    CONTINUE 
         IF( M.LT.LEND )                                                &
     &      E( M ) = ZERO                                               
         P = D( L ) 
         IF( M.EQ.L )                                                   &
     &      GO TO 90                                                    
!                                                                       
!        If remaining matrix is 2 by 2, use SLAE2 to compute its        
!        eigenvalues.                                                   
!                                                                       
         IF( M.EQ.L+1 ) THEN 
            RTE = SQRT( E( L ) ) 
            CALL SLAE2( D( L ), RTE, D( L+1 ), RT1, RT2 ) 
            D( L ) = RT1 
            D( L+1 ) = RT2 
            E( L ) = ZERO 
            L = L + 2 
            IF( L.LE.LEND )                                             &
     &         GO TO 50                                                 
            GO TO 150 
         END IF 
!                                                                       
         IF( JTOT.EQ.NMAXIT )                                           &
     &      GO TO 150                                                   
         JTOT = JTOT + 1 
!                                                                       
!        Form shift.                                                    
!                                                                       
         RTE = SQRT( E( L ) ) 
         SIGMA = ( D( L+1 )-P ) / ( TWO*RTE ) 
         R = SLAPY2( SIGMA, ONE ) 
         SIGMA = P - ( RTE / ( SIGMA+SIGN( R, SIGMA ) ) ) 
!                                                                       
         C = ONE 
         S = ZERO 
         GAMMA = D( M ) - SIGMA 
         P = GAMMA*GAMMA 
!                                                                       
!        Inner loop                                                     
!                                                                       
         DO 80 I = M - 1, L, -1 
            BB = E( I ) 
            R = P + BB 
            IF( I.NE.M-1 )                                              &
     &         E( I+1 ) = S*R                                           
            OLDC = C 
            C = P / R 
            S = BB / R 
            OLDGAM = GAMMA 
            ALPHA = D( I ) 
            GAMMA = C*( ALPHA-SIGMA ) - S*OLDGAM 
            D( I+1 ) = OLDGAM + ( ALPHA-GAMMA ) 
            IF( C.NE.ZERO ) THEN 
               P = ( GAMMA*GAMMA ) / C 
            ELSE 
               P = OLDC*BB 
            END IF 
   80    CONTINUE 
!                                                                       
         E( L ) = S*P 
         D( L ) = SIGMA + GAMMA 
         GO TO 50 
!                                                                       
!        Eigenvalue found.                                              
!                                                                       
   90    CONTINUE 
         D( L ) = P 
!                                                                       
         L = L + 1 
         IF( L.LE.LEND )                                                &
     &      GO TO 50                                                    
         GO TO 150 
!                                                                       
      ELSE 
!                                                                       
!        QR Iteration                                                   
!                                                                       
!        Look for small superdiagonal element.                          
!                                                                       
  100    CONTINUE 
         DO 110 M = L, LEND + 1, -1 
            IF( ABS( E( M-1 ) ).LE.EPS2*ABS( D( M )*D( M-1 ) ) )        &
     &         GO TO 120                                                
  110    CONTINUE 
         M = LEND 
!                                                                       
  120    CONTINUE 
         IF( M.GT.LEND )                                                &
     &      E( M-1 ) = ZERO                                             
         P = D( L ) 
         IF( M.EQ.L )                                                   &
     &      GO TO 140                                                   
!                                                                       
!        If remaining matrix is 2 by 2, use SLAE2 to compute its        
!        eigenvalues.                                                   
!                                                                       
         IF( M.EQ.L-1 ) THEN 
            RTE = SQRT( E( L-1 ) ) 
            CALL SLAE2( D( L ), RTE, D( L-1 ), RT1, RT2 ) 
            D( L ) = RT1 
            D( L-1 ) = RT2 
            E( L-1 ) = ZERO 
            L = L - 2 
            IF( L.GE.LEND )                                             &
     &         GO TO 100                                                
            GO TO 150 
         END IF 
!                                                                       
         IF( JTOT.EQ.NMAXIT )                                           &
     &      GO TO 150                                                   
         JTOT = JTOT + 1 
!                                                                       
!        Form shift.                                                    
!                                                                       
         RTE = SQRT( E( L-1 ) ) 
         SIGMA = ( D( L-1 )-P ) / ( TWO*RTE ) 
         R = SLAPY2( SIGMA, ONE ) 
         SIGMA = P - ( RTE / ( SIGMA+SIGN( R, SIGMA ) ) ) 
!                                                                       
         C = ONE 
         S = ZERO 
         GAMMA = D( M ) - SIGMA 
         P = GAMMA*GAMMA 
!                                                                       
!        Inner loop                                                     
!                                                                       
         DO 130 I = M, L - 1 
            BB = E( I ) 
            R = P + BB 
            IF( I.NE.M )                                                &
     &         E( I-1 ) = S*R                                           
            OLDC = C 
            C = P / R 
            S = BB / R 
            OLDGAM = GAMMA 
            ALPHA = D( I+1 ) 
            GAMMA = C*( ALPHA-SIGMA ) - S*OLDGAM 
            D( I ) = OLDGAM + ( ALPHA-GAMMA ) 
            IF( C.NE.ZERO ) THEN 
               P = ( GAMMA*GAMMA ) / C 
            ELSE 
               P = OLDC*BB 
            END IF 
  130    CONTINUE 
!                                                                       
         E( L-1 ) = S*P 
         D( L ) = SIGMA + GAMMA 
         GO TO 100 
!                                                                       
!        Eigenvalue found.                                              
!                                                                       
  140    CONTINUE 
         D( L ) = P 
!                                                                       
         L = L - 1 
         IF( L.GE.LEND )                                                &
     &      GO TO 100                                                   
         GO TO 150 
!                                                                       
      END IF 
!                                                                       
!     Undo scaling if necessary                                         
!                                                                       
  150 CONTINUE 
      IF( ISCALE.EQ.1 )                                                 &
     &   CALL SLASCL( 'G', 0, 0, SSFMAX, ANORM, LENDSV-LSV+1, 1,        &
     &                D( LSV ), N, INFO )                               
      IF( ISCALE.EQ.2 )                                                 &
     &   CALL SLASCL( 'G', 0, 0, SSFMIN, ANORM, LENDSV-LSV+1, 1,        &
     &                D( LSV ), N, INFO )                               
!                                                                       
!     Check for no convergence to an eigenvalue after a total           
!     of N*MAXIT iterations.                                            
!                                                                       
      IF( JTOT.LT.NMAXIT )                                              &
     &   GO TO 10                                                       
      DO 160 I = 1, N - 1 
         IF( E( I ).NE.ZERO )                                           &
     &      INFO = INFO + 1                                             
  160 END DO 
      GO TO 180 
!                                                                       
!     Sort eigenvalues in increasing order.                             
!                                                                       
  170 CONTINUE 
      CALL SLASRT( 'I', N, D, INFO ) 
!                                                                       
  180 CONTINUE 
      RETURN 
!                                                                       
!     End of SSTERF                                                     
!                                                                       
      END                                           
!> \brief \b SSWAP                                                      
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SSWAP(N,SX,INCX,SY,INCY)                             
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER INCX,INCY,N                                             
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL SX(*),SY(*)                                                
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>    SSWAP interchanges two vectors.                                   
!>    uses unrolled loops for increments equal to 1.                    
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>         number of elements in input vector(s)                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] SX                                                    
!> \verbatim                                                            
!>          SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) )   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCX                                                      
!> \verbatim                                                            
!>          INCX is INTEGER                                             
!>         storage spacing between elements of SX                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] SY                                                    
!> \verbatim                                                            
!>          SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCY ) )   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCY                                                      
!> \verbatim                                                            
!>          INCY is INTEGER                                             
!>         storage spacing between elements of SY                       
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date November 2017                                                  
!                                                                       
!> \ingroup single_blas_level1                                          
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>     jack dongarra, linpack, 3/11/78.                                 
!>     modified 12/3/93, array(1) declarations changed to array(*)      
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE SSWAP(N,SX,INCX,SY,INCY) 
!                                                                       
!  -- Reference BLAS level1 routine (version 3.8.0) --                  
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     November 2017                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER INCX,INCY,N 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL SX(*),SY(*) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Local Scalars ..                                               
      REAL STEMP 
      INTEGER I,IX,IY,M,MP1 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC MOD 
!     ..                                                                
      IF (N.LE.0) RETURN 
      IF (INCX.EQ.1 .AND. INCY.EQ.1) THEN 
!                                                                       
!       code for both increments equal to 1                             
!                                                                       
!                                                                       
!       clean-up loop                                                   
!                                                                       
         M = MOD(N,3) 
         IF (M.NE.0) THEN 
            DO I = 1,M 
               STEMP = SX(I) 
               SX(I) = SY(I) 
               SY(I) = STEMP 
            END DO 
            IF (N.LT.3) RETURN 
         END IF 
         MP1 = M + 1 
         DO I = MP1,N,3 
            STEMP = SX(I) 
            SX(I) = SY(I) 
            SY(I) = STEMP 
            STEMP = SX(I+1) 
            SX(I+1) = SY(I+1) 
            SY(I+1) = STEMP 
            STEMP = SX(I+2) 
            SX(I+2) = SY(I+2) 
            SY(I+2) = STEMP 
         END DO 
      ELSE 
!                                                                       
!       code for unequal increments or equal increments not equal       
!         to 1                                                          
!                                                                       
         IX = 1 
         IY = 1 
         IF (INCX.LT.0) IX = (-N+1)*INCX + 1 
         IF (INCY.LT.0) IY = (-N+1)*INCY + 1 
         DO I = 1,N 
            STEMP = SX(IX) 
            SX(IX) = SY(IY) 
            SY(IY) = STEMP 
            IX = IX + INCX 
            IY = IY + INCY 
         END DO 
      END IF 
      RETURN 
!> \brief <b> SSYEVR computes the eigenvalues and, optionally, the left 
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SSYEVR + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SSYEVR( JOBZ, RANGE, UPLO, N, A, LDA, VL, VU, IL, IU,
!                          ABSTOL, M, W, Z, LDZ, ISUPPZ, WORK, LWORK,   
!                          IWORK, LIWORK, INFO )                        
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          JOBZ, RANGE, UPLO                            
!       INTEGER            IL, INFO, IU, LDA, LDZ, LIWORK, LWORK, M, N  
!       REAL               ABSTOL, VL, VU                               
!       ..                                                              
!       .. Array Arguments ..                                           
!       INTEGER            ISUPPZ( * ), IWORK( * )                      
!       REAL               A( LDA, * ), W( * ), WORK( * ), Z( LDZ, * )  
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SSYEVR computes selected eigenvalues and, optionally, eigenvectors   
!> of a real symmetric matrix A.  Eigenvalues and eigenvectors can be   
!> selected by specifying either a range of values or a range of        
!> indices for the desired eigenvalues.                                 
!>                                                                      
!> SSYEVR first reduces the matrix A to tridiagonal form T with a call  
!> to SSYTRD.  Then, whenever possible, SSYEVR calls SSTEMR to compute  
!> the eigenspectrum using Relatively Robust Representations.  SSTEMR   
!> computes eigenvalues by the dqds algorithm, while orthogonal         
!> eigenvectors are computed from various "good" L D L^T representations
!> (also known as Relatively Robust Representations). Gram-Schmidt      
!> orthogonalization is avoided as far as possible. More specifically,  
!> the various steps of the algorithm are as follows.                   
!>                                                                      
!> For each unreduced block (submatrix) of T,                           
!>    (a) Compute T - sigma I  = L D L^T, so that L and D               
!>        define all the wanted eigenvalues to high relative accuracy.  
!>        This means that small relative changes in the entries of D and
!>        cause only small relative changes in the eigenvalues and      
!>        eigenvectors. The standard (unfactored) representation of the 
!>        tridiagonal matrix T does not have this property in general.  
!>    (b) Compute the eigenvalues to suitable accuracy.                 
!>        If the eigenvectors are desired, the algorithm attains full   
!>        accuracy of the computed eigenvalues only right before        
!>        the corresponding vectors have to be computed, see steps c) an
!>    (c) For each cluster of close eigenvalues, select a new           
!>        shift close to the cluster, find a new factorization, and refi
!>        the shifted eigenvalues to suitable accuracy.                 
!>    (d) For each eigenvalue with a large enough relative separation co
!>        the corresponding eigenvector by forming a rank revealing twis
!>        factorization. Go back to (c) for any clusters that remain.   
!>                                                                      
!> The desired accuracy of the output can be specified by the input     
!> parameter ABSTOL.                                                    
!>                                                                      
!> For more details, see SSTEMR's documentation and:                    
!> - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representat
!>   to compute orthogonal eigenvectors of symmetric tridiagonal matrice
!>   Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
!> - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors an
!>   Relative Gaps," SIAM Journal on Matrix Analysis and Applications, V
!>   2004.  Also LAPACK Working Note 154.                               
!> - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric        
!>   tridiagonal eigenvalue/eigenvector problem",                       
!>   Computer Science Division Technical Report No. UCB/CSD-97-971,     
!>   UC Berkeley, May 1997.                                             
!>                                                                      
!>                                                                      
!> Note 1 : SSYEVR calls SSTEMR when the full spectrum is requested     
!> on machines which conform to the ieee-754 floating point standard.   
!> SSYEVR calls SSTEBZ and SSTEIN on non-ieee machines and              
!> when partial spectrum requests are made.                             
!>                                                                      
!> Normal execution of SSTEMR may create NaNs and infinities and        
!> hence may abort due to a floating point exception in environments    
!> which do not handle NaNs and infinities in the ieee standard default 
!> manner.                                                              
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] JOBZ                                                      
!> \verbatim                                                            
!>          JOBZ is CHARACTER*1                                         
!>          = 'N':  Compute eigenvalues only;                           
!>          = 'V':  Compute eigenvalues and eigenvectors.               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] RANGE                                                     
!> \verbatim                                                            
!>          RANGE is CHARACTER*1                                        
!>          = 'A': all eigenvalues will be found.                       
!>          = 'V': all eigenvalues in the half-open interval (VL,VU]    
!>                 will be found.                                       
!>          = 'I': the IL-th through IU-th eigenvalues will be found.   
!>          For RANGE = 'V' or 'I' and IU - IL < N - 1, SSTEBZ and      
!>          SSTEIN are called                                           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] UPLO                                                      
!> \verbatim                                                            
!>          UPLO is CHARACTER*1                                         
!>          = 'U':  Upper triangle of A is stored;                      
!>          = 'L':  Lower triangle of A is stored.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix A.  N >= 0.                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] A                                                     
!> \verbatim                                                            
!>          A is REAL array, dimension (LDA, N)                         
!>          On entry, the symmetric matrix A.  If UPLO = 'U', the       
!>          leading N-by-N upper triangular part of A contains the      
!>          upper triangular part of the matrix A.  If UPLO = 'L',      
!>          the leading N-by-N lower triangular part of A contains      
!>          the lower triangular part of the matrix A.                  
!>          On exit, the lower triangle (if UPLO='L') or the upper      
!>          triangle (if UPLO='U') of A, including the diagonal, is     
!>          destroyed.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>          The leading dimension of the array A.  LDA >= max(1,N).     
!> \endverbatim                                                         
!>                                                                      
!> \param[in] VL                                                        
!> \verbatim                                                            
!>          VL is REAL                                                  
!>          If RANGE='V', the lower bound of the interval to            
!>          be searched for eigenvalues. VL < VU.                       
!>          Not referenced if RANGE = 'A' or 'I'.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] VU                                                        
!> \verbatim                                                            
!>          VU is REAL                                                  
!>          If RANGE='V', the upper bound of the interval to            
!>          be searched for eigenvalues. VL < VU.                       
!>          Not referenced if RANGE = 'A' or 'I'.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IL                                                        
!> \verbatim                                                            
!>          IL is INTEGER                                               
!>          If RANGE='I', the index of the                              
!>          smallest eigenvalue to be returned.                         
!>          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.   
!>          Not referenced if RANGE = 'A' or 'V'.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IU                                                        
!> \verbatim                                                            
!>          IU is INTEGER                                               
!>          If RANGE='I', the index of the                              
!>          largest eigenvalue to be returned.                          
!>          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.   
!>          Not referenced if RANGE = 'A' or 'V'.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ABSTOL                                                    
!> \verbatim                                                            
!>          ABSTOL is REAL                                              
!>          The absolute error tolerance for the eigenvalues.           
!>          An approximate eigenvalue is accepted as converged          
!>          when it is determined to lie in an interval [a,b]           
!>          of width less than or equal to                              
!>                                                                      
!>                  ABSTOL + EPS *   max( |a|,|b| ) ,                   
!>                                                                      
!>          where EPS is the machine precision.  If ABSTOL is less than 
!>          or equal to zero, then  EPS*|T|  will be used in its place, 
!>          where |T| is the 1-norm of the tridiagonal matrix obtained  
!>          by reducing A to tridiagonal form.                          
!>                                                                      
      END                                           
!>          See "Computing Small Singular Values of Bidiagonal Matrices 
!>          with Guaranteed High Relative Accuracy," by Demmel and      
!>          Kahan, LAPACK Working Note #3.                              
!>                                                                      
!>          If high relative accuracy is important, set ABSTOL to       
!>          SLAMCH( 'Safe minimum' ).  Doing so will guarantee that     
!>          eigenvalues are computed to high relative accuracy when     
!>          possible in future releases.  The current code does not     
!>          make any guarantees about high relative accuracy, but       
!>          future releases will. See J. Barlow and J. Demmel,          
!>          "Computing Accurate Eigensystems of Scaled Diagonally       
!>          Dominant Matrices", LAPACK Working Note #7, for a discussion
!>          of which matrices define their eigenvalues to high relative 
!>          accuracy.                                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[out] M                                                        
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The total number of eigenvalues found.  0 <= M <= N.        
!>          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] W                                                        
!> \verbatim                                                            
!>          W is REAL array, dimension (N)                              
!>          The first M elements contain the selected eigenvalues in    
!>          ascending order.                                            
!> \endverbatim                                                         
!>                                                                      
!> \param[out] Z                                                        
!> \verbatim                                                            
!>          Z is REAL array, dimension (LDZ, max(1,M))                  
!>          If JOBZ = 'V', then if INFO = 0, the first M columns of Z   
!>          contain the orthonormal eigenvectors of the matrix A        
!>          corresponding to the selected eigenvalues, with the i-th    
!>          column of Z holding the eigenvector associated with W(i).   
!>          If JOBZ = 'N', then Z is not referenced.                    
!>          Note: the user must ensure that at least max(1,M) columns ar
!>          supplied in the array Z; if RANGE = 'V', the exact value of 
!>          is not known in advance and an upper bound must be used.    
!>          Supplying N columns is always safe.                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDZ                                                       
!> \verbatim                                                            
!>          LDZ is INTEGER                                              
!>          The leading dimension of the array Z.  LDZ >= 1, and if     
!>          JOBZ = 'V', LDZ >= max(1,N).                                
!> \endverbatim                                                         
!>                                                                      
!> \param[out] ISUPPZ                                                   
!> \verbatim                                                            
!>          ISUPPZ is INTEGER array, dimension ( 2*max(1,M) )           
!>          The support of the eigenvectors in Z, i.e., the indices     
!>          indicating the nonzero elements in Z. The i-th eigenvector  
!>          is nonzero only in elements ISUPPZ( 2*i-1 ) through         
!>          ISUPPZ( 2*i ). This is an output of SSTEMR (tridiagonal     
!>          matrix). The support of the eigenvectors of A is typically  
!>          1:N because of the orthogonal transformations applied by SOR
!>          Implemented only for RANGE = 'A' or 'I' and IU - IL = N - 1 
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is REAL array, dimension (MAX(1,LWORK))                
!>          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LWORK                                                     
!> \verbatim                                                            
!>          LWORK is INTEGER                                            
!>          The dimension of the array WORK.  LWORK >= max(1,26*N).     
!>          For optimal efficiency, LWORK >= (NB+6)*N,                  
!>          where NB is the max of the blocksize for SSYTRD and SORMTR  
!>          returned by ILAENV.                                         
!>                                                                      
!>          If LWORK = -1, then a workspace query is assumed; the routin
!>          only calculates the optimal sizes of the WORK and IWORK     
!>          arrays, returns these values as the first entries of the WOR
!>          and IWORK arrays, and no error message related to LWORK or  
!>          LIWORK is issued by XERBLA.                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[out] IWORK                                                    
!> \verbatim                                                            
!>          IWORK is INTEGER array, dimension (MAX(1,LIWORK))           
!>          On exit, if INFO = 0, IWORK(1) returns the optimal LWORK.   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LIWORK                                                    
!> \verbatim                                                            
!>          LIWORK is INTEGER                                           
!>          The dimension of the array IWORK.  LIWORK >= max(1,10*N).   
!>                                                                      
!>          If LIWORK = -1, then a workspace query is assumed; the      
!>          routine only calculates the optimal sizes of the WORK and   
!>          IWORK arrays, returns these values as the first entries of  
!>          the WORK and IWORK arrays, and no error message related to  
!>          LWORK or LIWORK is issued by XERBLA.                        
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0:  successful exit                                       
!>          < 0:  if INFO = -i, the i-th argument had an illegal value  
!>          > 0:  Internal error                                        
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2016                                                      
!                                                                       
!> \ingroup realSYeigen                                                 
!                                                                       
!> \par Contributors:                                                   
!  ==================                                                   
!>                                                                      
!>     Inderjit Dhillon, IBM Almaden, USA \n                            
!>     Osni Marques, LBNL/NERSC, USA \n                                 
!>     Ken Stanley, Computer Science Division, University of            
!>       California at Berkeley, USA \n                                 
!>     Jason Riedy, Computer Science Division, University of            
!>       California at Berkeley, USA \n                                 
!>                                                                      
!  =====================================================================
      SUBROUTINE SSYEVR( JOBZ, RANGE, UPLO, N, A, LDA, VL, VU, IL, IU,  &
     &                   ABSTOL, M, W, Z, LDZ, ISUPPZ, WORK, LWORK,     &
     &                   IWORK, LIWORK, INFO )                          
!                                                                       
!  -- LAPACK driver routine (version 3.7.0) --                          
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2016                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          JOBZ, RANGE, UPLO 
      INTEGER            IL, INFO, IU, LDA, LDZ, LIWORK, LWORK, M, N 
      REAL               ABSTOL, VL, VU 
!     ..                                                                
!     .. Array Arguments ..                                             
      INTEGER            ISUPPZ( * ), IWORK( * ) 
      REAL               A( LDA, * ), W( * ), WORK( * ), Z( LDZ, * ) 
!     ..                                                                
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Parameters ..                                                  
      REAL               ZERO, ONE, TWO 
      PARAMETER          ( ZERO = 0.0E+0, ONE = 1.0E+0, TWO = 2.0E+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            ALLEIG, INDEIG, LOWER, LQUERY, TEST, VALEIG,   &
     &                   WANTZ, TRYRAC                                  
      CHARACTER          ORDER 
      INTEGER            I, IEEEOK, IINFO, IMAX, INDD, INDDD, INDE,     &
     &                   INDEE, INDIBL, INDIFL, INDISP, INDIWO, INDTAU, &
     &                   INDWK, INDWKN, ISCALE, J, JJ, LIWMIN,          &
     &                   LLWORK, LLWRKN, LWKOPT, LWMIN, NB, NSPLIT      
      REAL               ABSTLL, ANRM, BIGNUM, EPS, RMAX, RMIN, SAFMIN, &
     &                   SIGMA, SMLNUM, TMP1, VLL, VUU                  
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      INTEGER            ILAENV 
      REAL               SLAMCH, SLANSY 
      EXTERNAL           LSAME, ILAENV, SLAMCH, SLANSY 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           SCOPY, SORMTR, SSCAL, SSTEBZ, SSTEMR, SSTEIN,  &
     &                   SSTERF, SSWAP, SSYTRD, XERBLA                  
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX, MIN, SQRT 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      IEEEOK = ILAENV( 10, 'SSYEVR', 'N', 1, 2, 3, 4 ) 
!                                                                       
      LOWER = LSAME( UPLO, 'L' ) 
      WANTZ = LSAME( JOBZ, 'V' ) 
      ALLEIG = LSAME( RANGE, 'A' ) 
      VALEIG = LSAME( RANGE, 'V' ) 
      INDEIG = LSAME( RANGE, 'I' ) 
!                                                                       
      LQUERY = ( ( LWORK.EQ.-1 ) .OR. ( LIWORK.EQ.-1 ) ) 
!                                                                       
      LWMIN = MAX( 1, 26*N ) 
      LIWMIN = MAX( 1, 10*N ) 
!                                                                       
      INFO = 0 
      IF( .NOT.( WANTZ .OR. LSAME( JOBZ, 'N' ) ) ) THEN 
         INFO = -1 
      ELSE IF( .NOT.( ALLEIG .OR. VALEIG .OR. INDEIG ) ) THEN 
         INFO = -2 
      ELSE IF( .NOT.( LOWER .OR. LSAME( UPLO, 'U' ) ) ) THEN 
         INFO = -3 
      ELSE IF( N.LT.0 ) THEN 
         INFO = -4 
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN 
         INFO = -6 
      ELSE 
         IF( VALEIG ) THEN 
            IF( N.GT.0 .AND. VU.LE.VL )                                 &
     &         INFO = -8                                                
         ELSE IF( INDEIG ) THEN 
            IF( IL.LT.1 .OR. IL.GT.MAX( 1, N ) ) THEN 
               INFO = -9 
            ELSE IF( IU.LT.MIN( N, IL ) .OR. IU.GT.N ) THEN 
               INFO = -10 
            END IF 
         END IF 
      END IF 
      IF( INFO.EQ.0 ) THEN 
         IF( LDZ.LT.1 .OR. ( WANTZ .AND. LDZ.LT.N ) ) THEN 
            INFO = -15 
         END IF 
      END IF 
!                                                                       
      IF( INFO.EQ.0 ) THEN 
         NB = ILAENV( 1, 'SSYTRD', UPLO, N, -1, -1, -1 ) 
         NB = MAX( NB, ILAENV( 1, 'SORMTR', UPLO, N, -1, -1, -1 ) ) 
         LWKOPT = MAX( ( NB+1 )*N, LWMIN ) 
         WORK( 1 ) = LWKOPT 
         IWORK( 1 ) = LIWMIN 
!                                                                       
         IF( LWORK.LT.LWMIN .AND. .NOT.LQUERY ) THEN 
            INFO = -18 
         ELSE IF( LIWORK.LT.LIWMIN .AND. .NOT.LQUERY ) THEN 
            INFO = -20 
         END IF 
      END IF 
!                                                                       
      IF( INFO.NE.0 ) THEN 
         CALL XERBLA( 'SSYEVR', -INFO ) 
         RETURN 
      ELSE IF( LQUERY ) THEN 
         RETURN 
      END IF 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      M = 0 
      IF( N.EQ.0 ) THEN 
         WORK( 1 ) = 1 
         RETURN 
      END IF 
!                                                                       
      IF( N.EQ.1 ) THEN 
         WORK( 1 ) = 26 
         IF( ALLEIG .OR. INDEIG ) THEN 
            M = 1 
            W( 1 ) = A( 1, 1 ) 
         ELSE 
            IF( VL.LT.A( 1, 1 ) .AND. VU.GE.A( 1, 1 ) ) THEN 
               M = 1 
               W( 1 ) = A( 1, 1 ) 
            END IF 
         END IF 
         IF( WANTZ ) THEN 
            Z( 1, 1 ) = ONE 
            ISUPPZ( 1 ) = 1 
            ISUPPZ( 2 ) = 1 
         END IF 
         RETURN 
      END IF 
!                                                                       
!     Get machine constants.                                            
!                                                                       
      SAFMIN = SLAMCH( 'Safe minimum' ) 
      EPS = SLAMCH( 'Precision' ) 
      SMLNUM = SAFMIN / EPS 
      BIGNUM = ONE / SMLNUM 
      RMIN = SQRT( SMLNUM ) 
      RMAX = MIN( SQRT( BIGNUM ), ONE / SQRT( SQRT( SAFMIN ) ) ) 
!                                                                       
!     Scale matrix to allowable range, if necessary.                    
!                                                                       
      ISCALE = 0 
      ABSTLL = ABSTOL 
      IF (VALEIG) THEN 
         VLL = VL 
         VUU = VU 
      END IF 
      ANRM = SLANSY( 'M', UPLO, N, A, LDA, WORK ) 
      IF( ANRM.GT.ZERO .AND. ANRM.LT.RMIN ) THEN 
         ISCALE = 1 
         SIGMA = RMIN / ANRM 
      ELSE IF( ANRM.GT.RMAX ) THEN 
         ISCALE = 1 
         SIGMA = RMAX / ANRM 
      END IF 
      IF( ISCALE.EQ.1 ) THEN 
         IF( LOWER ) THEN 
            DO 10 J = 1, N 
               CALL SSCAL( N-J+1, SIGMA, A( J, J ), 1 ) 
   10       CONTINUE 
         ELSE 
            DO 20 J = 1, N 
               CALL SSCAL( J, SIGMA, A( 1, J ), 1 ) 
   20       CONTINUE 
         END IF 
         IF( ABSTOL.GT.0 )                                              &
     &      ABSTLL = ABSTOL*SIGMA                                       
         IF( VALEIG ) THEN 
            VLL = VL*SIGMA 
            VUU = VU*SIGMA 
         END IF 
      END IF 
                                                                        
!     Initialize indices into workspaces.  Note: The IWORK indices are  
!     used only if SSTERF or SSTEMR fail.                               
                                                                        
!     WORK(INDTAU:INDTAU+N-1) stores the scalar factors of the          
!     elementary reflectors used in SSYTRD.                             
      INDTAU = 1 
!     WORK(INDD:INDD+N-1) stores the tridiagonal's diagonal entries.    
      INDD = INDTAU + N 
!     WORK(INDE:INDE+N-1) stores the off-diagonal entries of the        
!     tridiagonal matrix from SSYTRD.                                   
      INDE = INDD + N 
!     WORK(INDDD:INDDD+N-1) is a copy of the diagonal entries over      
!     -written by SSTEMR (the SSTERF path copies the diagonal to W).    
      INDDD = INDE + N 
!     WORK(INDEE:INDEE+N-1) is a copy of the off-diagonal entries over  
!     -written while computing the eigenvalues in SSTERF and SSTEMR.    
      INDEE = INDDD + N 
!     INDWK is the starting offset of the left-over workspace, and      
!     LLWORK is the remaining workspace size.                           
      INDWK = INDEE + N 
      LLWORK = LWORK - INDWK + 1 
                                                                        
!     IWORK(INDIBL:INDIBL+M-1) corresponds to IBLOCK in SSTEBZ and      
!     stores the block indices of each of the M<=N eigenvalues.         
      INDIBL = 1 
!     IWORK(INDISP:INDISP+NSPLIT-1) corresponds to ISPLIT in SSTEBZ and 
!     stores the starting and finishing indices of each block.          
      INDISP = INDIBL + N 
!     IWORK(INDIFL:INDIFL+N-1) stores the indices of eigenvectors       
!     that corresponding to eigenvectors that fail to converge in       
!     SSTEIN.  This information is discarded; if any fail, the driver   
!     returns INFO > 0.                                                 
      INDIFL = INDISP + N 
!     INDIWO is the offset of the remaining integer workspace.          
      INDIWO = INDIFL + N 
                                                                        
!                                                                       
!     Call SSYTRD to reduce symmetric matrix to tridiagonal form.       
!                                                                       
      CALL SSYTRD( UPLO, N, A, LDA, WORK( INDD ), WORK( INDE ),         &
     &             WORK( INDTAU ), WORK( INDWK ), LLWORK, IINFO )       
!                                                                       
!     If all eigenvalues are desired                                    
!     then call SSTERF or SSTEMR and SORMTR.                            
!                                                                       
      TEST = .FALSE. 
      IF( INDEIG ) THEN 
         IF( IL.EQ.1 .AND. IU.EQ.N ) THEN 
            TEST = .TRUE. 
         END IF 
      END IF 
      IF( ( ALLEIG.OR.TEST ) .AND. ( IEEEOK.EQ.1 ) ) THEN 
         IF( .NOT.WANTZ ) THEN 
            CALL SCOPY( N, WORK( INDD ), 1, W, 1 ) 
            CALL SCOPY( N-1, WORK( INDE ), 1, WORK( INDEE ), 1 ) 
            CALL SSTERF( N, W, WORK( INDEE ), INFO ) 
         ELSE 
            CALL SCOPY( N-1, WORK( INDE ), 1, WORK( INDEE ), 1 ) 
            CALL SCOPY( N, WORK( INDD ), 1, WORK( INDDD ), 1 ) 
!                                                                       
            IF (ABSTOL .LE. TWO*N*EPS) THEN 
               TRYRAC = .TRUE. 
            ELSE 
               TRYRAC = .FALSE. 
            END IF 
            CALL SSTEMR( JOBZ, 'A', N, WORK( INDDD ), WORK( INDEE ),    &
     &                   VL, VU, IL, IU, M, W, Z, LDZ, N, ISUPPZ,       &
     &                   TRYRAC, WORK( INDWK ), LWORK, IWORK, LIWORK,   &
     &                   INFO )                                         
!                                                                       
!                                                                       
!                                                                       
!        Apply orthogonal matrix used in reduction to tridiagonal       
!        form to eigenvectors returned by SSTEMR.                       
!                                                                       
            IF( WANTZ .AND. INFO.EQ.0 ) THEN 
               INDWKN = INDE 
               LLWRKN = LWORK - INDWKN + 1 
               CALL SORMTR( 'L', UPLO, 'N', N, M, A, LDA,               &
     &                      WORK( INDTAU ), Z, LDZ, WORK( INDWKN ),     &
     &                      LLWRKN, IINFO )                             
            END IF 
         END IF 
!                                                                       
!                                                                       
         IF( INFO.EQ.0 ) THEN 
!           Everything worked.  Skip SSTEBZ/SSTEIN.  IWORK(:) are       
!           undefined.                                                  
            M = N 
            GO TO 30 
         END IF 
         INFO = 0 
      END IF 
!                                                                       
!     Otherwise, call SSTEBZ and, if eigenvectors are desired, SSTEIN.  
!     Also call SSTEBZ and SSTEIN if SSTEMR fails.                      
!                                                                       
      IF( WANTZ ) THEN 
         ORDER = 'B' 
      ELSE 
         ORDER = 'E' 
      END IF 
                                                                        
      CALL SSTEBZ( RANGE, ORDER, N, VLL, VUU, IL, IU, ABSTLL,           &
     &             WORK( INDD ), WORK( INDE ), M, NSPLIT, W,            &
     &             IWORK( INDIBL ), IWORK( INDISP ), WORK( INDWK ),     &
     &             IWORK( INDIWO ), INFO )                              
!                                                                       
      IF( WANTZ ) THEN 
         CALL SSTEIN( N, WORK( INDD ), WORK( INDE ), M, W,              &
     &                IWORK( INDIBL ), IWORK( INDISP ), Z, LDZ,         &
     &                WORK( INDWK ), IWORK( INDIWO ), IWORK( INDIFL ),  &
     &                INFO )                                            
!                                                                       
!        Apply orthogonal matrix used in reduction to tridiagonal       
!        form to eigenvectors returned by SSTEIN.                       
!                                                                       
         INDWKN = INDE 
         LLWRKN = LWORK - INDWKN + 1 
         CALL SORMTR( 'L', UPLO, 'N', N, M, A, LDA, WORK( INDTAU ), Z,  &
     &                LDZ, WORK( INDWKN ), LLWRKN, IINFO )              
      END IF 
!                                                                       
!     If matrix was scaled, then rescale eigenvalues appropriately.     
!                                                                       
!  Jump here if SSTEMR/SSTEIN succeeded.                                
   30 CONTINUE 
      IF( ISCALE.EQ.1 ) THEN 
         IF( INFO.EQ.0 ) THEN 
            IMAX = M 
         ELSE 
            IMAX = INFO - 1 
         END IF 
         CALL SSCAL( IMAX, ONE / SIGMA, W, 1 ) 
      END IF 
!                                                                       
!     If eigenvalues are not in order, then sort them, along with       
!     eigenvectors.  Note: We do not sort the IFAIL portion of IWORK.   
!     It may not be initialized (if SSTEMR/SSTEIN succeeded), and we do 
!     not return this detailed information to the user.                 
!                                                                       
      IF( WANTZ ) THEN 
         DO 50 J = 1, M - 1 
            I = 0 
            TMP1 = W( J ) 
            DO 40 JJ = J + 1, M 
               IF( W( JJ ).LT.TMP1 ) THEN 
                  I = JJ 
                  TMP1 = W( JJ ) 
               END IF 
   40       CONTINUE 
!                                                                       
            IF( I.NE.0 ) THEN 
               W( I ) = W( J ) 
               W( J ) = TMP1 
               CALL SSWAP( N, Z( 1, I ), 1, Z( 1, J ), 1 ) 
            END IF 
   50    CONTINUE 
      END IF 
!                                                                       
!     Set WORK(1) to optimal workspace size.                            
!                                                                       
      WORK( 1 ) = LWKOPT 
      IWORK( 1 ) = LIWMIN 
!                                                                       
      RETURN 
!                                                                       
!     End of SSYEVR                                                     
!                                                                       
      END                                           
!> \brief \b SSYMV                                                      
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SSYMV(UPLO,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY)         
!                                                                       
!       .. Scalar Arguments ..                                          
!       REAL ALPHA,BETA                                                 
!       INTEGER INCX,INCY,LDA,N                                         
!       CHARACTER UPLO                                                  
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL A(LDA,*),X(*),Y(*)                                         
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SSYMV  performs the matrix-vector  operation                         
!>                                                                      
!>    y := alpha*A*x + beta*y,                                          
!>                                                                      
!> where alpha and beta are scalars, x and y are n element vectors and  
!> A is an n by n symmetric matrix.                                     
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] UPLO                                                      
!> \verbatim                                                            
!>          UPLO is CHARACTER*1                                         
!>           On entry, UPLO specifies whether the upper or lower        
!>           triangular part of the array A is to be referenced as      
!>           follows:                                                   
!>                                                                      
!>              UPLO = 'U' or 'u'   Only the upper triangular part of A 
!>                                  is to be referenced.                
!>                                                                      
!>              UPLO = 'L' or 'l'   Only the lower triangular part of A 
!>                                  is to be referenced.                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>           On entry, N specifies the order of the matrix A.           
!>           N must be at least zero.                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ALPHA                                                     
!> \verbatim                                                            
!>          ALPHA is REAL                                               
!>           On entry, ALPHA specifies the scalar alpha.                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is REAL array, dimension ( LDA, N )                       
!>           Before entry with  UPLO = 'U' or 'u', the leading n by n   
!>           upper triangular part of the array A must contain the upper
!>           triangular part of the symmetric matrix and the strictly   
!>           lower triangular part of A is not referenced.              
!>           Before entry with UPLO = 'L' or 'l', the leading n by n    
!>           lower triangular part of the array A must contain the lower
!>           triangular part of the symmetric matrix and the strictly   
!>           upper triangular part of A is not referenced.              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>           On entry, LDA specifies the first dimension of A as declare
!>           in the calling (sub) program. LDA must be at least         
!>           max( 1, n ).                                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] X                                                         
!> \verbatim                                                            
!>          X is REAL array, dimension at least                         
!>           ( 1 + ( n - 1 )*abs( INCX ) ).                             
!>           Before entry, the incremented array X must contain the n   
!>           element vector x.                                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCX                                                      
!> \verbatim                                                            
!>          INCX is INTEGER                                             
!>           On entry, INCX specifies the increment for the elements of 
!>           X. INCX must not be zero.                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] BETA                                                      
!> \verbatim                                                            
!>          BETA is REAL                                                
!>           On entry, BETA specifies the scalar beta. When BETA is     
!>           supplied as zero then Y need not be set on input.          
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] Y                                                     
!> \verbatim                                                            
!>          Y is REAL array, dimension at least                         
!>           ( 1 + ( n - 1 )*abs( INCY ) ).                             
!>           Before entry, the incremented array Y must contain the n   
!>           element vector y. On exit, Y is overwritten by the updated 
!>           vector y.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCY                                                      
!> \verbatim                                                            
!>          INCY is INTEGER                                             
!>           On entry, INCY specifies the increment for the elements of 
!>           Y. INCY must not be zero.                                  
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup single_blas_level2                                          
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  Level 2 Blas routine.                                               
!>  The vector and matrix arguments are not referenced when N = 0, or M 
!>                                                                      
!>  -- Written on 22-October-1986.                                      
!>     Jack Dongarra, Argonne National Lab.                             
!>     Jeremy Du Croz, Nag Central Office.                              
!>     Sven Hammarling, Nag Central Office.                             
!>     Richard Hanson, Sandia National Labs.                            
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE SSYMV(UPLO,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) 
!                                                                       
!  -- Reference BLAS level2 routine (version 3.7.0) --                  
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      REAL ALPHA,BETA 
      INTEGER INCX,INCY,LDA,N 
      CHARACTER UPLO 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL A(LDA,*),X(*),Y(*) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL ONE,ZERO 
      PARAMETER (ONE=1.0E+0,ZERO=0.0E+0) 
!     ..                                                                
!     .. Local Scalars ..                                               
      REAL TEMP1,TEMP2 
      INTEGER I,INFO,IX,IY,J,JX,JY,KX,KY 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL LSAME 
      EXTERNAL LSAME 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL XERBLA 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC MAX 
!     ..                                                                
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0 
      IF (.NOT.LSAME(UPLO,'U') .AND. .NOT.LSAME(UPLO,'L')) THEN 
          INFO = 1 
      ELSE IF (N.LT.0) THEN 
          INFO = 2 
      ELSE IF (LDA.LT.MAX(1,N)) THEN 
          INFO = 5 
      ELSE IF (INCX.EQ.0) THEN 
          INFO = 7 
      ELSE IF (INCY.EQ.0) THEN 
          INFO = 10 
      END IF 
      IF (INFO.NE.0) THEN 
          CALL XERBLA('SSYMV ',INFO) 
          RETURN 
      END IF 
!                                                                       
!     Quick return if possible.                                         
!                                                                       
      IF ((N.EQ.0) .OR. ((ALPHA.EQ.ZERO).AND. (BETA.EQ.ONE))) RETURN 
!                                                                       
!     Set up the start points in  X  and  Y.                            
!                                                                       
      IF (INCX.GT.0) THEN 
          KX = 1 
      ELSE 
          KX = 1 - (N-1)*INCX 
      END IF 
      IF (INCY.GT.0) THEN 
          KY = 1 
      ELSE 
          KY = 1 - (N-1)*INCY 
      END IF 
!                                                                       
!     Start the operations. In this version the elements of A are       
!     accessed sequentially with one pass through the triangular part   
!     of A.                                                             
!                                                                       
!     First form  y := beta*y.                                          
!                                                                       
      IF (BETA.NE.ONE) THEN 
          IF (INCY.EQ.1) THEN 
              IF (BETA.EQ.ZERO) THEN 
                  DO 10 I = 1,N 
                      Y(I) = ZERO 
   10             CONTINUE 
              ELSE 
                  DO 20 I = 1,N 
                      Y(I) = BETA*Y(I) 
   20             CONTINUE 
              END IF 
          ELSE 
              IY = KY 
              IF (BETA.EQ.ZERO) THEN 
                  DO 30 I = 1,N 
                      Y(IY) = ZERO 
                      IY = IY + INCY 
   30             CONTINUE 
              ELSE 
                  DO 40 I = 1,N 
                      Y(IY) = BETA*Y(IY) 
                      IY = IY + INCY 
   40             CONTINUE 
              END IF 
          END IF 
      END IF 
      IF (ALPHA.EQ.ZERO) RETURN 
      IF (LSAME(UPLO,'U')) THEN 
!                                                                       
!        Form  y  when A is stored in upper triangle.                   
!                                                                       
          IF ((INCX.EQ.1) .AND. (INCY.EQ.1)) THEN 
              DO 60 J = 1,N 
                  TEMP1 = ALPHA*X(J) 
                  TEMP2 = ZERO 
                  DO 50 I = 1,J - 1 
                      Y(I) = Y(I) + TEMP1*A(I,J) 
                      TEMP2 = TEMP2 + A(I,J)*X(I) 
   50             CONTINUE 
                  Y(J) = Y(J) + TEMP1*A(J,J) + ALPHA*TEMP2 
   60         CONTINUE 
          ELSE 
              JX = KX 
              JY = KY 
              DO 80 J = 1,N 
                  TEMP1 = ALPHA*X(JX) 
                  TEMP2 = ZERO 
                  IX = KX 
                  IY = KY 
                  DO 70 I = 1,J - 1 
                      Y(IY) = Y(IY) + TEMP1*A(I,J) 
                      TEMP2 = TEMP2 + A(I,J)*X(IX) 
                      IX = IX + INCX 
                      IY = IY + INCY 
   70             CONTINUE 
                  Y(JY) = Y(JY) + TEMP1*A(J,J) + ALPHA*TEMP2 
                  JX = JX + INCX 
                  JY = JY + INCY 
   80         CONTINUE 
          END IF 
      ELSE 
!                                                                       
!        Form  y  when A is stored in lower triangle.                   
!                                                                       
          IF ((INCX.EQ.1) .AND. (INCY.EQ.1)) THEN 
              DO 100 J = 1,N 
                  TEMP1 = ALPHA*X(J) 
                  TEMP2 = ZERO 
                  Y(J) = Y(J) + TEMP1*A(J,J) 
                  DO 90 I = J + 1,N 
                      Y(I) = Y(I) + TEMP1*A(I,J) 
                      TEMP2 = TEMP2 + A(I,J)*X(I) 
   90             CONTINUE 
                  Y(J) = Y(J) + ALPHA*TEMP2 
  100         CONTINUE 
          ELSE 
              JX = KX 
              JY = KY 
              DO 120 J = 1,N 
                  TEMP1 = ALPHA*X(JX) 
                  TEMP2 = ZERO 
                  Y(JY) = Y(JY) + TEMP1*A(J,J) 
                  IX = JX 
                  IY = JY 
                  DO 110 I = J + 1,N 
                      IX = IX + INCX 
                      IY = IY + INCY 
                      Y(IY) = Y(IY) + TEMP1*A(I,J) 
                      TEMP2 = TEMP2 + A(I,J)*X(IX) 
  110             CONTINUE 
                  Y(JY) = Y(JY) + ALPHA*TEMP2 
                  JX = JX + INCX 
                  JY = JY + INCY 
  120         CONTINUE 
          END IF 
      END IF 
!                                                                       
      RETURN 
!                                                                       
!     End of SSYMV .                                                    
!                                                                       
      END                                           
!> \brief \b SSYR2                                                      
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SSYR2(UPLO,N,ALPHA,X,INCX,Y,INCY,A,LDA)              
!                                                                       
!       .. Scalar Arguments ..                                          
!       REAL ALPHA                                                      
!       INTEGER INCX,INCY,LDA,N                                         
!       CHARACTER UPLO                                                  
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL A(LDA,*),X(*),Y(*)                                         
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SSYR2  performs the symmetric rank 2 operation                       
!>                                                                      
!>    A := alpha*x*y**T + alpha*y*x**T + A,                             
!>                                                                      
!> where alpha is a scalar, x and y are n element vectors and A is an n 
!> by n symmetric matrix.                                               
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] UPLO                                                      
!> \verbatim                                                            
!>          UPLO is CHARACTER*1                                         
!>           On entry, UPLO specifies whether the upper or lower        
!>           triangular part of the array A is to be referenced as      
!>           follows:                                                   
!>                                                                      
!>              UPLO = 'U' or 'u'   Only the upper triangular part of A 
!>                                  is to be referenced.                
!>                                                                      
!>              UPLO = 'L' or 'l'   Only the lower triangular part of A 
!>                                  is to be referenced.                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>           On entry, N specifies the order of the matrix A.           
!>           N must be at least zero.                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ALPHA                                                     
!> \verbatim                                                            
!>          ALPHA is REAL                                               
!>           On entry, ALPHA specifies the scalar alpha.                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] X                                                         
!> \verbatim                                                            
!>          X is REAL array, dimension at least                         
!>           ( 1 + ( n - 1 )*abs( INCX ) ).                             
!>           Before entry, the incremented array X must contain the n   
!>           element vector x.                                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCX                                                      
!> \verbatim                                                            
!>          INCX is INTEGER                                             
!>           On entry, INCX specifies the increment for the elements of 
!>           X. INCX must not be zero.                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] Y                                                         
!> \verbatim                                                            
!>          Y is REAL array, dimension at least                         
!>           ( 1 + ( n - 1 )*abs( INCY ) ).                             
!>           Before entry, the incremented array Y must contain the n   
!>           element vector y.                                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCY                                                      
!> \verbatim                                                            
!>          INCY is INTEGER                                             
!>           On entry, INCY specifies the increment for the elements of 
!>           Y. INCY must not be zero.                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] A                                                     
!> \verbatim                                                            
!>          A is REAL array, dimension ( LDA, N )                       
!>           Before entry with  UPLO = 'U' or 'u', the leading n by n   
!>           upper triangular part of the array A must contain the upper
!>           triangular part of the symmetric matrix and the strictly   
!>           lower triangular part of A is not referenced. On exit, the 
!>           upper triangular part of the array A is overwritten by the 
!>           upper triangular part of the updated matrix.               
!>           Before entry with UPLO = 'L' or 'l', the leading n by n    
!>           lower triangular part of the array A must contain the lower
!>           triangular part of the symmetric matrix and the strictly   
!>           upper triangular part of A is not referenced. On exit, the 
!>           lower triangular part of the array A is overwritten by the 
!>           lower triangular part of the updated matrix.               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>           On entry, LDA specifies the first dimension of A as declare
!>           in the calling (sub) program. LDA must be at least         
!>           max( 1, n ).                                               
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup single_blas_level2                                          
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  Level 2 Blas routine.                                               
!>                                                                      
!>  -- Written on 22-October-1986.                                      
!>     Jack Dongarra, Argonne National Lab.                             
!>     Jeremy Du Croz, Nag Central Office.                              
!>     Sven Hammarling, Nag Central Office.                             
!>     Richard Hanson, Sandia National Labs.                            
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE SSYR2(UPLO,N,ALPHA,X,INCX,Y,INCY,A,LDA) 
!                                                                       
!  -- Reference BLAS level2 routine (version 3.7.0) --                  
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      REAL ALPHA 
      INTEGER INCX,INCY,LDA,N 
      CHARACTER UPLO 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL A(LDA,*),X(*),Y(*) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL ZERO 
      PARAMETER (ZERO=0.0E+0) 
!     ..                                                                
!     .. Local Scalars ..                                               
      REAL TEMP1,TEMP2 
      INTEGER I,INFO,IX,IY,J,JX,JY,KX,KY 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL LSAME 
      EXTERNAL LSAME 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL XERBLA 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC MAX 
!     ..                                                                
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0 
      IF (.NOT.LSAME(UPLO,'U') .AND. .NOT.LSAME(UPLO,'L')) THEN 
          INFO = 1 
      ELSE IF (N.LT.0) THEN 
          INFO = 2 
      ELSE IF (INCX.EQ.0) THEN 
          INFO = 5 
      ELSE IF (INCY.EQ.0) THEN 
          INFO = 7 
      ELSE IF (LDA.LT.MAX(1,N)) THEN 
          INFO = 9 
      END IF 
      IF (INFO.NE.0) THEN 
          CALL XERBLA('SSYR2 ',INFO) 
          RETURN 
      END IF 
!                                                                       
!     Quick return if possible.                                         
!                                                                       
      IF ((N.EQ.0) .OR. (ALPHA.EQ.ZERO)) RETURN 
!                                                                       
!     Set up the start points in X and Y if the increments are not both 
!     unity.                                                            
!                                                                       
      IF ((INCX.NE.1) .OR. (INCY.NE.1)) THEN 
          IF (INCX.GT.0) THEN 
              KX = 1 
          ELSE 
              KX = 1 - (N-1)*INCX 
          END IF 
          IF (INCY.GT.0) THEN 
              KY = 1 
          ELSE 
              KY = 1 - (N-1)*INCY 
          END IF 
          JX = KX 
          JY = KY 
      END IF 
!                                                                       
!     Start the operations. In this version the elements of A are       
!     accessed sequentially with one pass through the triangular part   
!     of A.                                                             
!                                                                       
      IF (LSAME(UPLO,'U')) THEN 
!                                                                       
!        Form  A  when A is stored in the upper triangle.               
!                                                                       
          IF ((INCX.EQ.1) .AND. (INCY.EQ.1)) THEN 
              DO 20 J = 1,N 
                  IF ((X(J).NE.ZERO) .OR. (Y(J).NE.ZERO)) THEN 
                      TEMP1 = ALPHA*Y(J) 
                      TEMP2 = ALPHA*X(J) 
                      DO 10 I = 1,J 
                          A(I,J) = A(I,J) + X(I)*TEMP1 + Y(I)*TEMP2 
   10                 CONTINUE 
                  END IF 
   20         CONTINUE 
          ELSE 
              DO 40 J = 1,N 
                  IF ((X(JX).NE.ZERO) .OR. (Y(JY).NE.ZERO)) THEN 
                      TEMP1 = ALPHA*Y(JY) 
                      TEMP2 = ALPHA*X(JX) 
                      IX = KX 
                      IY = KY 
                      DO 30 I = 1,J 
                          A(I,J) = A(I,J) + X(IX)*TEMP1 + Y(IY)*TEMP2 
                          IX = IX + INCX 
                          IY = IY + INCY 
   30                 CONTINUE 
                  END IF 
                  JX = JX + INCX 
                  JY = JY + INCY 
   40         CONTINUE 
          END IF 
      ELSE 
!                                                                       
!        Form  A  when A is stored in the lower triangle.               
!                                                                       
          IF ((INCX.EQ.1) .AND. (INCY.EQ.1)) THEN 
              DO 60 J = 1,N 
                  IF ((X(J).NE.ZERO) .OR. (Y(J).NE.ZERO)) THEN 
                      TEMP1 = ALPHA*Y(J) 
                      TEMP2 = ALPHA*X(J) 
                      DO 50 I = J,N 
                          A(I,J) = A(I,J) + X(I)*TEMP1 + Y(I)*TEMP2 
   50                 CONTINUE 
                  END IF 
   60         CONTINUE 
          ELSE 
              DO 80 J = 1,N 
                  IF ((X(JX).NE.ZERO) .OR. (Y(JY).NE.ZERO)) THEN 
                      TEMP1 = ALPHA*Y(JY) 
                      TEMP2 = ALPHA*X(JX) 
                      IX = JX 
                      IY = JY 
                      DO 70 I = J,N 
                          A(I,J) = A(I,J) + X(IX)*TEMP1 + Y(IY)*TEMP2 
                          IX = IX + INCX 
                          IY = IY + INCY 
   70                 CONTINUE 
                  END IF 
                  JX = JX + INCX 
                  JY = JY + INCY 
   80         CONTINUE 
          END IF 
      END IF 
!                                                                       
      RETURN 
!                                                                       
!     End of SSYR2 .                                                    
!                                                                       
      END                                           
!> \brief \b SSYR2K                                                     
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SSYR2K(UPLO,TRANS,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC)  
!                                                                       
!       .. Scalar Arguments ..                                          
!       REAL ALPHA,BETA                                                 
!       INTEGER K,LDA,LDB,LDC,N                                         
!       CHARACTER TRANS,UPLO                                            
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL A(LDA,*),B(LDB,*),C(LDC,*)                                 
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SSYR2K  performs one of the symmetric rank 2k operations             
!>                                                                      
!>    C := alpha*A*B**T + alpha*B*A**T + beta*C,                        
!>                                                                      
!> or                                                                   
!>                                                                      
!>    C := alpha*A**T*B + alpha*B**T*A + beta*C,                        
!>                                                                      
!> where  alpha and beta  are scalars, C is an  n by n  symmetric matrix
!> and  A and B  are  n by k  matrices  in the  first  case  and  k by n
!> matrices in the second case.                                         
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] UPLO                                                      
!> \verbatim                                                            
!>          UPLO is CHARACTER*1                                         
!>           On  entry,   UPLO  specifies  whether  the  upper  or  lowe
!>           triangular  part  of the  array  C  is to be  referenced  a
!>           follows:                                                   
!>                                                                      
!>              UPLO = 'U' or 'u'   Only the  upper triangular part of  
!>                                  is to be referenced.                
!>                                                                      
!>              UPLO = 'L' or 'l'   Only the  lower triangular part of  
!>                                  is to be referenced.                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TRANS                                                     
!> \verbatim                                                            
!>          TRANS is CHARACTER*1                                        
!>           On entry,  TRANS  specifies the operation to be performed a
!>           follows:                                                   
!>                                                                      
!>              TRANS = 'N' or 'n'   C := alpha*A*B**T + alpha*B*A**T + 
!>                                        beta*C.                       
!>                                                                      
!>              TRANS = 'T' or 't'   C := alpha*A**T*B + alpha*B**T*A + 
!>                                        beta*C.                       
!>                                                                      
!>              TRANS = 'C' or 'c'   C := alpha*A**T*B + alpha*B**T*A + 
!>                                        beta*C.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>           On entry,  N specifies the order of the matrix C.  N must b
!>           at least zero.                                             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] K                                                         
!> \verbatim                                                            
!>          K is INTEGER                                                
!>           On entry with  TRANS = 'N' or 'n',  K  specifies  the numbe
!>           of  columns  of the  matrices  A and B,  and on  entry  wit
!>           TRANS = 'T' or 't' or 'C' or 'c',  K  specifies  the  numbe
!>           of rows of the matrices  A and B.  K must be at least  zero
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ALPHA                                                     
!> \verbatim                                                            
!>          ALPHA is REAL                                               
!>           On entry, ALPHA specifies the scalar alpha.                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is REAL array, dimension ( LDA, ka ), where ka is         
!>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise.        
!>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by 
!>           part of the array  A  must contain the matrix  A,  otherwis
!>           the leading  k by n  part of the array  A  must contain  th
!>           matrix A.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>           On entry, LDA specifies the first dimension of A as declare
!>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n
!>           then  LDA must be at least  max( 1, n ), otherwise  LDA mus
!>           be at least  max( 1, k ).                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] B                                                         
!> \verbatim                                                            
!>          B is REAL array, dimension ( LDB, kb ), where kb is         
!>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise.        
!>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by 
!>           part of the array  B  must contain the matrix  B,  otherwis
!>           the leading  k by n  part of the array  B  must contain  th
!>           matrix B.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDB                                                       
!> \verbatim                                                            
!>          LDB is INTEGER                                              
!>           On entry, LDB specifies the first dimension of B as declare
!>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n
!>           then  LDB must be at least  max( 1, n ), otherwise  LDB mus
!>           be at least  max( 1, k ).                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] BETA                                                      
!> \verbatim                                                            
!>          BETA is REAL                                                
!>           On entry, BETA specifies the scalar beta.                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] C                                                     
!> \verbatim                                                            
!>          C is REAL array, dimension ( LDC, N )                       
!>           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
!>           upper triangular part of the array C must contain the upper
!>           triangular part  of the  symmetric matrix  and the strictly
!>           lower triangular part of C is not referenced.  On exit, the
!>           upper triangular part of the array  C is overwritten by the
!>           upper triangular part of the updated matrix.               
!>           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
!>           lower triangular part of the array C must contain the lower
!>           triangular part  of the  symmetric matrix  and the strictly
!>           upper triangular part of C is not referenced.  On exit, the
!>           lower triangular part of the array  C is overwritten by the
!>           lower triangular part of the updated matrix.               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDC                                                       
!> \verbatim                                                            
!>          LDC is INTEGER                                              
!>           On entry, LDC specifies the first dimension of C as declare
!>           in  the  calling  (sub)  program.   LDC  must  be  at  leas
!>           max( 1, n ).                                               
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup single_blas_level3                                          
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  Level 3 Blas routine.                                               
!>                                                                      
!>                                                                      
!>  -- Written on 8-February-1989.                                      
!>     Jack Dongarra, Argonne National Laboratory.                      
!>     Iain Duff, AERE Harwell.                                         
!>     Jeremy Du Croz, Numerical Algorithms Group Ltd.                  
!>     Sven Hammarling, Numerical Algorithms Group Ltd.                 
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE SSYR2K(UPLO,TRANS,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC) 
!                                                                       
!  -- Reference BLAS level3 routine (version 3.7.0) --                  
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      REAL ALPHA,BETA 
      INTEGER K,LDA,LDB,LDC,N 
      CHARACTER TRANS,UPLO 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL A(LDA,*),B(LDB,*),C(LDC,*) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. External Functions ..                                          
      LOGICAL LSAME 
      EXTERNAL LSAME 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL XERBLA 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC MAX 
!     ..                                                                
!     .. Local Scalars ..                                               
      REAL TEMP1,TEMP2 
      INTEGER I,INFO,J,L,NROWA 
      LOGICAL UPPER 
!     ..                                                                
!     .. Parameters ..                                                  
      REAL ONE,ZERO 
      PARAMETER (ONE=1.0E+0,ZERO=0.0E+0) 
!     ..                                                                
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      IF (LSAME(TRANS,'N')) THEN 
          NROWA = N 
      ELSE 
          NROWA = K 
      END IF 
      UPPER = LSAME(UPLO,'U') 
!                                                                       
      INFO = 0 
      IF ((.NOT.UPPER) .AND. (.NOT.LSAME(UPLO,'L'))) THEN 
          INFO = 1 
      ELSE IF ((.NOT.LSAME(TRANS,'N')) .AND.                            &
     &         (.NOT.LSAME(TRANS,'T')) .AND.                            &
     &         (.NOT.LSAME(TRANS,'C'))) THEN                            
          INFO = 2 
      ELSE IF (N.LT.0) THEN 
          INFO = 3 
      ELSE IF (K.LT.0) THEN 
          INFO = 4 
      ELSE IF (LDA.LT.MAX(1,NROWA)) THEN 
          INFO = 7 
      ELSE IF (LDB.LT.MAX(1,NROWA)) THEN 
          INFO = 9 
      ELSE IF (LDC.LT.MAX(1,N)) THEN 
          INFO = 12 
      END IF 
      IF (INFO.NE.0) THEN 
          CALL XERBLA('SSYR2K',INFO) 
          RETURN 
      END IF 
!                                                                       
!     Quick return if possible.                                         
!                                                                       
      IF ((N.EQ.0) .OR. (((ALPHA.EQ.ZERO).OR.                           &
     &    (K.EQ.0)).AND. (BETA.EQ.ONE))) RETURN                         
!                                                                       
!     And when  alpha.eq.zero.                                          
!                                                                       
      IF (ALPHA.EQ.ZERO) THEN 
          IF (UPPER) THEN 
              IF (BETA.EQ.ZERO) THEN 
                  DO 20 J = 1,N 
                      DO 10 I = 1,J 
                          C(I,J) = ZERO 
   10                 CONTINUE 
   20             CONTINUE 
              ELSE 
                  DO 40 J = 1,N 
                      DO 30 I = 1,J 
                          C(I,J) = BETA*C(I,J) 
   30                 CONTINUE 
   40             CONTINUE 
              END IF 
          ELSE 
              IF (BETA.EQ.ZERO) THEN 
                  DO 60 J = 1,N 
                      DO 50 I = J,N 
                          C(I,J) = ZERO 
   50                 CONTINUE 
   60             CONTINUE 
              ELSE 
                  DO 80 J = 1,N 
                      DO 70 I = J,N 
                          C(I,J) = BETA*C(I,J) 
   70                 CONTINUE 
   80             CONTINUE 
              END IF 
          END IF 
          RETURN 
      END IF 
!                                                                       
!     Start the operations.                                             
!                                                                       
      IF (LSAME(TRANS,'N')) THEN 
!                                                                       
!        Form  C := alpha*A*B**T + alpha*B*A**T + C.                    
!                                                                       
          IF (UPPER) THEN 
              DO 130 J = 1,N 
                  IF (BETA.EQ.ZERO) THEN 
                      DO 90 I = 1,J 
                          C(I,J) = ZERO 
   90                 CONTINUE 
                  ELSE IF (BETA.NE.ONE) THEN 
                      DO 100 I = 1,J 
                          C(I,J) = BETA*C(I,J) 
  100                 CONTINUE 
                  END IF 
                  DO 120 L = 1,K 
                      IF ((A(J,L).NE.ZERO) .OR. (B(J,L).NE.ZERO)) THEN 
                          TEMP1 = ALPHA*B(J,L) 
                          TEMP2 = ALPHA*A(J,L) 
                          DO 110 I = 1,J 
                              C(I,J) = C(I,J) + A(I,L)*TEMP1 +          &
     &                                 B(I,L)*TEMP2                     
  110                     CONTINUE 
                      END IF 
  120             CONTINUE 
  130         CONTINUE 
          ELSE 
              DO 180 J = 1,N 
                  IF (BETA.EQ.ZERO) THEN 
                      DO 140 I = J,N 
                          C(I,J) = ZERO 
  140                 CONTINUE 
                  ELSE IF (BETA.NE.ONE) THEN 
                      DO 150 I = J,N 
                          C(I,J) = BETA*C(I,J) 
  150                 CONTINUE 
                  END IF 
                  DO 170 L = 1,K 
                      IF ((A(J,L).NE.ZERO) .OR. (B(J,L).NE.ZERO)) THEN 
                          TEMP1 = ALPHA*B(J,L) 
                          TEMP2 = ALPHA*A(J,L) 
                          DO 160 I = J,N 
                              C(I,J) = C(I,J) + A(I,L)*TEMP1 +          &
     &                                 B(I,L)*TEMP2                     
  160                     CONTINUE 
                      END IF 
  170             CONTINUE 
  180         CONTINUE 
          END IF 
      ELSE 
!                                                                       
!        Form  C := alpha*A**T*B + alpha*B**T*A + C.                    
!                                                                       
          IF (UPPER) THEN 
              DO 210 J = 1,N 
                  DO 200 I = 1,J 
                      TEMP1 = ZERO 
                      TEMP2 = ZERO 
                      DO 190 L = 1,K 
                          TEMP1 = TEMP1 + A(L,I)*B(L,J) 
                          TEMP2 = TEMP2 + B(L,I)*A(L,J) 
  190                 CONTINUE 
                      IF (BETA.EQ.ZERO) THEN 
                          C(I,J) = ALPHA*TEMP1 + ALPHA*TEMP2 
                      ELSE 
                          C(I,J) = BETA*C(I,J) + ALPHA*TEMP1 +          &
     &                             ALPHA*TEMP2                          
                      END IF 
  200             CONTINUE 
  210         CONTINUE 
          ELSE 
              DO 240 J = 1,N 
                  DO 230 I = J,N 
                      TEMP1 = ZERO 
                      TEMP2 = ZERO 
                      DO 220 L = 1,K 
                          TEMP1 = TEMP1 + A(L,I)*B(L,J) 
                          TEMP2 = TEMP2 + B(L,I)*A(L,J) 
  220                 CONTINUE 
                      IF (BETA.EQ.ZERO) THEN 
                          C(I,J) = ALPHA*TEMP1 + ALPHA*TEMP2 
                      ELSE 
                          C(I,J) = BETA*C(I,J) + ALPHA*TEMP1 +          &
     &                             ALPHA*TEMP2                          
                      END IF 
  230             CONTINUE 
  240         CONTINUE 
          END IF 
      END IF 
!                                                                       
      RETURN 
!                                                                       
!     End of SSYR2K.                                                    
!                                                                       
      END                                           
!> \brief \b SSYTD2 reduces a symmetric matrix to real symmetric tridiag
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SSYTD2 + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SSYTD2( UPLO, N, A, LDA, D, E, TAU, INFO )           
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          UPLO                                         
!       INTEGER            INFO, LDA, N                                 
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL               A( LDA, * ), D( * ), E( * ), TAU( * )        
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SSYTD2 reduces a real symmetric matrix A to symmetric tridiagonal    
!> form T by an orthogonal similarity transformation: Q**T * A * Q = T. 
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] UPLO                                                      
!> \verbatim                                                            
!>          UPLO is CHARACTER*1                                         
!>          Specifies whether the upper or lower triangular part of the 
!>          symmetric matrix A is stored:                               
!>          = 'U':  Upper triangular                                    
!>          = 'L':  Lower triangular                                    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix A.  N >= 0.                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] A                                                     
!> \verbatim                                                            
!>          A is REAL array, dimension (LDA,N)                          
!>          On entry, the symmetric matrix A.  If UPLO = 'U', the leadin
!>          n-by-n upper triangular part of A contains the upper        
!>          triangular part of the matrix A, and the strictly lower     
!>          triangular part of A is not referenced.  If UPLO = 'L', the 
!>          leading n-by-n lower triangular part of A contains the lower
!>          triangular part of the matrix A, and the strictly upper     
!>          triangular part of A is not referenced.                     
!>          On exit, if UPLO = 'U', the diagonal and first superdiagonal
!>          of A are overwritten by the corresponding elements of the   
!>          tridiagonal matrix T, and the elements above the first      
!>          superdiagonal, with the array TAU, represent the orthogonal 
!>          matrix Q as a product of elementary reflectors; if UPLO     
!>          = 'L', the diagonal and first subdiagonal of A are over-    
!>          written by the corresponding elements of the tridiagonal    
!>          matrix T, and the elements below the first subdiagonal, with
!>          the array TAU, represent the orthogonal matrix Q as a produc
!>          of elementary reflectors. See Further Details.              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>          The leading dimension of the array A.  LDA >= max(1,N).     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] D                                                        
!> \verbatim                                                            
!>          D is REAL array, dimension (N)                              
!>          The diagonal elements of the tridiagonal matrix T:          
!>          D(i) = A(i,i).                                              
!> \endverbatim                                                         
!>                                                                      
!> \param[out] E                                                        
!> \verbatim                                                            
!>          E is REAL array, dimension (N-1)                            
!>          The off-diagonal elements of the tridiagonal matrix T:      
!>          E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'
!> \endverbatim                                                         
!>                                                                      
!> \param[out] TAU                                                      
!> \verbatim                                                            
!>          TAU is REAL array, dimension (N-1)                          
!>          The scalar factors of the elementary reflectors (see Further
!>          Details).                                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0:  successful exit                                       
!>          < 0:  if INFO = -i, the i-th argument had an illegal value. 
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup realSYcomputational                                         
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  If UPLO = 'U', the matrix Q is represented as a product of elementar
!>  reflectors                                                          
!>                                                                      
!>     Q = H(n-1) . . . H(2) H(1).                                      
!>                                                                      
!>  Each H(i) has the form                                              
!>                                                                      
!>     H(i) = I - tau * v * v**T                                        
!>                                                                      
!>  where tau is a real scalar, and v is a real vector with             
!>  v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in            
!>  A(1:i-1,i+1), and tau in TAU(i).                                    
!>                                                                      
!>  If UPLO = 'L', the matrix Q is represented as a product of elementar
!>  reflectors                                                          
!>                                                                      
!>     Q = H(1) H(2) . . . H(n-1).                                      
!>                                                                      
!>  Each H(i) has the form                                              
!>                                                                      
!>     H(i) = I - tau * v * v**T                                        
!>                                                                      
!>  where tau is a real scalar, and v is a real vector with             
!>  v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
!>  and tau in TAU(i).                                                  
!>                                                                      
!>  The contents of A on exit are illustrated by the following examples 
!>  with n = 5:                                                         
!>                                                                      
!>  if UPLO = 'U':                       if UPLO = 'L':                 
!>                                                                      
!>    (  d   e   v2  v3  v4 )              (  d                  )      
!>    (      d   e   v3  v4 )              (  e   d              )      
!>    (          d   e   v4 )              (  v1  e   d          )      
!>    (              d   e  )              (  v1  v2  e   d      )      
!>    (                  d  )              (  v1  v2  v3  e   d  )      
!>                                                                      
!>  where d and e denote diagonal and off-diagonal elements of T, and vi
!>  denotes an element of the vector defining H(i).                     
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE SSYTD2( UPLO, N, A, LDA, D, E, TAU, INFO ) 
!                                                                       
!  -- LAPACK computational routine (version 3.7.0) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          UPLO 
      INTEGER            INFO, LDA, N 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               A( LDA, * ), D( * ), E( * ), TAU( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ONE, ZERO, HALF 
      PARAMETER          ( ONE = 1.0, ZERO = 0.0, HALF = 1.0 / 2.0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            UPPER 
      INTEGER            I 
      REAL               ALPHA, TAUI 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           SAXPY, SLARFG, SSYMV, SSYR2, XERBLA 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      REAL               SDOT 
      EXTERNAL           LSAME, SDOT 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX, MIN 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters                                         
!                                                                       
      INFO = 0 
      UPPER = LSAME( UPLO, 'U' ) 
      IF( .NOT.UPPER .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN 
         INFO = -1 
      ELSE IF( N.LT.0 ) THEN 
         INFO = -2 
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN 
         INFO = -4 
      END IF 
      IF( INFO.NE.0 ) THEN 
         CALL XERBLA( 'SSYTD2', -INFO ) 
         RETURN 
      END IF 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.LE.0 )                                                      &
     &   RETURN                                                         
!                                                                       
      IF( UPPER ) THEN 
!                                                                       
!        Reduce the upper triangle of A                                 
!                                                                       
         DO 10 I = N - 1, 1, -1 
!                                                                       
!           Generate elementary reflector H(i) = I - tau * v * v**T     
!           to annihilate A(1:i-1,i+1)                                  
!                                                                       
            CALL SLARFG( I, A( I, I+1 ), A( 1, I+1 ), 1, TAUI ) 
            E( I ) = A( I, I+1 ) 
!                                                                       
            IF( TAUI.NE.ZERO ) THEN 
!                                                                       
!              Apply H(i) from both sides to A(1:i,1:i)                 
!                                                                       
               A( I, I+1 ) = ONE 
!                                                                       
!              Compute  x := tau * A * v  storing x in TAU(1:i)         
!                                                                       
               CALL SSYMV( UPLO, I, TAUI, A, LDA, A( 1, I+1 ), 1, ZERO, &
     &                     TAU, 1 )                                     
!                                                                       
!              Compute  w := x - 1/2 * tau * (x**T * v) * v             
!                                                                       
               ALPHA = -HALF*TAUI*SDOT( I, TAU, 1, A( 1, I+1 ), 1 ) 
               CALL SAXPY( I, ALPHA, A( 1, I+1 ), 1, TAU, 1 ) 
!                                                                       
!              Apply the transformation as a rank-2 update:             
!                 A := A - v * w**T - w * v**T                          
!                                                                       
               CALL SSYR2( UPLO, I, -ONE, A( 1, I+1 ), 1, TAU, 1, A,    &
     &                     LDA )                                        
!                                                                       
               A( I, I+1 ) = E( I ) 
            END IF 
            D( I+1 ) = A( I+1, I+1 ) 
            TAU( I ) = TAUI 
   10    CONTINUE 
         D( 1 ) = A( 1, 1 ) 
      ELSE 
!                                                                       
!        Reduce the lower triangle of A                                 
!                                                                       
         DO 20 I = 1, N - 1 
!                                                                       
!           Generate elementary reflector H(i) = I - tau * v * v**T     
!           to annihilate A(i+2:n,i)                                    
!                                                                       
            CALL SLARFG( N-I, A( I+1, I ), A( MIN( I+2, N ), I ), 1,    &
     &                   TAUI )                                         
            E( I ) = A( I+1, I ) 
!                                                                       
            IF( TAUI.NE.ZERO ) THEN 
!                                                                       
!              Apply H(i) from both sides to A(i+1:n,i+1:n)             
!                                                                       
               A( I+1, I ) = ONE 
!                                                                       
!              Compute  x := tau * A * v  storing y in TAU(i:n-1)       
!                                                                       
               CALL SSYMV( UPLO, N-I, TAUI, A( I+1, I+1 ), LDA,         &
     &                     A( I+1, I ), 1, ZERO, TAU( I ), 1 )          
!                                                                       
!              Compute  w := x - 1/2 * tau * (x**T * v) * v             
!                                                                       
               ALPHA = -HALF*TAUI*SDOT( N-I, TAU( I ), 1, A( I+1, I ),  &
     &                 1 )                                              
               CALL SAXPY( N-I, ALPHA, A( I+1, I ), 1, TAU( I ), 1 ) 
!                                                                       
!              Apply the transformation as a rank-2 update:             
!                 A := A - v * w**T - w * v**T                          
!                                                                       
               CALL SSYR2( UPLO, N-I, -ONE, A( I+1, I ), 1, TAU( I ), 1,&
     &                     A( I+1, I+1 ), LDA )                         
!                                                                       
               A( I+1, I ) = E( I ) 
            END IF 
            D( I ) = A( I, I ) 
            TAU( I ) = TAUI 
   20    CONTINUE 
         D( N ) = A( N, N ) 
      END IF 
!                                                                       
      RETURN 
!                                                                       
!     End of SSYTD2                                                     
!                                                                       
      END                                           
!> \brief \b SSYTRD                                                     
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download SSYTRD + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE SSYTRD( UPLO, N, A, LDA, D, E, TAU, WORK, LWORK, INFO
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          UPLO                                         
!       INTEGER            INFO, LDA, LWORK, N                          
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL               A( LDA, * ), D( * ), E( * ), TAU( * ),       
!      $                   WORK( * )                                    
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SSYTRD reduces a real symmetric matrix A to real symmetric           
!> tridiagonal form T by an orthogonal similarity transformation:       
!> Q**T * A * Q = T.                                                    
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] UPLO                                                      
!> \verbatim                                                            
!>          UPLO is CHARACTER*1                                         
!>          = 'U':  Upper triangle of A is stored;                      
!>          = 'L':  Lower triangle of A is stored.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix A.  N >= 0.                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] A                                                     
!> \verbatim                                                            
!>          A is REAL array, dimension (LDA,N)                          
!>          On entry, the symmetric matrix A.  If UPLO = 'U', the leadin
!>          N-by-N upper triangular part of A contains the upper        
!>          triangular part of the matrix A, and the strictly lower     
!>          triangular part of A is not referenced.  If UPLO = 'L', the 
!>          leading N-by-N lower triangular part of A contains the lower
!>          triangular part of the matrix A, and the strictly upper     
!>          triangular part of A is not referenced.                     
!>          On exit, if UPLO = 'U', the diagonal and first superdiagonal
!>          of A are overwritten by the corresponding elements of the   
!>          tridiagonal matrix T, and the elements above the first      
!>          superdiagonal, with the array TAU, represent the orthogonal 
!>          matrix Q as a product of elementary reflectors; if UPLO     
!>          = 'L', the diagonal and first subdiagonal of A are over-    
!>          written by the corresponding elements of the tridiagonal    
!>          matrix T, and the elements below the first subdiagonal, with
!>          the array TAU, represent the orthogonal matrix Q as a produc
!>          of elementary reflectors. See Further Details.              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>          The leading dimension of the array A.  LDA >= max(1,N).     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] D                                                        
!> \verbatim                                                            
!>          D is REAL array, dimension (N)                              
!>          The diagonal elements of the tridiagonal matrix T:          
!>          D(i) = A(i,i).                                              
!> \endverbatim                                                         
!>                                                                      
!> \param[out] E                                                        
!> \verbatim                                                            
!>          E is REAL array, dimension (N-1)                            
!>          The off-diagonal elements of the tridiagonal matrix T:      
!>          E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'
!> \endverbatim                                                         
!>                                                                      
!> \param[out] TAU                                                      
!> \verbatim                                                            
!>          TAU is REAL array, dimension (N-1)                          
!>          The scalar factors of the elementary reflectors (see Further
!>          Details).                                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is REAL array, dimension (MAX(1,LWORK))                
!>          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LWORK                                                     
!> \verbatim                                                            
!>          LWORK is INTEGER                                            
!>          The dimension of the array WORK.  LWORK >= 1.               
!>          For optimum performance LWORK >= N*NB, where NB is the      
!>          optimal blocksize.                                          
!>                                                                      
!>          If LWORK = -1, then a workspace query is assumed; the routin
!>          only calculates the optimal size of the WORK array, returns 
!>          this value as the first entry of the WORK array, and no erro
!>          message related to LWORK is issued by XERBLA.               
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0:  successful exit                                       
!>          < 0:  if INFO = -i, the i-th argument had an illegal value  
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup realSYcomputational                                         
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  If UPLO = 'U', the matrix Q is represented as a product of elementar
!>  reflectors                                                          
!>                                                                      
!>     Q = H(n-1) . . . H(2) H(1).                                      
!>                                                                      
!>  Each H(i) has the form                                              
!>                                                                      
!>     H(i) = I - tau * v * v**T                                        
!>                                                                      
!>  where tau is a real scalar, and v is a real vector with             
!>  v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in            
!>  A(1:i-1,i+1), and tau in TAU(i).                                    
!>                                                                      
!>  If UPLO = 'L', the matrix Q is represented as a product of elementar
!>  reflectors                                                          
!>                                                                      
!>     Q = H(1) H(2) . . . H(n-1).                                      
!>                                                                      
!>  Each H(i) has the form                                              
!>                                                                      
!>     H(i) = I - tau * v * v**T                                        
!>                                                                      
!>  where tau is a real scalar, and v is a real vector with             
!>  v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
!>  and tau in TAU(i).                                                  
!>                                                                      
!>  The contents of A on exit are illustrated by the following examples 
!>  with n = 5:                                                         
!>                                                                      
!>  if UPLO = 'U':                       if UPLO = 'L':                 
!>                                                                      
!>    (  d   e   v2  v3  v4 )              (  d                  )      
!>    (      d   e   v3  v4 )              (  e   d              )      
!>    (          d   e   v4 )              (  v1  e   d          )      
!>    (              d   e  )              (  v1  v2  e   d      )      
!>    (                  d  )              (  v1  v2  v3  e   d  )      
!>                                                                      
!>  where d and e denote diagonal and off-diagonal elements of T, and vi
!>  denotes an element of the vector defining H(i).                     
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE SSYTRD( UPLO, N, A, LDA, D, E, TAU, WORK, LWORK, INFO ) 
!                                                                       
!  -- LAPACK computational routine (version 3.7.0) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          UPLO 
      INTEGER            INFO, LDA, LWORK, N 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               A( LDA, * ), D( * ), E( * ), TAU( * ),         &
     &                   WORK( * )                                      
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ONE 
      PARAMETER          ( ONE = 1.0E+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            LQUERY, UPPER 
      INTEGER            I, IINFO, IWS, J, KK, LDWORK, LWKOPT, NB,      &
     &                   NBMIN, NX                                      
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           SLATRD, SSYR2K, SSYTD2, XERBLA 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      INTEGER            ILAENV 
      EXTERNAL           LSAME, ILAENV 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters                                         
!                                                                       
      INFO = 0 
      UPPER = LSAME( UPLO, 'U' ) 
      LQUERY = ( LWORK.EQ.-1 ) 
      IF( .NOT.UPPER .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN 
         INFO = -1 
      ELSE IF( N.LT.0 ) THEN 
         INFO = -2 
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN 
         INFO = -4 
      ELSE IF( LWORK.LT.1 .AND. .NOT.LQUERY ) THEN 
         INFO = -9 
      END IF 
!                                                                       
      IF( INFO.EQ.0 ) THEN 
!                                                                       
!        Determine the block size.                                      
!                                                                       
         NB = ILAENV( 1, 'SSYTRD', UPLO, N, -1, -1, -1 ) 
         LWKOPT = N*NB 
         WORK( 1 ) = LWKOPT 
      END IF 
!                                                                       
      IF( INFO.NE.0 ) THEN 
         CALL XERBLA( 'SSYTRD', -INFO ) 
         RETURN 
      ELSE IF( LQUERY ) THEN 
         RETURN 
      END IF 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.EQ.0 ) THEN 
         WORK( 1 ) = 1 
         RETURN 
      END IF 
!                                                                       
      NX = N 
      IWS = 1 
      IF( NB.GT.1 .AND. NB.LT.N ) THEN 
!                                                                       
!        Determine when to cross over from blocked to unblocked code    
!        (last block is always handled by unblocked code).              
!                                                                       
         NX = MAX( NB, ILAENV( 3, 'SSYTRD', UPLO, N, -1, -1, -1 ) ) 
         IF( NX.LT.N ) THEN 
!                                                                       
!           Determine if workspace is large enough for blocked code.    
!                                                                       
            LDWORK = N 
            IWS = LDWORK*NB 
            IF( LWORK.LT.IWS ) THEN 
!                                                                       
!              Not enough workspace to use optimal NB:  determine the   
!              minimum value of NB, and reduce NB or force use of       
!              unblocked code by setting NX = N.                        
!                                                                       
               NB = MAX( LWORK / LDWORK, 1 ) 
               NBMIN = ILAENV( 2, 'SSYTRD', UPLO, N, -1, -1, -1 ) 
               IF( NB.LT.NBMIN )                                        &
     &            NX = N                                                
            END IF 
         ELSE 
            NX = N 
         END IF 
      ELSE 
         NB = 1 
      END IF 
!                                                                       
      IF( UPPER ) THEN 
!                                                                       
!        Reduce the upper triangle of A.                                
!        Columns 1:kk are handled by the unblocked method.              
!                                                                       
         KK = N - ( ( N-NX+NB-1 ) / NB )*NB 
         DO 20 I = N - NB + 1, KK + 1, -NB 
!                                                                       
!           Reduce columns i:i+nb-1 to tridiagonal form and form the    
!           matrix W which is needed to update the unreduced part of    
!           the matrix                                                  
!                                                                       
            CALL SLATRD( UPLO, I+NB-1, NB, A, LDA, E, TAU, WORK,        &
     &                   LDWORK )                                       
!                                                                       
!           Update the unreduced submatrix A(1:i-1,1:i-1), using an     
!           update of the form:  A := A - V*W**T - W*V**T               
!                                                                       
            CALL SSYR2K( UPLO, 'No transpose', I-1, NB, -ONE, A( 1, I ),&
     &                   LDA, WORK, LDWORK, ONE, A, LDA )               
!                                                                       
!           Copy superdiagonal elements back into A, and diagonal       
!           elements into D                                             
!                                                                       
            DO 10 J = I, I + NB - 1 
               A( J-1, J ) = E( J-1 ) 
               D( J ) = A( J, J ) 
   10       CONTINUE 
   20    CONTINUE 
!                                                                       
!        Use unblocked code to reduce the last or only block            
!                                                                       
         CALL SSYTD2( UPLO, KK, A, LDA, D, E, TAU, IINFO ) 
      ELSE 
!                                                                       
!        Reduce the lower triangle of A                                 
!                                                                       
         DO 40 I = 1, N - NX, NB 
!                                                                       
!           Reduce columns i:i+nb-1 to tridiagonal form and form the    
!           matrix W which is needed to update the unreduced part of    
!           the matrix                                                  
!                                                                       
            CALL SLATRD( UPLO, N-I+1, NB, A( I, I ), LDA, E( I ),       &
     &                   TAU( I ), WORK, LDWORK )                       
!                                                                       
!           Update the unreduced submatrix A(i+ib:n,i+ib:n), using      
!           an update of the form:  A := A - V*W**T - W*V**T            
!                                                                       
            CALL SSYR2K( UPLO, 'No transpose', N-I-NB+1, NB, -ONE,      &
     &                   A( I+NB, I ), LDA, WORK( NB+1 ), LDWORK, ONE,  &
     &                   A( I+NB, I+NB ), LDA )                         
!                                                                       
!           Copy subdiagonal elements back into A, and diagonal         
!           elements into D                                             
!                                                                       
            DO 30 J = I, I + NB - 1 
               A( J+1, J ) = E( J ) 
               D( J ) = A( J, J ) 
   30       CONTINUE 
   40    CONTINUE 
!                                                                       
!        Use unblocked code to reduce the last or only block            
!                                                                       
         CALL SSYTD2( UPLO, N-I+1, A( I, I ), LDA, D( I ), E( I ),      &
     &                TAU( I ), IINFO )                                 
      END IF 
!                                                                       
      WORK( 1 ) = LWKOPT 
      RETURN 
!                                                                       
!     End of SSYTRD                                                     
!                                                                       
      END                                           
!> \brief \b STRMM                                                      
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE STRMM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB)   
!                                                                       
!       .. Scalar Arguments ..                                          
!       REAL ALPHA                                                      
!       INTEGER LDA,LDB,M,N                                             
!       CHARACTER DIAG,SIDE,TRANSA,UPLO                                 
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL A(LDA,*),B(LDB,*)                                          
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> STRMM  performs one of the matrix-matrix operations                  
!>                                                                      
!>    B := alpha*op( A )*B,   or   B := alpha*B*op( A ),                
!>                                                                      
!> where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
!> non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
!>                                                                      
!>    op( A ) = A   or   op( A ) = A**T.                                
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] SIDE                                                      
!> \verbatim                                                            
!>          SIDE is CHARACTER*1                                         
!>           On entry,  SIDE specifies whether  op( A ) multiplies B fro
!>           the left or right as follows:                              
!>                                                                      
!>              SIDE = 'L' or 'l'   B := alpha*op( A )*B.               
!>                                                                      
!>              SIDE = 'R' or 'r'   B := alpha*B*op( A ).               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] UPLO                                                      
!> \verbatim                                                            
!>          UPLO is CHARACTER*1                                         
!>           On entry, UPLO specifies whether the matrix A is an upper o
!>           lower triangular matrix as follows:                        
!>                                                                      
!>              UPLO = 'U' or 'u'   A is an upper triangular matrix.    
!>                                                                      
!>              UPLO = 'L' or 'l'   A is a lower triangular matrix.     
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TRANSA                                                    
!> \verbatim                                                            
!>          TRANSA is CHARACTER*1                                       
!>           On entry, TRANSA specifies the form of op( A ) to be used i
!>           the matrix multiplication as follows:                      
!>                                                                      
!>              TRANSA = 'N' or 'n'   op( A ) = A.                      
!>                                                                      
!>              TRANSA = 'T' or 't'   op( A ) = A**T.                   
!>                                                                      
!>              TRANSA = 'C' or 'c'   op( A ) = A**T.                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] DIAG                                                      
!> \verbatim                                                            
!>          DIAG is CHARACTER*1                                         
!>           On entry, DIAG specifies whether or not A is unit triangula
!>           as follows:                                                
!>                                                                      
!>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. 
!>                                                                      
!>              DIAG = 'N' or 'n'   A is not assumed to be unit         
!>                                  triangular.                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>           On entry, M specifies the number of rows of B. M must be at
!>           least zero.                                                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>           On entry, N specifies the number of columns of B.  N must b
!>           at least zero.                                             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ALPHA                                                     
!> \verbatim                                                            
!>          ALPHA is REAL                                               
!>           On entry,  ALPHA specifies the scalar  alpha. When  alpha i
!>           zero then  A is not referenced and  B need not be set befor
!>           entry.                                                     
!> \endverbatim                                                         
!>                                                                      
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is REAL array, dimension ( LDA, k ), where k is m         
!>           when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'
!>           Before entry  with  UPLO = 'U' or 'u',  the  leading  k by 
!>           upper triangular part of the array  A must contain the uppe
!>           triangular matrix  and the strictly lower triangular part o
!>           A is not referenced.                                       
!>           Before entry  with  UPLO = 'L' or 'l',  the  leading  k by 
!>           lower triangular part of the array  A must contain the lowe
!>           triangular matrix  and the strictly upper triangular part o
!>           A is not referenced.                                       
!>           Note that when  DIAG = 'U' or 'u',  the diagonal elements o
!>           A  are not referenced either,  but are assumed to be  unity
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>           On entry, LDA specifies the first dimension of A as declare
!>           in the calling (sub) program.  When  SIDE = 'L' or 'l'  the
!>           LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r
!>           then LDA must be at least max( 1, n ).                     
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] B                                                     
!> \verbatim                                                            
!>          B is REAL array, dimension ( LDB, N )                       
!>           Before entry,  the leading  m by n part of the array  B mus
!>           contain the matrix  B,  and  on exit  is overwritten  by th
!>           transformed matrix.                                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDB                                                       
!> \verbatim                                                            
!>          LDB is INTEGER                                              
!>           On entry, LDB specifies the first dimension of B as declare
!>           in  the  calling  (sub)  program.   LDB  must  be  at  leas
!>           max( 1, m ).                                               
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup single_blas_level3                                          
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  Level 3 Blas routine.                                               
!>                                                                      
!>  -- Written on 8-February-1989.                                      
!>     Jack Dongarra, Argonne National Laboratory.                      
!>     Iain Duff, AERE Harwell.                                         
!>     Jeremy Du Croz, Numerical Algorithms Group Ltd.                  
!>     Sven Hammarling, Numerical Algorithms Group Ltd.                 
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE STRMM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB) 
!                                                                       
!  -- Reference BLAS level3 routine (version 3.7.0) --                  
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      REAL ALPHA 
      INTEGER LDA,LDB,M,N 
      CHARACTER DIAG,SIDE,TRANSA,UPLO 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL A(LDA,*),B(LDB,*) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. External Functions ..                                          
      LOGICAL LSAME 
      EXTERNAL LSAME 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL XERBLA 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC MAX 
!     ..                                                                
!     .. Local Scalars ..                                               
      REAL TEMP 
      INTEGER I,INFO,J,K,NROWA 
      LOGICAL LSIDE,NOUNIT,UPPER 
!     ..                                                                
!     .. Parameters ..                                                  
      REAL ONE,ZERO 
      PARAMETER (ONE=1.0E+0,ZERO=0.0E+0) 
!     ..                                                                
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      LSIDE = LSAME(SIDE,'L') 
      IF (LSIDE) THEN 
          NROWA = M 
      ELSE 
          NROWA = N 
      END IF 
      NOUNIT = LSAME(DIAG,'N') 
      UPPER = LSAME(UPLO,'U') 
!                                                                       
      INFO = 0 
      IF ((.NOT.LSIDE) .AND. (.NOT.LSAME(SIDE,'R'))) THEN 
          INFO = 1 
      ELSE IF ((.NOT.UPPER) .AND. (.NOT.LSAME(UPLO,'L'))) THEN 
          INFO = 2 
      ELSE IF ((.NOT.LSAME(TRANSA,'N')) .AND.                           &
     &         (.NOT.LSAME(TRANSA,'T')) .AND.                           &
     &         (.NOT.LSAME(TRANSA,'C'))) THEN                           
          INFO = 3 
      ELSE IF ((.NOT.LSAME(DIAG,'U')) .AND. (.NOT.LSAME(DIAG,'N'))) THEN 
          INFO = 4 
      ELSE IF (M.LT.0) THEN 
          INFO = 5 
      ELSE IF (N.LT.0) THEN 
          INFO = 6 
      ELSE IF (LDA.LT.MAX(1,NROWA)) THEN 
          INFO = 9 
      ELSE IF (LDB.LT.MAX(1,M)) THEN 
          INFO = 11 
      END IF 
      IF (INFO.NE.0) THEN 
          CALL XERBLA('STRMM ',INFO) 
          RETURN 
      END IF 
!                                                                       
!     Quick return if possible.                                         
!                                                                       
      IF (M.EQ.0 .OR. N.EQ.0) RETURN 
!                                                                       
!     And when  alpha.eq.zero.                                          
!                                                                       
      IF (ALPHA.EQ.ZERO) THEN 
          DO 20 J = 1,N 
              DO 10 I = 1,M 
                  B(I,J) = ZERO 
   10         CONTINUE 
   20     CONTINUE 
          RETURN 
      END IF 
!                                                                       
!     Start the operations.                                             
!                                                                       
      IF (LSIDE) THEN 
          IF (LSAME(TRANSA,'N')) THEN 
!                                                                       
!           Form  B := alpha*A*B.                                       
!                                                                       
              IF (UPPER) THEN 
                  DO 50 J = 1,N 
                      DO 40 K = 1,M 
                          IF (B(K,J).NE.ZERO) THEN 
                              TEMP = ALPHA*B(K,J) 
                              DO 30 I = 1,K - 1 
                                  B(I,J) = B(I,J) + TEMP*A(I,K) 
   30                         CONTINUE 
                              IF (NOUNIT) TEMP = TEMP*A(K,K) 
                              B(K,J) = TEMP 
                          END IF 
   40                 CONTINUE 
   50             CONTINUE 
              ELSE 
                  DO 80 J = 1,N 
                      DO 70 K = M,1,-1 
                          IF (B(K,J).NE.ZERO) THEN 
                              TEMP = ALPHA*B(K,J) 
                              B(K,J) = TEMP 
                              IF (NOUNIT) B(K,J) = B(K,J)*A(K,K) 
                              DO 60 I = K + 1,M 
                                  B(I,J) = B(I,J) + TEMP*A(I,K) 
   60                         CONTINUE 
                          END IF 
   70                 CONTINUE 
   80             CONTINUE 
              END IF 
          ELSE 
!                                                                       
!           Form  B := alpha*A**T*B.                                    
!                                                                       
              IF (UPPER) THEN 
                  DO 110 J = 1,N 
                      DO 100 I = M,1,-1 
                          TEMP = B(I,J) 
                          IF (NOUNIT) TEMP = TEMP*A(I,I) 
                          DO 90 K = 1,I - 1 
                              TEMP = TEMP + A(K,I)*B(K,J) 
   90                     CONTINUE 
                          B(I,J) = ALPHA*TEMP 
  100                 CONTINUE 
  110             CONTINUE 
              ELSE 
                  DO 140 J = 1,N 
                      DO 130 I = 1,M 
                          TEMP = B(I,J) 
                          IF (NOUNIT) TEMP = TEMP*A(I,I) 
                          DO 120 K = I + 1,M 
                              TEMP = TEMP + A(K,I)*B(K,J) 
  120                     CONTINUE 
                          B(I,J) = ALPHA*TEMP 
  130                 CONTINUE 
  140             CONTINUE 
              END IF 
          END IF 
      ELSE 
          IF (LSAME(TRANSA,'N')) THEN 
!                                                                       
!           Form  B := alpha*B*A.                                       
!                                                                       
              IF (UPPER) THEN 
                  DO 180 J = N,1,-1 
                      TEMP = ALPHA 
                      IF (NOUNIT) TEMP = TEMP*A(J,J) 
                      DO 150 I = 1,M 
                          B(I,J) = TEMP*B(I,J) 
  150                 CONTINUE 
                      DO 170 K = 1,J - 1 
                          IF (A(K,J).NE.ZERO) THEN 
                              TEMP = ALPHA*A(K,J) 
                              DO 160 I = 1,M 
                                  B(I,J) = B(I,J) + TEMP*B(I,K) 
  160                         CONTINUE 
                          END IF 
  170                 CONTINUE 
  180             CONTINUE 
              ELSE 
                  DO 220 J = 1,N 
                      TEMP = ALPHA 
                      IF (NOUNIT) TEMP = TEMP*A(J,J) 
                      DO 190 I = 1,M 
                          B(I,J) = TEMP*B(I,J) 
  190                 CONTINUE 
                      DO 210 K = J + 1,N 
                          IF (A(K,J).NE.ZERO) THEN 
                              TEMP = ALPHA*A(K,J) 
                              DO 200 I = 1,M 
                                  B(I,J) = B(I,J) + TEMP*B(I,K) 
  200                         CONTINUE 
                          END IF 
  210                 CONTINUE 
  220             CONTINUE 
              END IF 
          ELSE 
!                                                                       
!           Form  B := alpha*B*A**T.                                    
!                                                                       
              IF (UPPER) THEN 
                  DO 260 K = 1,N 
                      DO 240 J = 1,K - 1 
                          IF (A(J,K).NE.ZERO) THEN 
                              TEMP = ALPHA*A(J,K) 
                              DO 230 I = 1,M 
                                  B(I,J) = B(I,J) + TEMP*B(I,K) 
  230                         CONTINUE 
                          END IF 
  240                 CONTINUE 
                      TEMP = ALPHA 
                      IF (NOUNIT) TEMP = TEMP*A(K,K) 
                      IF (TEMP.NE.ONE) THEN 
                          DO 250 I = 1,M 
                              B(I,K) = TEMP*B(I,K) 
  250                     CONTINUE 
                      END IF 
  260             CONTINUE 
              ELSE 
                  DO 300 K = N,1,-1 
                      DO 280 J = K + 1,N 
                          IF (A(J,K).NE.ZERO) THEN 
                              TEMP = ALPHA*A(J,K) 
                              DO 270 I = 1,M 
                                  B(I,J) = B(I,J) + TEMP*B(I,K) 
  270                         CONTINUE 
                          END IF 
  280                 CONTINUE 
                      TEMP = ALPHA 
                      IF (NOUNIT) TEMP = TEMP*A(K,K) 
                      IF (TEMP.NE.ONE) THEN 
                          DO 290 I = 1,M 
                              B(I,K) = TEMP*B(I,K) 
  290                     CONTINUE 
                      END IF 
  300             CONTINUE 
              END IF 
          END IF 
      END IF 
!                                                                       
      RETURN 
!                                                                       
!     End of STRMM .                                                    
!                                                                       
      END                                           
!> \brief \b STRMV                                                      
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE STRMV(UPLO,TRANS,DIAG,N,A,LDA,X,INCX)                
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER INCX,LDA,N                                              
!       CHARACTER DIAG,TRANS,UPLO                                       
!       ..                                                              
!       .. Array Arguments ..                                           
!       REAL A(LDA,*),X(*)                                              
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> STRMV  performs one of the matrix-vector operations                  
!>                                                                      
!>    x := A*x,   or   x := A**T*x,                                     
!>                                                                      
!> where x is an n element vector and  A is an n by n unit, or non-unit,
!> upper or lower triangular matrix.                                    
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] UPLO                                                      
!> \verbatim                                                            
!>          UPLO is CHARACTER*1                                         
!>           On entry, UPLO specifies whether the matrix is an upper or 
!>           lower triangular matrix as follows:                        
!>                                                                      
!>              UPLO = 'U' or 'u'   A is an upper triangular matrix.    
!>                                                                      
!>              UPLO = 'L' or 'l'   A is a lower triangular matrix.     
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TRANS                                                     
!> \verbatim                                                            
!>          TRANS is CHARACTER*1                                        
!>           On entry, TRANS specifies the operation to be performed as 
!>           follows:                                                   
!>                                                                      
!>              TRANS = 'N' or 'n'   x := A*x.                          
!>                                                                      
!>              TRANS = 'T' or 't'   x := A**T*x.                       
!>                                                                      
!>              TRANS = 'C' or 'c'   x := A**T*x.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] DIAG                                                      
!> \verbatim                                                            
!>          DIAG is CHARACTER*1                                         
!>           On entry, DIAG specifies whether or not A is unit          
!>           triangular as follows:                                     
!>                                                                      
!>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. 
!>                                                                      
!>              DIAG = 'N' or 'n'   A is not assumed to be unit         
!>                                  triangular.                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>           On entry, N specifies the order of the matrix A.           
!>           N must be at least zero.                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is REAL array, dimension ( LDA, N )                       
!>           Before entry with  UPLO = 'U' or 'u', the leading n by n   
!>           upper triangular part of the array A must contain the upper
!>           triangular matrix and the strictly lower triangular part of
!>           A is not referenced.                                       
!>           Before entry with UPLO = 'L' or 'l', the leading n by n    
!>           lower triangular part of the array A must contain the lower
!>           triangular matrix and the strictly upper triangular part of
!>           A is not referenced.                                       
!>           Note that when  DIAG = 'U' or 'u', the diagonal elements of
!>           A are not referenced either, but are assumed to be unity.  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>           On entry, LDA specifies the first dimension of A as declare
!>           in the calling (sub) program. LDA must be at least         
!>           max( 1, n ).                                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] X                                                     
!> \verbatim                                                            
!>          X is REAL array, dimension at least                         
!>           ( 1 + ( n - 1 )*abs( INCX ) ).                             
!>           Before entry, the incremented array X must contain the n   
!>           element vector x. On exit, X is overwritten with the       
!>           transformed vector x.                                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCX                                                      
!> \verbatim                                                            
!>          INCX is INTEGER                                             
!>           On entry, INCX specifies the increment for the elements of 
!>           X. INCX must not be zero.                                  
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup single_blas_level2                                          
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  Level 2 Blas routine.                                               
!>  The vector and matrix arguments are not referenced when N = 0, or M 
!>                                                                      
!>  -- Written on 22-October-1986.                                      
!>     Jack Dongarra, Argonne National Lab.                             
!>     Jeremy Du Croz, Nag Central Office.                              
!>     Sven Hammarling, Nag Central Office.                             
!>     Richard Hanson, Sandia National Labs.                            
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE STRMV(UPLO,TRANS,DIAG,N,A,LDA,X,INCX) 
!                                                                       
!  -- Reference BLAS level2 routine (version 3.7.0) --                  
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER INCX,LDA,N 
      CHARACTER DIAG,TRANS,UPLO 
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL A(LDA,*),X(*) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL ZERO 
      PARAMETER (ZERO=0.0E+0) 
!     ..                                                                
!     .. Local Scalars ..                                               
      REAL TEMP 
      INTEGER I,INFO,IX,J,JX,KX 
      LOGICAL NOUNIT 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL LSAME 
      EXTERNAL LSAME 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL XERBLA 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC MAX 
!     ..                                                                
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0 
      IF (.NOT.LSAME(UPLO,'U') .AND. .NOT.LSAME(UPLO,'L')) THEN 
          INFO = 1 
      ELSE IF (.NOT.LSAME(TRANS,'N') .AND. .NOT.LSAME(TRANS,'T') .AND.  &
     &         .NOT.LSAME(TRANS,'C')) THEN                              
          INFO = 2 
      ELSE IF (.NOT.LSAME(DIAG,'U') .AND. .NOT.LSAME(DIAG,'N')) THEN 
          INFO = 3 
      ELSE IF (N.LT.0) THEN 
          INFO = 4 
      ELSE IF (LDA.LT.MAX(1,N)) THEN 
          INFO = 6 
      ELSE IF (INCX.EQ.0) THEN 
          INFO = 8 
      END IF 
      IF (INFO.NE.0) THEN 
          CALL XERBLA('STRMV ',INFO) 
          RETURN 
      END IF 
!                                                                       
!     Quick return if possible.                                         
!                                                                       
      IF (N.EQ.0) RETURN 
!                                                                       
      NOUNIT = LSAME(DIAG,'N') 
!                                                                       
!     Set up the start point in X if the increment is not unity. This   
!     will be  ( N - 1 )*INCX  too small for descending loops.          
!                                                                       
      IF (INCX.LE.0) THEN 
          KX = 1 - (N-1)*INCX 
      ELSE IF (INCX.NE.1) THEN 
          KX = 1 
      END IF 
!                                                                       
!     Start the operations. In this version the elements of A are       
!     accessed sequentially with one pass through A.                    
!                                                                       
      IF (LSAME(TRANS,'N')) THEN 
!                                                                       
!        Form  x := A*x.                                                
!                                                                       
          IF (LSAME(UPLO,'U')) THEN 
              IF (INCX.EQ.1) THEN 
                  DO 20 J = 1,N 
                      IF (X(J).NE.ZERO) THEN 
                          TEMP = X(J) 
                          DO 10 I = 1,J - 1 
                              X(I) = X(I) + TEMP*A(I,J) 
   10                     CONTINUE 
                          IF (NOUNIT) X(J) = X(J)*A(J,J) 
                      END IF 
   20             CONTINUE 
              ELSE 
                  JX = KX 
                  DO 40 J = 1,N 
                      IF (X(JX).NE.ZERO) THEN 
                          TEMP = X(JX) 
                          IX = KX 
                          DO 30 I = 1,J - 1 
                              X(IX) = X(IX) + TEMP*A(I,J) 
                              IX = IX + INCX 
   30                     CONTINUE 
                          IF (NOUNIT) X(JX) = X(JX)*A(J,J) 
                      END IF 
                      JX = JX + INCX 
   40             CONTINUE 
              END IF 
          ELSE 
              IF (INCX.EQ.1) THEN 
                  DO 60 J = N,1,-1 
                      IF (X(J).NE.ZERO) THEN 
                          TEMP = X(J) 
                          DO 50 I = N,J + 1,-1 
                              X(I) = X(I) + TEMP*A(I,J) 
   50                     CONTINUE 
                          IF (NOUNIT) X(J) = X(J)*A(J,J) 
                      END IF 
   60             CONTINUE 
              ELSE 
                  KX = KX + (N-1)*INCX 
                  JX = KX 
                  DO 80 J = N,1,-1 
                      IF (X(JX).NE.ZERO) THEN 
                          TEMP = X(JX) 
                          IX = KX 
                          DO 70 I = N,J + 1,-1 
                              X(IX) = X(IX) + TEMP*A(I,J) 
                              IX = IX - INCX 
   70                     CONTINUE 
                          IF (NOUNIT) X(JX) = X(JX)*A(J,J) 
                      END IF 
                      JX = JX - INCX 
   80             CONTINUE 
              END IF 
          END IF 
      ELSE 
!                                                                       
!        Form  x := A**T*x.                                             
!                                                                       
          IF (LSAME(UPLO,'U')) THEN 
              IF (INCX.EQ.1) THEN 
                  DO 100 J = N,1,-1 
                      TEMP = X(J) 
                      IF (NOUNIT) TEMP = TEMP*A(J,J) 
                      DO 90 I = J - 1,1,-1 
                          TEMP = TEMP + A(I,J)*X(I) 
   90                 CONTINUE 
                      X(J) = TEMP 
  100             CONTINUE 
              ELSE 
                  JX = KX + (N-1)*INCX 
                  DO 120 J = N,1,-1 
                      TEMP = X(JX) 
                      IX = JX 
                      IF (NOUNIT) TEMP = TEMP*A(J,J) 
                      DO 110 I = J - 1,1,-1 
                          IX = IX - INCX 
                          TEMP = TEMP + A(I,J)*X(IX) 
  110                 CONTINUE 
                      X(JX) = TEMP 
                      JX = JX - INCX 
  120             CONTINUE 
              END IF 
          ELSE 
              IF (INCX.EQ.1) THEN 
                  DO 140 J = 1,N 
                      TEMP = X(J) 
                      IF (NOUNIT) TEMP = TEMP*A(J,J) 
                      DO 130 I = J + 1,N 
                          TEMP = TEMP + A(I,J)*X(I) 
  130                 CONTINUE 
                      X(J) = TEMP 
  140             CONTINUE 
              ELSE 
                  JX = KX 
                  DO 160 J = 1,N 
                      TEMP = X(JX) 
                      IX = JX 
                      IF (NOUNIT) TEMP = TEMP*A(J,J) 
                      DO 150 I = J + 1,N 
                          IX = IX + INCX 
                          TEMP = TEMP + A(I,J)*X(IX) 
  150                 CONTINUE 
                      X(JX) = TEMP 
                      JX = JX + INCX 
  160             CONTINUE 
              END IF 
          END IF 
      END IF 
!                                                                       
      RETURN 
!                                                                       
!     End of STRMV .                                                    
!                                                                       
      END                                           
!> \brief \b XERBLA                                                     
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE XERBLA( SRNAME, INFO )                               
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER*(*)      SRNAME                                       
!       INTEGER            INFO                                         
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> XERBLA  is an error handler for the LAPACK routines.                 
!> It is called by an LAPACK routine if an input parameter has an       
!> invalid value.  A message is printed and execution stops.            
!>                                                                      
!> Installers may consider modifying the STOP statement in order to     
!> call system-specific exception-handling facilities.                  
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] SRNAME                                                    
!> \verbatim                                                            
!>          SRNAME is CHARACTER*(*)                                     
!>          The name of the routine which called XERBLA.                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INFO                                                      
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          The position of the invalid parameter in the parameter list 
!>          of the calling routine.                                     
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup aux_blas                                                    
!                                                                       
!  =====================================================================
      SUBROUTINE XERBLA( SRNAME, INFO ) 
!                                                                       
!  -- Reference BLAS level1 routine (version 3.7.0) --                  
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER*(*)      SRNAME 
      INTEGER            INFO 
!     ..                                                                
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Intrinsic Functions ..                                         
      INTRINSIC          LEN_TRIM 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      WRITE( *, FMT = 9999 )SRNAME( 1:LEN_TRIM( SRNAME ) ), INFO 
!                                                                       
      STOP 
!                                                                       
 9999 FORMAT( ' ** On entry to ', A, ' parameter number ', I2, ' had ', &
     &      'an illegal value' )                                        
!                                                                       
!     End of XERBLA                                                     
!                                                                       
      END                                           
!> \brief \b SLAMCH                                                     
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!      REAL             FUNCTION SLAMCH( CMACH )                        
!                                                                       
!     .. Scalar Arguments ..                                            
!      CHARACTER          CMACH                                         
!     ..                                                                
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> SLAMCH determines single precision machine parameters.               
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] CMACH                                                     
!> \verbatim                                                            
!>          CMACH is CHARACTER*1                                        
!>          Specifies the value to be returned by SLAMCH:               
!>          = 'E' or 'e',   SLAMCH := eps                               
!>          = 'S' or 's ,   SLAMCH := sfmin                             
!>          = 'B' or 'b',   SLAMCH := base                              
!>          = 'P' or 'p',   SLAMCH := eps*base                          
!>          = 'N' or 'n',   SLAMCH := t                                 
!>          = 'R' or 'r',   SLAMCH := rnd                               
!>          = 'M' or 'm',   SLAMCH := emin                              
!>          = 'U' or 'u',   SLAMCH := rmin                              
!>          = 'L' or 'l',   SLAMCH := emax                              
!>          = 'O' or 'o',   SLAMCH := rmax                              
!>          where                                                       
!>          eps   = relative machine precision                          
!>          sfmin = safe minimum, such that 1/sfmin does not overflow   
!>          base  = base of the machine                                 
!>          prec  = eps*base                                            
!>          t     = number of (base) digits in the mantissa             
!>          rnd   = 1.0 when rounding occurs in addition, 0.0 otherwise 
!>          emin  = minimum exponent before (gradual) underflow         
!>          rmin  = underflow threshold - base**(emin-1)                
!>          emax  = largest exponent before overflow                    
!>          rmax  = overflow threshold  - (base**emax)*(1-eps)          
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup auxOTHERauxiliary                                           
!                                                                       
!  =====================================================================
      REAL             FUNCTION SLAMCH( CMACH ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          CMACH 
!     ..                                                                
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Parameters ..                                                  
      REAL               ONE, ZERO 
      PARAMETER          ( ONE = 1.0E+0, ZERO = 0.0E+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      REAL               RND, EPS, SFMIN, SMALL, RMACH 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      EXTERNAL           LSAME 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          DIGITS, EPSILON, HUGE, MAXEXPONENT,            &
     &                   MINEXPONENT, RADIX, TINY                       
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!                                                                       
!     Assume rounding, not chopping. Always.                            
!                                                                       
      RND = ONE 
!                                                                       
      IF( ONE.EQ.RND ) THEN 
         EPS = EPSILON(ZERO) * 0.5 
      ELSE 
         EPS = EPSILON(ZERO) 
      END IF 
!                                                                       
      IF( LSAME( CMACH, 'E' ) ) THEN 
         RMACH = EPS 
      ELSE IF( LSAME( CMACH, 'S' ) ) THEN 
         SFMIN = TINY(ZERO) 
         SMALL = ONE / HUGE(ZERO) 
         IF( SMALL.GE.SFMIN ) THEN 
!                                                                       
!           Use SMALL plus a bit, to avoid the possibility of rounding  
!           causing overflow when computing  1/sfmin.                   
!                                                                       
            SFMIN = SMALL*( ONE+EPS ) 
         END IF 
         RMACH = SFMIN 
      ELSE IF( LSAME( CMACH, 'B' ) ) THEN 
         RMACH = RADIX(ZERO) 
      ELSE IF( LSAME( CMACH, 'P' ) ) THEN 
         RMACH = EPS * RADIX(ZERO) 
      ELSE IF( LSAME( CMACH, 'N' ) ) THEN 
         RMACH = DIGITS(ZERO) 
      ELSE IF( LSAME( CMACH, 'R' ) ) THEN 
         RMACH = RND 
      ELSE IF( LSAME( CMACH, 'M' ) ) THEN 
         RMACH = MINEXPONENT(ZERO) 
      ELSE IF( LSAME( CMACH, 'U' ) ) THEN 
         RMACH = tiny(zero) 
      ELSE IF( LSAME( CMACH, 'L' ) ) THEN 
         RMACH = MAXEXPONENT(ZERO) 
      ELSE IF( LSAME( CMACH, 'O' ) ) THEN 
         RMACH = HUGE(ZERO) 
      ELSE 
         RMACH = ZERO 
      END IF 
!                                                                       
      SLAMCH = RMACH 
      RETURN 
!                                                                       
!     End of SLAMCH                                                     
!                                                                       
      END                                           
!***********************************************************************
!> \brief \b SLAMC3                                                     
!> \details                                                             
!> \b Purpose:                                                          
!> \verbatim                                                            
!> SLAMC3  is intended to force  A  and  B  to be stored prior to doing 
!> the addition of  A  and  B ,  for use in situations where optimizers 
!> might hold one of these in a register.                               
!> \endverbatim                                                         
!> \author LAPACK is a software package provided by Univ. of Tennessee, 
!> \date December 2016                                                  
!> \ingroup auxOTHERauxiliary                                           
!>                                                                      
!> \param[in] A                                                         
!> \verbatim                                                            
!> \endverbatim                                                         
!>                                                                      
!> \param[in] B                                                         
!> \verbatim                                                            
!>          The values A and B.                                         
!> \endverbatim                                                         
!>                                                                      
!                                                                       
      REAL             FUNCTION SLAMC3( A, B ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..    
!     November 2010                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      REAL               A, B 
!     ..                                                                
! ===================================================================== 
!                                                                       
!     .. Executable Statements ..                                       
!                                                                       
      SLAMC3 = A + B 
!                                                                       
      RETURN 
!                                                                       
!     End of SLAMC3                                                     
!                                                                       
      END                                           
