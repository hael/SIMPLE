<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><!-- InstanceBegin template="/Templates/template_new.dwt" codeOutsideHTMLIsLocked="false" -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- InstanceBeginEditable name="doctitle" -->
<title>manuals for SIMPLE 2.1</title>
<!-- InstanceEndEditable -->
<style type="text/css">
body,td,th {
	color: #FFFFFF;
}

body {
	background-image: url(images/nebula.jpg);
	background-attachment: fixed;
	margin-top: 0px;
	margin-right: 0px;
	margin-bottom: 0px;
	margin-left: 0px;
	background-color: rgb(0,0,0);
	background-repeat: repeat;
}


</style>
<link href="common_styles.css" rel="stylesheet" type="text/css">
<script src="SpryAssets/SpryMenuBar.js" type="text/javascript"></script>
<link href="SpryAssets/SpryMenuBarHorizontal.css" rel="stylesheet" type="text/css">
<!-- InstanceBeginEditable name="head" -->
<style type="text/css">
</style>
<script src="SpryAssets/SpryAccordion.js" type="text/javascript"></script>
<link href="SpryAssets/SpryAccordion.css" rel="stylesheet" type="text/css">
<!-- InstanceEndEditable -->
<script type="text/xml">
<!--
<oa:widgets>
  <oa:widget wid="2149022" binding="#OAWidget" />
</oa:widgets>
-->
</script>
<style type="text/css">
a:link {
	color: rgb(153,0,51);
}
a:visited {
	color: rgb(187,0,62);
}
a:hover {
	color: rgb(187,0,62);
}
a:active {
	color: rgb(187,0,62);
}
h1,h2,h3,h4,h5,h6 {
	font-family: Verdana, Geneva, sans-serif;
}
h1 {
	color: rgb(0,0,0);
}
h2 {
	font-size: 18px;
	color: rgb(153,0,0);
}
</style>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-31924791-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
<link rel="shortcut icon" href="http://simplecryoem.com/favicon.ico" >
</head>

<body bgcolor="#000000">
<a name="top"></a>
<div class="logo_div"><img src="./images/SIMPLE_banner.png" alt="SIMPLE banner" width="830" height="110" align="absmiddle"></div>
<div class="nav_div">
  <ul id="MenuBar1" class="MenuBarHorizontal">
    <li><a href="./index.html">About</a>    </li>
    <li><a href="./download_form.html">Download</a></li>
    <li><a href="./workflows.html">Workflows</a></li>
    <li><a href="./manuals.html">Manuals</a></li>
    <li><a href="./lab.html">Elmlund Lab</a></li>
    <li><a href="./publications.html">Publications</a></li>
    <li><a href="./contact.html">Contact </a></li>
  </ul>
</div>
<!-- InstanceBeginEditable name="EditRegion1" -->
<div class="content_div">

  <h1>Manuals for SIMPLE 2.1</h1>
  
  <h2 class="h2_manual" align="center">
  <a href="http://simplecryoem.com/documents/simple2.1manual.pdf" target="_new">simple2.1manual.pdf</a>
  <h2 class="h2_manual" align="center">
  <a href="http://simplecryoem.com/documents/simple2.1cmdlindict.pdf" target="_new">command_line_dictionary.pdf</a></h2>
  
 <!-- 
 
HEADINGS FOR THE ACCORDIONS

* Installation

* 2D alignment/clustering
    (1) prime2D_init
    (2) prime2D
    (3) rank_cavgs
    (4) map2ptcls
    (5) doc2cavgs
* Ab initio 3D reconstruction
    (1) resrange
    (2) prime3D_init
    (3) prime3D
    (4) symsrch
    (5) recvol
    (6) eo_recvol
* Standard image/volume operations (ops)
    (1) automask 
    (2) converter
    (3) iminfo 
    (4) simimgs
    (5) stackops
    (6) volops
* Utility programs
    (1) print_fsc
    (2) res
    (3) projvol
    
-->


<div id="Accordion0" class="Accordion" >
        <div class="AccordionPanel">
      <div class="AccordionPanelTab">File formats</div>
      <div class="AccordionPanelContent">
      <P>
<strong>SIMPLE 2.1</strong> supports both SPIDER (<TT>*.spi</TT>) and MRC (<TT>*.mrc</TT>) formats for image stacks and volumes. The MRC file handling classes are shared with the <a href="http://grigoriefflab.janelia.org/frealix" target="new">Frealix</a> program for helical reconstruction. <a href="http://www2.mrc-lmb.cam.ac.uk/relion/index.php/Main_Page" target="new">Relion</a> uses the convention that MRC stacks have the suffix <TT>*.mrcs</TT> and volumes the suffix <TT>*.mrc</TT>. This is to overcome the annoyance that it is not possible to tell from an MRC file header whether a MRC file is a volume or a stack. With SIMPLE you can select to use either the <TT>*.mrcs</TT> or <TT>*.mrc</TT> suffix for stacks. The way that we keep track of whether a file is a volume or stack is via the command line key value. The key value pairs <TT>vol1=rec.mrc</TT> and <TT>vol2=rec2.mrc</TT> refer to volumes whereas the key value pairs <TT>stk=ptcls.mrc</TT> and <TT>stk2=ptcls2.mrc</TT> refer to stacks. Another notable change is the text file format used to write per-particle information to disk. The SIMPLE text files used for parameter input/output now use a <TT>key=value</TT> syntax of the form
<PRE>
    e1=80. e2=100. e3=5.5 x=1.23 y=4.25 dfx=2.56 dfy=2.54 angast=30.5 state=1
</PRE>
to represent per-particle information. Internally, the orientation information is stored in a dynamic hash data structure, which gives the file format high flexibility. Therefore, writing conversion scripts to allow interchange of parameters between SIMPLE and other packages is trivial. SIMPLE uses the same conventions as Frealign to represent orientations and CTF parameters. The CTF parameterization obtained by <a href="http://grigoriefflab.janelia.org/ctf" target="new">CTFFIND</a> can be directly plugged into SIMPLE, for example by creating a file <TT>deftab.txt</TT>, looking like:
<PRE>
    dfx=2.56 dfy=2.76 angast=30.5
    dfx=3.50 dfy=3.33 angast=60.0
    dfx=1.98 dfy=2.02 angast=120.5
    ...
</PRE>
and adding <TT>deftab=deftab.txt</TT> and <TT>ctf=yes</TT> to the PRIME command line (if the images are phase-flipped, this should be indicated by <TT>ctf=flip</TT>). The <TT>SIMPLE/scripts</TT> folder contains a perl script (<TT>convert_frealign2simple.pl</TT>) to convert a Frealign parameter file to a SIMPLE parameter file. This is easy, since both software internally use the <a href="http://spider.wadsworth.org/spider_doc/spider/docs/euler.html" target="new">SPIDER Euler angle convention</a></B>. Other packages may use other conventions.
      
    </div>
    </div>  

</div>

<!-- ACCORDION 1 START -->

		<h2 class="h2_manual" align="left"> <a name="installation"></a>&nbsp; &nbsp;Installation</h2>
        
        <div id="Accordion1" class="Accordion" >
        <div class="AccordionPanel">
      <div class="AccordionPanelTab">System requirements</div>
      <div class="AccordionPanelContent">
        <p><strong>Hardware
        </strong>
        <ul>
<strong>CPU</strong>
<li>Linux (fully supported Debian-based distributions: Mint-17.1, Ubuntu (14.10, 15.04, 15.10, 16.04 LTS)), SUSE-13.2 (earlier SUSE versions are also supported but not tested)</li>
  <li>MacOSX (Yosemite and El Capitan, i.e. 10.10 and above)</li>
</ul></br>

<strong>Sofware</strong>
<ul>
  <strong>CPU</strong>
<li>GNU tool chain 4.9 and above</li>
  <li>The linear algebra packages: Lapack and BLAS</li>
  <li>FFTW-3 (The Fastest Fourier Transform in the West library)</li>
</ul></br></p>
        
        </div>
    </div>
        
        
        <div class="AccordionPanel">
      <div class="AccordionPanelTab">Compiling from source on a Linux PC</div>
      <div class="AccordionPanelContent">
        <P>
Here we will compile SIMPLE2.1 from source on a Linux PC. The manual states that  SIMPLE2.1 requires the GNU toolchain version 4.9.1 or later (see above). Although SIMPLE supports all newer versions of the GNU toolchain, it is safest to use version 4.9.X because later versions are currently incompatible with the CUDA7 compiler. GPU accelerated code is planned for SIMPLE v3 and it may not be supported unless 4.9.X is used. To check the compiler versions, we execute
<PRE>
    $ gfortran --version
    GNU Fortran (GCC) 4.9.1
    Copyright (C) 2014 Free Software Foundation, Inc.
</PRE>
To confirm that the gcc and g++ compilers are of the same version, we execute
<PRE>
    $ gcc --version
    gcc (GCC) 4.9.1
    Copyright (C) 2014 Free Software Foundation, Inc.
    This is free software; see the source for copying conditions.  There is NO
    warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
</PRE>
<PRE>
    $ g++ --version
    g++ (GCC) 4.9.1
    Copyright (C) 2014 Free Software Foundation, Inc.
    This is free software; see the source for copying conditions.  There is NO
    warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
</PRE>
To check whether lapack is installed, we open the package manager installed on our system (in our case <TT>Synaptic</TT> but other systems may have others, such as <TT>YaST</TT>, <TT>apt</TT> etc.) and search for <TT>lapack</TT> and conclude that <TT>liblapack3</TT> is installed on the system. We also search for <TT>fftw</TT> and conclude that the <TT>libfftw3-single-3</TT> is installed on the system. We cd to the directory  where we have our software installed (<TT>&lt;my software location&gt;</TT>) and copy the tar ball there
<PRE>
    $ cd &lt;my software location&gt;
    $ cp ~/Downloads/simple2.1.tar.gz .
</PRE>
Next, we unpack the tar ball and cd to the simple directory
<PRE>
    $ gunzip simple2.1.tar.gz
    $ tar -xvf simple2.1.tar
    $ cd simple2.1/
</PRE>
To check which Linux distribution we are running, we execute
<PRE>
    $ lsb_release -a
    No LSB modules are available.
    Distributor ID: Ubuntu
    Description:    Ubuntu 15.10
    Release:    15.10
    Codename:   wily
</PRE>
Now we try to identify the configuration template file most suitable for our system by executing
<PRE>
    $ ls -1 scripts/Template_*
    scripts/Template_FEDORA_21x64_CPU_simple_user_input.pm
    scripts/Template_MacOSX_10.9.5x64_CPU_simple_user_input.pm
    scripts/Template_MacOSXFINK_10.11.4x64_CPU_simple_user_input.pm
    scripts/Template_MASSIVE_CPU_simple_user_input.pm
    scripts/Template_Mint_17.1x64_CPU_simple_user_input.pm
    scripts/Template_OXFORD_CPU_simple_user_input.pm
    scripts/Template_SUSE_13.2x64_CPU_simple_user_input.pm
    scripts/Template_Ubuntu_14.10x64_CPU_simple_user_input.pm
    scripts/Template_Ubuntu_15.10x64_CPU_simple_user_input.pm
    scripts/Template_Ubuntu_16.XXx64_CPU_simple_user_input.pm
</PRE>

<P>
For this system, it looks like the <TT>Template_Ubuntu_15.10x64_CPU_simple_user_input.pm</TT> is the best fit, so we copy it to the root of the SIMPLE directory and rename it by executing
<PRE>
    $ cp ./scripts/Template_Ubuntu_15.10x64_CPU_simple_user_input.pm
    simple_user_input.pm
</PRE>

<P>
We open the <TT>simple_user_input.pm</TT> file in our favourite text editor (vim) and replace on line 30 <TT>our$SIMPLE_PATH
"/mysimplepath/"</TT> <br> with <br><TT>our$SIMPLE_PATH
"/mysoftwarelocation/simple2.1/"</TT> <br> This is the path in which the software will be installed. We close vim and execute
<PRE>
    $ ./Makefile_genAll.pl
    SIMPLE library has finished compilation in dir:
    /mysoftwarelocation/simple2.1/
    *********************************************************
    * Compilation and linkage is complete for Simple-v2.1   *
    * You may run all simple checks  --- List check options *
    * &gt; make check                   --- &gt; make check_help  *
    *                                --- &gt; make check_cpu   *
    * Cleaners: --- &gt; make {clean,cleanall,clean_check_cpu} *
    * New Rel.: --- &gt; make checknews                        *
    * Lne Cntr: --- &gt; make wc                               *
    *********************************************************
</PRE>

<P>
Compilation was succesful and we see that a new directory <TT>/bin</TT> has been created in the simple directory in addition to two text files <TT>add2.bashrc</TT> and <TT>add2.tcshrc</TT>
<PRE>
    $ cat add2.bashrc
    export SIMPLEPATH=/mysoftwarelocation/simple2.1/
    export PATH=${SIMPLEPATH}/scripts:${SIMPLEPATH}/$PATH
    $ cat add2.tcshrc
    setenv SIMPLEPATH /mysoftwarelocation/simple2.1/
    set path=(${SIMPLEPATH}/scripts ${SIMPLEPATH}/bin $path)
</PRE>

<P>
On this machine we use the bash shell, so we add the lines in <TT>add2.bashrc</TT> to the <TT>.bashrc</TT> file and when a new terminal window is opened we have access to all the <TT>simple_*</TT> programs.    
        </div>
    </div>
        
       <div class="AccordionPanel">
      <div class="AccordionPanelTab">Compiling from source on MacOSX</div>
      <div class="AccordionPanelContent">
        <P>
This procedure is virtually identical to the one described for Linux above but we need to select the correct configuration file. If the <TT>fink</TT> package manager was used to install the GNU toolchain and the FFTW library, try the configuration file:
<PRE>
    scripts/Template_MacOSXFINK_10.11.4x64_CPU_simple_user_input.pm
</PRE>
 Otherwise, try the file:
<PRE>
    scripts/Template_MacOSX_10.9.5x64_CPU_simple_user_input.pm
</PRE>   
        </div>
    </div> 
        
        
        
        <div class="AccordionPanel">
      <div class="AccordionPanelTab">Compilation troubleshooting</div>
      <div class="AccordionPanelContent">
        <H3><A NAME="SECTION00053100000000000000">
FFTW</A>
</H3>

<P>
If not installed, the FFTW-3 library needs to be installed. Most Linux package managers <TT>YaST</TT>, <TT>Synaptic</TT>, <TT>apt-get</TT> etc. provide the FFTW-3 library. On a Mac system the <TT>Fink</TT> and <TT>Macports</TT> package managers provide the FFTW-3 library or it can be obtained from: <TT><A NAME="tex2html1"
  HREF="http://www.fftw.org/install/mac.html" target="new">http://www.fftw.org/install/mac.html</A></TT>. SIMPLE relies on the single-precision FFTW library. Typically we will need to
<PRE>
    $ ./configure --enable-floats
    $ make
    $ sudo make install
</PRE>

<P>
The <TT>-enable floats</TT> directive is critical as the installer will otherwise only install the double-precision version of the library. We check that we have in the lib folder (typically: <TT>/usr/local/lib/</TT>):

<P>
<PRE>
    libfftw3.a libfftw3.la
    libfftw3f.a libfftw3f.la
</PRE>

<P>
Similarly the <TT>lapack3</TT> and <TT>BLAS</TT> will need to be installed on the system. On MacOSX Lapack and BLAS are usually installed by default. Installation of the dependencies on a PC with a Debian operating system, such as Ubuntu or Mint, is done using the <TT>apt-get install command</TT> as a super user

<PRE>
    #the compilers
    $ sudo apt-get install gfortran gfortran-4.9 gcc-4.9 g++-4.9
    #libraries (Lapack and BLAS)
    $ sudo apt-get install scalapack-doc scalapack-mpi-test
    scalapack-pvm-test scalapack-test-common  libscalapack-pvm1
    libscalapack-pvm-dev libscalapack-openmpi1 libopenblas-base
    libopenblas-dev libmlpack-dev libblas-dev libblas3 liblapack-dev
    liblapack-doc liblapack-doc-man liblapack3 libopenmpi-dev
    libmeep-mpich2-dev
    #FFTW-3
    $ sudo apt-get install libfftw3-bin libfftw3-dbg libfftw3-dev
    libfftw3-doc libfftw3-double3 libfftw3-long3 libfftw3-quad3
    libfftw3-single3 cl-fftw3 fftw-dev fftw-docs libfftw3-3
    libfftw3-mpi-dev libfftw3-mpi3
</PRE>

<H3><A NAME="SECTION00053200000000000000">
Compilers</A>
</H3>

<P>
One possible cause of failing compilation may be that the compiler paths are not correctly set in the <TT>simple_user_input.pm</TT> file. A typical configuration on Ubuntu looks like

<P>
<PRE>
    our$CC_COMPILER = "gcc-4.9";
    our$GCC_COMPILER = "g++-4.9";
    our$MPI_F_COMPILER = "/usr/bin/mpif90";
    our$FCOMPILER = "gfortran-4.9";
</PRE>

<P>
A configuration on MacOSX could look like

<P>
<PRE>
    our$CC_COMPILER = "/usr/local/bin/gcc";
    our$GCC_COMPILER = "/usr/local/bin/g++";
    our$MPI_F_COMPILER = "/usr/local/bin/mpif90";
    our$FCOMPILER = "/usr/local/bin/gfortran";
</PRE>

<P>
If we used the <TT>Fink</TT> package manager to install the GNU toolchain on MacOSX, the configuration will typically look like:

<P>
<PRE>
    our$CC_COMPILER = "/sw/bin/gcc-fsf-5";
    our$GCC_COMPILER = "/sw/bin/g++-fsf-5";
    our$MPI_F_COMPILER = "/sw/bin/mpif90";
    our$FCOMPILER = "/sw/bin/gfortran";
</PRE>

<P>
If we are on MacOSX and used the <TT>MacPorts</TT> package manager to install the GNU toolchain, the configuration will typically look like:

<P>
<PRE>
    our$CC_COMPILER = "/opt/local/bin/gcc";
    our$GCC_COMPILER = "/opt/local/bin/g++";
    our$MPI_F_COMPILER = "/opt/local/bin/mpif90";
    our$FCOMPILER = "/opt/local/bin/gfortran";
</PRE>

<P>
On MacOSX it is required that the correct Command Line Tools for <TT>Xcode</TT> are installed. If we use the package managers <TT>Fink</TT> or <TT>MacPorts</TT> this is taken care of as part of the installation procedure. The <TT>gfortran-5</TT>,  <TT>gcc-5</TT> and <TT>g++-5</TT> compilers can be installed via the <TT>apt-get</TT>, <TT>Synaptic</TT> or <TT>YaST</TT> package managers on Linux systems. Beware that Apple have their own gcc compiler (for objective-C) which is different than the GNU one and will generate errors upon compilation.

<P>
<PRE>
    $ gcc --version 
    Configured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr
    --with-gxx-include-dir=/usr/include/c++/4.2.1
    Apple LLVM version 6.0 (clang-600.0.54) (based on LLVM 3.5svn)
    Target: x86_64-apple-darwin13.4.0
    Thread model: posix
</PRE>

<P>
The compilation needs to be using the GNU compiler and <B><I>not</I></B> the Apple one. Otherwise the compilation will not work. Make sure that the paths in <TT>simple_user_input.pm</TT> are pointing to the correct location

<P>
<PRE>
    $SIMPLE_PATH= {path where simple will be installed}
    $CC_COMPILER = {path to the gcc compiler on MacOSX,
                     default: /usr/local/bin/gcc}
    $GCC_COMPILER = {path to the g++ compiler on MacOSX,
                     default: /usr/local/bin/g++}
    $MPI_F_COMPILER = {path to the mpif90 compiler on MacOSX, 
                       default:/usr/local/bin/mpif90}
    $FCOMPILER = {path to the gfortran or ifort compiler on MacOSX,
                   default: /usr/local/bin/gfortran}

    $MPI_DIR={path to the mpi directory, default:/usr}
    $MPI_DIR_INCLUDE="/usr/include/mpi";
    $FFTW_LIB={path for to the FFTW lib, default: /usr/local/lib}
    $FFTW_INC={path to the include for the FFTW, default:
    /usr/local/fftw/3.3.4-gcc/include/} cluster dependent

    $OBJDIR={path to the object compiled files, default: obj/GFORTgpu}
    $MODDIR={path to the .mod files, default: obj/GFORTgpu}
</PRE>
All of the compilers must originate from the same version of the GNU toolchain.

<H2><A NAME="SECTION00054000000000000000"></A>
<A NAME="inst_clusters_linux"></A>
<BR>    
        </div>
    </div>
    
    
    
    <div class="AccordionPanel">
      <div class="AccordionPanelTab">Installation on a Linux cluster</div>
      <div class="AccordionPanelContent">
        
        
        <P>
Installation on a Linux cluster is essentially the same as on a Linux workstation with the exception that the appropriate modules need to be loaded before installation and execution. On a typical SLURM cluster

<P>
<PRE>
    $ module load fftw/3.3.4-gcc
    $ module load gcc/4.9.1
    $ module load lapack/3.4.2
</PRE>

<P>
The instructions for how to execute SIMPLE in distributed environments (clusters or workstations with more than one CPU socket) are described <a href="workflows.html#distr" target="new">here</a>.
        
        </div>
    </div>
    
    
    
    <div class="AccordionPanel">
      <div class="AccordionPanelTab">Pre-compiled binaries for MacOSX</div>
      <div class="AccordionPanelContent">
        
        <P>
We also provide a script for automatic installation of pre-compiled binaries on MacOSX. Download the tar ball and untar it in the directory of your choice 
<PRE>
    $ tar -xvzf Install_Simple_MacOSX_binaries.tar.gz
</PRE>
Change directory 
<PRE>
    $ cd &lt;path to&gt;/Install_Simple_MacOSX_binaries
</PRE>
This installation route requires administration rights, since the script will install GNU compilers version 4.9 and the FFTW library (v3.4.4) in <TT>/usr/local/bin</TT> and <TT>/usr/local/lib</TT> respectively. Don't use this script if you have other GNU compiler versions installed in these folders that you do not wish to have overwritten. To proceed with the installation specify the absolute path of the target location for the installation.
<PRE>
    $ sudo csh install_MacOSX_binaries_prod.csh /Users/&lt;username&gt;/Simple
</PRE>
Enter your admin user password and wait. This may take a while because the fftw-3.4.4 library needs to be compiled for the most commonly used precisions. The scripts installs and checks for the correctness of the installed compilers (i.e. gcc, g++ and gfortran) in the <TT>/usr/local/bin</TT> folder. It
should look like
<PRE>
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-                       Checking installation ...                       -
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-                                                                       -
-                      fftw-3.3.4 library ...                           -
-                                                                       -
libfftw3.a	    libfftw3f.a	         libfftw3l.a	      libfftw3q.a
libfftw3.la	    libfftw3f.la	 libfftw3l.la	      libfftw3q.la
libfftw3_omp.a	    libfftw3f_omp.a	 libfftw3l_omp.a      libfftw3q_omp.a
libfftw3_omp.la	    libfftw3f_omp.la     libfftw3l_omp.la     libfftw3q_omp.la
libfftw3_threads.a  libfftw3f_threads.a  libfftw3l_threads.a  libfftw3q_threads.a
libfftw3_threads.la libfftw3f_threads.la libfftw3l_threads.la libfftw3q_threads.la
-                                                                       -
-    GNU compilers /usr/local/bin/{gcc-4.9,g++-4.9, gfortran-4.9} ...   -
-                                                                       -
g++	gcc	gfortran {... plus other files ...}

gcc (GCC) 4.9.2 20141029 (prerelease)
Copyright (C) 2014 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

g++ (GCC) 4.9.2 20141029 (prerelease)
Copyright (C) 2014 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

GNU Fortran (GCC) 4.9.2 20141029 (prerelease)
Copyright (C) 2014 Free Software Foundation, Inc.

GNU Fortran comes with NO WARRANTY, to the extent permitted by law.
You may redistribute copies of GNU Fortran
under the terms of the GNU General Public License.
For more information about these matters, see the file named COPYING
</PRE>
A successful completion of script provides the final steps for
successful installation and should show:
<PRE>
    ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! !
    !                                                                       !
    !            You now need to add the environment variable in            !
    !                your ~/.bashrc or shell rc:                            !
    !                                                                       !
                                 in bash                                     
    export SIMPLEPATH=/Users/&lt;username&gt;/Simple/MacOSX_binaries 
    export PATH=${SIMPLEPATH}/scripts:${SIMPLEPATH}/bin:$PATH        
                                                                                                                 
                         in shell or cshell or tshell                        
                                           
    setenv SIMPLEPATH /Users/&lt;username&gt;/Simple/MacOSX_binaries
    set path=(${SIMPLEPATH}/scripts ${SIMPLEPATH}/bin $path)
    !                                                                       !
        Check ownership of installation path: /Users/&lt;username&gt;/Simple                   
             if it has root and not &lt;username&gt; then change it by:                 
    !                                                                       !
                    sudo chown -R &lt;username&gt; /Users/&lt;username&gt;/Simple                         
    !                                                                       !
    !          You may now start using SIMPLE from command line             !
          and go to: /Users/&lt;username&gt;/Simple/MacOSX_binaries                            
    !                       to launch the checks                             
    !                                                                       !
                            csh launch_checks.csh                            
    !                                                                       !
    ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! !
</PRE>
To check the owner ship of the target location
<PRE>
    $ ls -al /Users/&lt;username&gt;/Simple
    total 0
    drwxr-xr-x   3 root       staff  102 20 May 12:48 .
    drwxr-xr-x+ 26 &lt;username&gt; staff  884 20 May 13:36 ..
    drwxr-xr-x   7 root       staff  238 20 May 14:03 MacOSX_binaries
</PRE>
We recommend changing ownership to <TT>&lt;username&gt;</TT> via   
<PRE>
    $ sudo chown -R &lt;username&gt; /Users/&lt;username&gt;/Simple
</PRE>
and to confirm that the rights were changed, execute
<PRE>
    $ ls -al /Users/&lt;username&gt;/Simple
    total 0
    drwxr-xr-x   3 &lt;username&gt; staff  102 20 May 12:48 .
    drwxr-xr-x+ 26 &lt;username&gt; staff  884 20 May 13:36 ..
    drwxr-xr-x   7 &lt;username&gt; staff  238 20 May 14:03 MacOSX_binaries
</PRE>
Lastly, we need to add a few paths to our shell environment. This enables running simple commands from the prompt anywhere in the user directory structure and. If you are using the bash shell, add to your <TT>.bashrc</TT>
<PRE>
    export SIMPLEPATH=/Users/&lt;username&gt;/Simple/MacOSX_binaries
    export PATH=${SIMPLEPATH}/scripts:${SIMPLEPATH}/bin:$PATH
</PRE>
and if you are using the c-shell or the tc-shell, add to your <TT>.cshrc</TT> or <TT>.tcshrc</TT>
<PRE>
    setenv SIMPLEPATH /Users/&lt;username&gt;/Simple/MacOSX_binaries
    set path=(${SIMPLEPATH}/scripts ${SIMPLEPATH}/bin $path)
</PRE>
Do not forget to source the environment by typing
<PRE>
    #for bash
    $ source ~/.bashrc
    #for cshell
    $ source ~/.cshrc
</PRE>
Once this is done, launch the checks in /Simple/MacOSX_binaries:
<PRE>
    $ cd /Users/<username>/Simple/MacOSX_binaries
    $ csh launch_checks.csh
</PRE>
If the checks passes the installation is complete.

        
        
        </div>
    </div>
        
        
        
 </div>
<!-- ACCORDION 1 END -->



<!-- ACCORDION 2 START -->

<!-- 2D alignment/clustering
    (1) prime2D_init
    (2) prime2D
    (3) rank_cavgs
    (4) map2ptcls
    (5) doc2cavgs -->
      
	<h2 class="h2_manual" align="left"> <a name="prime2D"></a>&nbsp; &nbsp;2D alignment/clustering</h2>
    
	<div id="Accordion2" class="Accordion" >
    
        <div class="AccordionPanel">
      <div class="AccordionPanelTab">simple_prime2D_init</div>
      <div class="AccordionPanelContent">
        <p><strong>simple_prime2D_init</strong> is a program for initialising prime2D. We use it to produce the initial random references when executing <em>simple_prime2D</em> in distributed mode using <em>distr_simple.pl</em>.</p>
        <p align="left"><span class="h2_manual">Usage:<br>
     </span> &gt;&gt;&gt;<strong>simple_prime2D_init </strong><em>stk</em>=&lt;stack.ext&gt; <em>smpd</em>=&lt;sampling distance(in A)&gt; <em>msk</em>=&lt;mask radius(in pixels)&gt; <em>ncls</em>=&lt;nr of clusters&gt; [<em>nthr</em>=&lt;nr of OpenMP threads{1}&gt;] [<em>oritab</em>=&lt;input doc&gt;]<br></p>
    <p><span class="h2_manual">Comments:<br>
    </span> The program assumes that the images have been phase-flipped, as no CTF correction by Wiener restoration is implemented yet. The random clustering and in-plane alignment will be printed in the file <em>prime2D_startdoc.txt</em> produced by the program. This file is used together with the initial references (<em>startcavgsmsk.ext</em>) to execute PRIME2D in distributed mode by <em>distr_simple.pl</em>.</p>
    	</div>
    </div>
    
    
        <div class="AccordionPanel">
          <div class="AccordionPanelTab">simple_prime2D</div>
          <div class="AccordionPanelContent">
            <p><strong>simple_prime2D</strong> is a reference-free 2D alignment/clustering algorithm adopted from the prime3D probabilistic ab initio 3D reconstruction algorithm. It is assumed that the images are phase-flipped (phase flipping can be done with <em>simple_stackops</em>). Do not search the origin shifts initially, when the cluster centers are of low quality. If your images are far off centre, use <em>simple_stackops</em> with option <em>shalgn=yes</em> instead to shiftalign the images beforehand (the algorithm implemented is the same as EMAN's <em>cenalignint</em> program). Use <em>distr_simple.pl</em> for distributed PRIME2D execution.</p>
            <p align="left"><span class="h2_manual">Usage:<br>
         </span> &gt;&gt;&gt;<strong>simple_prime2D </strong><em>stk</em>=&lt;stack.ext&gt; <em>smpd</em>=&lt;sampling distance(in A)&gt; <em>msk</em>=&lt;mask radius(in pixels)&gt; <em>ncls</em>=&lt;nr of clusters&gt; <em>refs</em>=&lt;initial_references.ext&gt; <em>oritab</em>=&lt;previous clustering doc&gt; [<em>lp</em>=&lt;low-pass limit(in A){20}&gt;] [<em>trs</em>=&lt;origin shift(in pixels){0}&gt;] [<em>nthr</em>=&lt;nr of OpenMP threads{1}&gt;] [<em>startit</em>=&lt;start iteration&gt;] [<em>hp</em>=&lt;high-pass limit(in A)&gt;] [<em>srch_inpl</em>=&lt;yes|no{yes}&gt;]<br>

            <strong>** less commonly used**</strong>  [<em>maxits</em>=&lt;max iterations{500}&gt;] [<em>inner</em>=&lt;inner mask radius(in pixels)&gt;] [<em>width</em>=&lt;pixels falloff inner mask(in pixels){10}&gt;]</p>
        </div>
        </div>



    <div class="AccordionPanel">
      <div class="AccordionPanelTab">simple_rank_cavgs</div>
      <div class="AccordionPanelContent">
        <p><strong>simple_rank_cavgs</strong> is a program for ranking class averages by decreasing population, given the stack of class averages (<em>stk</em> argument) and the 2D orientations document (<em>oritab</em>) generated by <em>simple_prime2D</em>.</p>
        <p align="left"><span class="h2_manual">Usage:<br>
     </span> &gt;&gt;&gt;<strong>simple_rank_cavgs </strong><em>stk</em>=&lt;cavgs.ext&gt; <em>oritab</em>=&lt;2D clustering doc&gt; [<em>outstk</em>=&lt;ranked cavgs stack&gt;]<br></p>
    </div>
    </div>



    <div class="AccordionPanel">
      <div class="AccordionPanelTab">simple_map2ptcls</div>
      <div class="AccordionPanelContent">
        <p><strong>simple_map2ptcls</strong> is a program for mapping parameters that have been obtained using class averages to the individual particle images. There are many functionalities present that will become critical in future releases. Right now we recommend using this program exclusively to exclude the particles corresponding to deselected class averages. See the workflows section of the manual for further info.</p>
        <p align="left"><span class="h2_manual">Usage:<br>
     </span> &gt;&gt;&gt;<strong>simple_map2ptcls </strong><em>stk</em>=&lt;particles.ext&gt; <em>stk2</em>=&lt;selected_cavgs.ext&gt; <em>stk3</em>=&lt;orig_cavgs.ext&gt; <em>oritab</em>=&lt;PRIME 2D doc&gt; [<em>oritab2</em>=&lt;prime3D shc doc&gt;] [<em>comlindoc</em>=&lt;shc_clustering_nclsX.txt&gt;] [<em>doclist</em>=&lt;list of oritabs for the different states&gt;] [<em>deftab</em>=&lt;text file defocus values&gt;] [<em>outfile</em>=&lt;output parameter file{mapped_ptcls_params.txt}&gt;] [<em>nthr</em>=&lt;nr of OpenMP threads{1}&gt;]<br></p>
    </div>
    </div>
    
    
<div class="AccordionPanel">
  <div class="AccordionPanelTab">simple_doc2cavgs</div>
  <div class="AccordionPanelContent">
    <p><strong>simple_doc2cavgs</strong> is a program for generating class averages. We use it to to re-generate class averages when <em>simple_prime2D</em> has been run on downscaled images. If the images processed with PRIME2D were downscaled from 200x200 to 100x00, set <em>mul=2</em>.</p>
    <p align="left"><span class="h2_manual">Usage:<br>
 </span> &gt;&gt;&gt;<strong>simple_doc2cavgs </strong><em>stk</em>=&lt;stack.ext&gt; <em>smpd</em>=&lt;sampling distance(in A)&gt; <em>msk</em>=&lt;mask radius(in pixels)&gt; <em>ncls</em>=&lt;nr of clusters&gt; <em>oritab</em>=&lt;previous clustering doc&gt; <em>which_iter</em>=&lt;iteration nr&gt; [<em>mul</em>=&lt;shift multiplication factor{1}&gt;] [<em>nthr</em>=&lt;nr of OpenMP threads{1}&gt;]<br></p>
<p><span class="h2_manual">Comments:<br>
</span> The program assumes that the images have been phase-flipped, as no CTF correction by Wiener restoration is implemented yet.</p>
</div>
</div>

</div>
 <!-- ACCORDION 2 END -->
 
 <!-- ******************************************* -->
 
<!-- ACCORDION 3 START -->

<!-- Ab initio 3D reconstruction
    (1) resrange
    (2) prime3D_init
    (3) prime3D
    (4) symsrch
    (5) recvol
    (6) eo_recvol -->
    
	<h2 class="h2_manual" align="left"><a name="prime3D"></a> &nbsp; &nbsp;Ab initio 3D reconstruction</h2>
    
	<div id="Accordion3" class="Accordion" >
    
    
      <div class="AccordionPanel">
        <div class="AccordionPanelTab">simple_resrange</div>
        <div class="AccordionPanelContent">
          <p><strong>simple_resrange</strong> is a program for estimating the resolution range used in the heuristic resolution-stepping scheme in the PRIME3D initial model production procedure. The initial low-pass limit is set so that each image receives ten nonzero orientation weights. When quasi-convergence has been reached, the limit is updated one Fourier index at the time, until PRIME reaches the condition where six nonzero orientation weights are assigned to each image. FSC-based filtering is unfortunately not possible to do in the ab initio reconstruction step, because when the orientations are mostly random, the FSC overestimates the resolution. This program is used internally by <em>distr_simple.pl</em> when executing PRIME in distributed mode. We advise you to check the starting and stopping low-pass limits before executing PRIME3D using this program.</p>
          <p align="left"><span class="h2_manual">Usage:<br>
       </span> &gt;&gt;&gt;<strong>simple_resrange </strong><em>smpd</em>=&lt;sampling distance(in A)&gt; [<em>nspace</em>=&lt;nr of reference sections{1000}&gt;] [<em>pgrp</em>=&lt;cn|dn|t|o|i{c1}&gt;] [<em>box</em>=&lt;image size(in pixels)&gt;] [<em>moldiam</em>=&lt;molecular diameter(in A))&gt;]<br></p>
      <p><span class="h2_manual">Comments:<br>
      </span> The resolution range estimate depends on the molecular diameter, which is estimated based on the box size. If you want to override this estimate, set <em>moldiam</em> to the desired value (in A). This may be necessary if your images have a lot of background "padding". However, for starting model generation it is probably better to clip the images snugly around the particle, because smaller images equal less computation.</p>
      </div>
      </div>
    
    
    <div class="AccordionPanel">
      <div class="AccordionPanelTab">simple_prime3D_init</div>
      <div class="AccordionPanelContent">
        <p><strong>simple_prime3D_init</strong> is a program for generating a random initial model for initialisation of PRIME3D when executed in distributed mode. It is assumed that the images have been phase flipped. If the data set is large (&gt;5000 images), generating a random model can be quite slow. To speedup, set <em>nran</em> to some smaller number, resulting in <em>nran</em> images selected randomly for reconstruction.</p>
        <p align="left"><span class="h2_manual">Usage:<br>
     </span> &gt;&gt;&gt;<strong>simple_prime3D_init </strong><em>stk</em>=&lt;stack.ext&gt; <em>smpd</em>=&lt;sampling distance(in A)&gt; <em>msk</em>=&lt;mask radius(in pixels)&gt; [<em>nspace</em>=&lt;nr reference sections{1000}&gt;] [<em>nran</em>=&lt;size of random sample&gt;] [<em>lp</em>=&lt;low-pass limit(in A)&gt;] [<em>nthr</em>=&lt;nr OpenMP threads{1}&gt;]<br>

        <strong>** less commonly used**</strong> [<em>pgrp</em>=&lt;cn|dn|t|o|i{c1}&gt;] [<em>npeaks</em>=&lt;nr nonzero orientation weights{1}&gt;] [<em>ctf</em>=&lt;yes|no|flip|mul{no}&gt;] [<em>kv</em>=&lt;acceleration voltage(in kV){300.}&gt;] [<em>fraca</em>=&lt;frac amp contrast{0.07}&gt;] [<em>cs</em>=&lt;spherical aberration constant(in mm){2.7}&gt;] [<em>deftab</em>=&lt;text file with defocus values&gt;] [<em>inner</em>=&lt;inner mask radius(in pixels)&gt;] [<em>width</em>=&lt;pixels falloff inner mask{10}&gt;] [<em>xfel</em>=&lt;yes|no{no}&gt;]</p>
    </div>
    </div>
    
    <div class="AccordionPanel">
      <div class="AccordionPanelTab">simple_prime3D</div>
      <div class="AccordionPanelContent">
        <p><strong>simple_prime3D</strong> is an ab inito reconstruction/refinement program based on probabilistic projection matching. PRIME is shorthand for PRobabilistic Initial 3D Model Generation for Single-Particle Cryo-Electron Microscopy. You should use phase-flipped images for initial model production with PRIME3D (phase flipping can be done with <em>simple_stackops</em>). Do not search the origin shifts initially, when the model is of very low quality. If your images are far off centre, use <em>simple_stackops</em> with option <em>shalgn=yes</em> instead to shiftalign the images beforehand (the algorithm implemented is the same as EMAN's <em>cenalignint</em> program). We recommend running the first round of PRIME with the default dynamic resolution stepping <em>dynlp=yes</em>. The <em>dynlp</em> option implements a heuristic resolution weighting/update scheme. The initial low-pass limit is set so that each image receives ten nonzero orientation weights. When quasi-convergence has been reached, the limit is updated one Fourier index at the time until PRIME reaches the condition where six nonzero orientation weights are assigned to each image. FSC-based filtering is unfortunately not possible to do in the ab initio reconstruction step, because when the orientations are mostly random, the FSC overestimates the resolution. Once the initial model has converged, we recommend start searching the shifts (by setting <em>trs</em> to some nonzero value), applying the FSC for resolution-weighting (by setting <em>eo=yes</em>). You should NOT give <em>ctf=flip</em> on the command line unless the model has converged. Giving <em>ctf=flip</em> on the command lines signal to PRIME that tou have obtain a reconstruction of decent resolution and you want to take it further by applying Wiener restoration by resolution-weighting the reocnstructed volume more accurately. In order to be able to use Wiener restoration you also need to input CTF parameters, for example via <em>deftab=defocus_values.txt</em>. Remember that the defocus values should be given in microns and the astigmatism angle in degrees (one row of the file <em>defocus_values.txt</em> may look like: <em>dfx=3.5</em> <em>dfy=3.3</em> <em>angast=20.0</em>).</p>
        <p align="left"><span class="h2_manual">Usage:<br>
     </span> &gt;&gt;&gt;<strong>simple_prime3D </strong><em>stk</em>=&lt;stack.ext&gt; <em>vol1</em>=&lt;invol.ext&gt; [<em>vol2</em>=&lt;refvol_2.ext&gt; etc.] <em>smpd</em>=&lt;sampling distance(in A)&gt; <em>msk</em>=&lt;mask radius(in pixels)&gt; [<em>oritab</em>=&lt;previous alignment doc&gt;] [<em>trs</em>=&lt;origin shift(in pixels){0}&gt;] [<em>lp</em>=&lt;low-pass limit{20}&gt;] [<em>dynlp</em>=&lt;yes|no{yes}&gt;] [<em>nstates</em>=&lt;nstates to reconstruct&gt;] [<em>frac</em>=&lt;fraction of ptcls to include{1}&gt;] [<em>mw</em>=&lt;molecular weight(in kD)&gt;] [<em>nthr</em>=&lt;nr of OpenMP threads{1}&gt;] [<em>startit</em>=&lt;start iteration&gt;] [<em>refine</em>=&lt;no|shc|neigh|shcneigh{no}&gt;] [<em>lpstop</em>=&lt;stay at this low-pass limit (in A)&gt;] [<em>deftab</em>=&lt;text file defocus values&gt;] [<em>nspace</em>=&lt;nr reference sections{1000}&gt;] [<em>eo</em>=&lt;yes|no{no}&gt;] [<em>amsklp</em>=&lt;automask low-pass limit(in A)&gt;] [<em>pgrp</em>=&lt;cn|dn|t|o|i{c1}&gt;] [<em>ctf</em>=&lt;yes|no|flip|mul{no}&gt;] [<em>kv</em>=&lt;acceleration voltage(in kV){300.}&gt;] [<em>cs</em>=&lt;spherical aberration constant(in mm){2.7}&gt;] [<em>fraca</em>=&lt;frac amp contrast{0.07}&gt;] [<em>hp</em>=&lt;high-pass limit(in A)&gt;] [<em>diversify</em>=&lt;yes|no{yes}&gt;] [<em>xfel</em>=&lt;yes|no{no}&gt;]<br>

        <strong>** less commonly used**</strong>  [<em>maxits</em>=&lt;max iterations{100}&gt;] [<em>edge</em>=&lt;edge size for softening molecular envelope(in pixels){3}&gt;] [<em>noise</em>=&lt;yes|no{no}&gt;] [<em>npeaks</em>=&lt;number of nonzero orientation weights&gt;] [<em>dens</em>=&lt;density(e.g. 9.368 Da/A3 4 gold clusters){0.}&gt;] [<em>nvox</em>=&lt;nr of voxels in mask{0}&gt;] [<em>inner</em>=&lt;inner mask radius(in pixels)&gt;] [<em>width</em>=&lt;pixels falloff inner mask{10}&gt;]</p>
    <p><span class="h2_manual">Comments:<br>
    </span> Note that we do not assume any point-group symmetry in the initial runs. However, the <em>simple_symsrch</em> program can be used to align the reconstruction to its symmetry axis so that future searches can be restricted to the asymmetric unit in refinement. Less commonly used and less obvious input parameters are <em>nspace</em>, which  controls the number of reference projections, <em>amsklp</em>, which controls the low-pass limit used in the automask routine, <em>maxits</em>, which controls the maximum number of iterations executed, <em>pgrp</em>, which controls the point-group symmetry, assuming that the starting volume is aligned to its principal symmetry axis, <em>edge</em>, which controls the size of the softening edge in the automask routine.</p>
    </div>
    </div>
    
    
    
    <div class="AccordionPanel">
      <div class="AccordionPanelTab">simple_symsrch</div>
      <div class="AccordionPanelContent">
        <p><strong>simple_symsrch</strong> is a program for searching for the principal symmetry axis of a volume reconstructed without assuming any point-group symmetry. Our philosophy is to start off without assuming any symmetry, and then analyzse the reconstructed volume to identify the correct point-group symmetry. <em>simple_symsrch</em> can be used for this purpose. The program takes as input the asymmetrical reconstruction (obtained with <em>simple_prime3D</em>), the alignment document for all the particle images that have gone into the reconstruction, and the desired point-group symmetry. It then projects the reconstruction in 20 (default option) even directions, uses common lines-based optimisation to identify the principal symmetry axis, applies the rotational transformation to the inputted orientations, and produces a new alignment document. Input this document to <em>simple_recvol</em> or <em>simple_eo_recvol</em> together with the images and the point-group symmetry to generate a symmetrised map. If you are unsure about the point-group, you should of course test many different point-groups and compare the asymmetric map with the symmetrised maps. SIMPLE now implements most point-groups: c- and d-groups, as well as tetrahedral, octahedral, and icosahedral groups.</p>
        <p align="left"><span class="h2_manual">Usage:<br>
     </span> &gt;&gt;&gt;<strong>simple_symsrch </strong><em>vol1</em>=&lt;vol.ext&gt; <em>smpd</em>=&lt;sampling distance(in A)&gt; <em>oritab</em>=&lt;input alignment doc&gt; <em>pgrp</em>=&lt;cn|dn|t|o|i{c1}&gt; <em>outfile</em>=&lt;output alignment doc&gt; <em>lp</em>=&lt;low-pass limit(in A)&gt; [<em>amsklp</em>=&lt;low-pass limit for centering mask(in A){50}&gt;] [<em>hp</em>=&lt;high-pass limit(in A)&gt;] [<em>nthr</em>=&lt;nr openMP threads{1}&gt;] [<em>nspace</em>=&lt;nr of projs{20}&gt;]<br></p>
    <p><span class="h2_manual">Comments:<br>
    </span> The <em>state</em> parameter allows you to apply symmetry for the given state.</p>
    </div>
    </div>
    
    
    <div class="AccordionPanel">
      <div class="AccordionPanelTab">simple_recvol</div>
      <div class="AccordionPanelContent">
        <p><strong>simple_recvol</strong> is a program for reconstructing volumes from MRC and SPIDER stacks, given input orientations and state assignments (obtained by program <em>simple_prime3D</em>). The algorithm is based on direct Fourier inversion with a Kaiser-Bessel (KB) interpolation kernel. This window function reduces the real-space ripple artifacts associated with direct moving windowed-sinc interpolation. The feature sought when implementing this algorithm was to enable quick, reliable reconstruction from aligned individual particle images.</p>
        <p align="left"><span class="h2_manual">Usage:<br>
     </span> &gt;&gt;&gt;<strong>simple_recvol </strong><em>stk</em>=&lt;ptcls.ext&gt; <em>smpd</em>=&lt;sampling distance(in A)&gt; <em>oritab</em>=&lt;algndoc.txt&gt; <em>msk</em>=&lt;mask radius(in pixels)&gt; [<em>lp</em>=&lt;low-pass limit{20}&gt;] [<em>frac</em>=&lt;fraction of ptcls to include{1.}&gt;] [<em>nthr</em>=&lt;nr of openMP threads{1}&gt;] [<em>pgrp</em>=&lt;cn|dn|t|o|i{c1}&gt;]<br>

        <strong>** less commonly used**</strong> [<em>mw</em>=&lt;molecular weight(in kD)&gt;] [<em>amsklp</em>=&lt;low-pass limit(in A){20}&gt;] [<em>mul</em>=&lt;shift multiplication factor{1}&gt;] [<em>ctf</em>=&lt;yes|no|flip|mul{no}&gt;] [<em>kv</em>=&lt;acceleration voltage(in kV){300.}&gt;] [<em>fraca</em>=&lt;frac amp contrast{0.07}&gt;] [<em>cs</em>=&lt;spherical aberration constant(in mm){2.7}&gt;] [<em>deftab</em>=&lt;text file defocus values&gt;] [<em>state</em>=&lt;state to reconstruct{all}&gt;] [<em>edge</em>=&lt;edge size for softening molecular envelope(in pixels){3}&gt;] [<em>dens</em>=&lt;density(e.g.9.368 Da/A3 4 gold clusters){0.}&gt;] [<em>inner</em>=&lt;inner mask radius(in pixels)&gt;] [<em>width</em>=&lt;pixels falloff inner mask{10}&gt;] [<em>mirr</em>=&lt;yes|no{no}&gt;] [<em>even</em>=&lt;yes|no{no}&gt;] [<em>odd</em>=&lt;yes|no{no}&gt;]</p>
    <p><span class="h2_manual">Comments:<br>
    </span> <em>mul</em> is used to scale the origin shifts if down-sampled were used for alignment and the original images are used for reconstruction. This program can be run in distributed mode using <em>distr_simple.pl</em>. <em>ctf</em>, <em>kv</em>, <em>fraca</em>, <em>cs</em> and <em>deftab</em> are used to communicate CTF information to the program. <em>ctf=yes</em>, <em>ctf=flip</em> or <em>ctf=mul</em> turns on the Wiener restoration. If the images were pre-multiplied with CTF set <em>ctf=mul</em> or if the images were phase-flipped set <em>ctf=flip</em>. <em>amsklp</em>, <em>mw</em>, and <em>edge</em> are parameters that control the solvent mask: the low-pass limit used to generate the envelope; the molecular weight of the molecule (protein assumed but it works reasonably well also for RNA; slight modification of <em>mw</em> might be needed). The <em>inner</em> parameter controls the radius of the soft-edged mask used to remove the unordered DNA/RNA core of spherical icosahedral viruses. The <em>even</em> and <em>odd</em> parameters allow you to reconstruct either the even or the odd pair.</p>
    </div>
    </div>
    
    
<div class="AccordionPanel">
  <div class="AccordionPanelTab">simple_eo_recvol</div>
  <div class="AccordionPanelContent">
    <p><strong>simple_eo_recvol</strong> is a program for reconstructing volumes from MRC or SPIDER stacks, given input orientations and state assignments (obtained by program <em>simple_prime3D</em>). The algorithm is based on direct Fourier inversion with a Kaiser-Bessel (KB) interpolation kernel. This window function reduces the real-space ripple artefacts associated with direct moving windowed-sinc interpolation. The feature sought when implementing this algorithm was to enable quick, reliable reconstruction from aligned individual particle images. The even and odd pairs are automatically reconstructed, the FSC calculated, and the Wiener filter formalism used for image restoration (CTF correction). Use <em>distr_simple.pl</em> for distributed execution.</p>
    <p align="left"><span class="h2_manual">Usage:<br>
 </span> &gt;&gt;&gt;<strong>simple_eo_recvol </strong><em>stk</em>=&lt;ptcls.ext&gt; <em>msk</em>=&lt;mask radius(in pixels)&gt; <em>smpd</em>=&lt;sampling distance(in A)&gt; <em>oritab</em>=&lt;algndoc.txt&gt; [<em>frac</em>=&lt;fraction ptcls to include{1.}&gt;] [<em>nthr</em>=&lt;nr openMP threads{1}&gt;] [<em>pgrp</em>=&lt;cn|dn|t|o|i{c1}&gt;]<br>

    <strong>** less commonly used**</strong> [<em>mul</em>=&lt;shift multiplication factor{1}&gt;] [<em>ctf</em>=&lt;yes|no|flip|mul{no}&gt;] [<em>kv</em>=&lt;acceleration voltage(in kV){300.}&gt;] [<em>fraca</em>=&lt;frac amp contrast{0.07}&gt;] [<em>cs</em>=&lt;spherical aberration constant(in mm){2.7}&gt;] [<em>deftab</em>=&lt;text file defocus values&gt;] [<em>state</em>=&lt;state to reconstruct{all}&gt;] [<em>mw</em>=&lt;molecular weight(in kD)&gt;] [<em>amsklp</em>=&lt;low-pass limit(in A){20}&gt;] [<em>edge</em>=&lt;edge size softening molecular envelope(in pixels){3}&gt;] [<em>inner</em>=&lt;inner mask radius(in pixels)&gt;] [<em>width</em>=&lt;pixels falloff inner mask{10}&gt;]</p>
<p><span class="h2_manual">Comments:<br>
</span> <em>mul</em> is used to scale the origin shifts if down-sampled images were used for alignment and the original images are used for reconstruction. <em>ctf</em>, <em>kv</em>, <em>fraca</em>, <em>cs</em> and <em>deftab</em> are used to communicate CTF information to the program. <em>ctf=yes</em>, <em>ctf=flip</em> or <em>ctf=mul</em> turns on the Wiener restoration. If you input CTF info to the program, please ensure that the correct kV, Cs and fraca (fraction of amplitude contrast) parameters are inputted as well. If the images were pre-multiplied with the CTF, set <em>ctf=mul</em> or if the images were phase-flipped set <em>ctf=flip</em>. <em>amsklp</em> and <em>mw</em> parameters control the solvent mask: the low-pass limit used to generate the envelope; the molecular weight of the molecule (protein assumed but it works reasonably well also for RNA; slight modification of <em>mw</em> might be needed). The <em>inner</em> parameter controls the radius of the soft-edged mask used to remove the unordered DNA/RNA core of spherical icosahedral viruses.</p>
</div>
</div>


</div>
 <!-- ACCORDION 3 END -->
 
 
<!-- ACCORDION 4 START -->

<!-- Standard image/volume operations (ops)
    (1) automask 
    (2) converter
    (3) iminfo 
    (4) simimgs
    (5) stackops
    (6) volops -->
    
	<h2 class="h2_manual" align="left"> <a name="operations"></a>&nbsp; &nbsp;Standard image/volume operations (ops)</h2>
    
	<div id="Accordion4" class="Accordion" >
    
    
      <div class="AccordionPanel">
        <div class="AccordionPanelTab">simple_automask</div>
        <div class="AccordionPanelContent">
          <p><strong>simple_automask</strong> is a program for solvent flattening of a volume (MRC or SPIDER). The algorithm for background removal is based on low-pass filtering and binarization. First, the volume is low-pass filtered to <em>amsklp</em>. A binary volume is then generated by assigning foreground pixels (=1) based on the volume calculated from the molecular weight, assuming a protein density of 1.43 g/mL. A real-space low-pass filter softens the edge of the resulting binary volume before multiplying it with the unmasked input volume to generate the flattened map.</p>
          <p align="left"><span class="h2_manual">Usage:<br>
       </span> &gt;&gt;&gt;<strong>simple_automask </strong><em>vol1</em>=&lt;invol.ext&gt; [<em>vol2</em>=&lt;invol2.ext&gt; etc.] <em>smpd</em>=&lt;sampling distance(in A)&gt; [<em>mw</em>=&lt;molecular weight(in kD)&gt;] [<em>amsklp</em>=&lt;low-pass limit(in A){20}&gt;] [<em>nthr</em>=&lt;nr of OpenMP threads{1}&gt;]<br>

          <strong>** less commonly used**</strong> [<em>edge</em>=&lt;edge size for softening molecular envelope(in pixels){3}&gt;]</p>
      </div>
      </div>
      
      
      <div class="AccordionPanel">
        <div class="AccordionPanelTab">simple_converter</div>
        <div class="AccordionPanelContent">
          <p><strong>simple_converter</strong> is a program for converting between SPIDER and MRC formats.</p>
          <p align="left"><span class="h2_manual">Usage:<br>
       </span> &gt;&gt;&gt;<strong>simple_converter </strong>[<em>stk</em>=&lt;input particle stack&gt;] [<em>vol1</em>=&lt;invol.ext&gt;] [<em>outstk</em>=&lt;output particle stack&gt;] [<em>outvol</em>=&lt;outvol.ext&gt;]<br></p>
      </div>
      </div>
      
      
      <div class="AccordionPanel">
        <div class="AccordionPanelTab">simple_iminfo</div>
        <div class="AccordionPanelContent">
          <p><strong>simple_iminfo</strong> is a program for printing header information in MRC and SPIDER stacks and volumes</p>
          <p align="left"><span class="h2_manual">Usage:<br>
       </span> &gt;&gt;&gt;<strong>simple_iminfo </strong>[<em>fname</em>=&lt;filename.ext&gt;] [<em>box</em>=&lt;box size(pixels)&gt;] [<em>smpd</em>=&lt;sampling distance(in A)&gt;] [<em>stats</em>=&lt;yes|no|print{no}&gt;]<br></p>
      </div>
      </div>
      
      <div class="AccordionPanel">
        <div class="AccordionPanelTab">simple_stackops</div>
        <div class="AccordionPanelContent">
          <p><strong>simple_stackops</strong> is a program that provides standard single-particle image processing routines that are applied to MRC or SPIDER stacks.</p>
          <p align="left"><span class="h2_manual">Usage:<br>
       </span> &gt;&gt;&gt;<strong>simple_stackops </strong>[<em>stk</em>=&lt;stack.ext&gt;] [<em>stk2</em>=&lt;stack2.ext&gt;] [<em>nptcls</em>=&lt;nr of imgs&gt;] [<em>smpd</em>=&lt;sampling distance(in A)&gt;] [<em>outstk</em>=&lt;outstk.ext&gt;] [<em>split</em>=&lt;nr of partitions to split the stack into&gt;] [<em>oritab</em>=&lt;SIMPLE alignment doc&gt;] [<em>hp</em>=&lt;high-pass limit(in A)&gt;](in A)&gt;] [<em>shalgn</em>=&lt;yes|no{no}&gt;] [<em>mul</em>=&lt;shift multiplication factor{1}&gt;] [<em>trs</em>=&lt;origin shift halfwidth(in pixels){0}] [<em>lp</em>=&lt;low-pass limit(in A){20}&gt;] [<em>state</em>=&lt;state to extract&gt;] [<em>frac</em>=&lt;fraction of ptcls to extract{1}&gt;] [<em>class</em>=&lt;cluster2extract&gt;] [<em>snr</em>=&lt;signal2noise ratio&gt;] [<em>msk</em>=&lt;mask radius(in pixels){box/2}&gt;] [<em>vis</em>=&lt;yes|no&gt;] [<em>bin</em>=&lt;binarize{no}&gt;] [<em>acf</em>=&lt;yes|no{no}&gt;] [<em>phrand</em>=&lt;yes|no{no}&gt;] [<em>fromp</em>=&lt;start ptcl&gt;] [<em>top</em>=&lt;stop ptcl&gt;] [<em>nran</em>=&lt;number of random images to select&gt;] [<em>newbox</em>=&lt;scaled box&gt;] [<em>scale</em>=&lt;scale factor{1}&gt;] [<em>hfun</em>=&lt;sigm|tanh|lin{sigm}&gt;] [<em>norm</em>=&lt;yes|no{no}&gt;] [<em>noise_norm</em>=&lt;yes|no&gt;] [<em>nthr</em>=&lt;nr of openMP threads{1}&gt;] [<em>avg</em>=&lt;yes|no&gt;] [<em>filetab</em>=&lt;filenames.txt&gt;] [<em>stats</em>=&lt;yes|no{yes}&gt;] [<em>ctf</em>=&lt;yes|no|flip|mul|abs{no}&gt;] [<em>kv</em>=&lt;acceleration voltage(in kV){300.}&gt;] [<em>fraca</em>=&lt;frac amp contrast{0.07}&gt;] [<em>cs</em>=&lt;spherical aberration constant(in mm){2.7}&gt;] [<em>deftab</em>=&lt;text file with defocus values&gt;] [<em>ft2img</em>=&lt;yes|no{no}&gt;] [<em>frameavg</em>=&lt;nr of frames to average{0}&gt;] [<em>clip</em>=&lt;clipped box size{box}&gt;] [<em>compare</em>=&lt;yes|no{no}&gt;] [<em>mirr</em>=&lt;no|x|y{no}&gt;] [<em>neg</em>=&lt;yes|no{no}&gt;] [<em>box</em>=&lt;image size(in pixels)&gt;] [<em>outfile</em>=&lt;output_params.txt&gt;] [<em>ctfsq</em>=&lt;yes|no{no}&gt;] [<em>masscen</em>=&lt;yes|no{no}&gt;] [<em>thres</em>=&lt;threshold4bin[0,1]{0.6}&gt;] [<em>inner</em>=&lt;inner mask radius(in pixels)&gt;] [<em>width</em>=&lt;pixels falloff inner mask{10}&gt;] [<em>append</em>=&lt;yes|no{no}&gt;]<br></p>
      <p><span class="h2_manual">Comments:<br>
      </span> You can do many things with <em>simple_stackops</em>. Inputting two stacks of the same size results in the calculation of the joint Fourier Ring  Correlation (FRC) between the images. Inputting no stacks, but setting <em>nptcls</em>, results in production of <em>nptcls</em> pure noise images, unless <em>ctf=yes</em>, then CTF images are produced. Filtering is controlled by the <em>hp</em> and <em>lp</em> arguments. If you input an alignment document (via <em>oritab</em>) <em>shalgn=yes</em> will produce a shift-aligned stack based on the inputted orientations, whereas if you do not input an alignment document, the alignment will be done in a reference-free manner (remember to set <em>trs</em> to some nonzero value). If you want to centre the images based on their centre of mass, set <em>masscen=yes</em>. If you want to extract a particular state, give an alignment document (<em>oritab</em>) and set <em>state</em> to the state that you want to extract. If you want to select the fraction of best particles (according to the goal function), input an alignment doc (<em>oritab</em>) and set <em>frac</em>. You can combine the <em>state</em> and <em>frac</em> options. If you want to apply noise to images, give the desired signal-to-noise ratio via <em>snr</em>. If you want to mask your images with a spherical mask with a soft falloff, set <em>msk</em> to the radius in pixels. If you want to binarize your images, set <em>bin=yes</em>. If <em>thres</em> is defined, the images are sigmoid normalised to  and threshold binarized. If <em>thres</em> is not defined the foreground/background pixels are assigned by sort-means (a variant of the continuous k-means algorithm where the initial centres are obtained by sorting the real values). If you want to calculate the autocorrelation function of your images set <em>acf=yes</em>. If you want to randomise the phases of the Fourier transforms of your images, set <em>phrand=yes</em> and <em>lp</em> to the desired low-pass limit. If you want to extract a contiguous subset of particle images from the stack, set <em>fromp</em> and <em>top</em>. If you want to fish out a number of particle images from your stack at random, set <em>nran</em> to some nonzero integer number less than <em>nptcls</em>. If you want to resize your images, set the desired box to <em>newbox</em> or use the <em>scale</em> option. It is often convenient to use <em>scale</em> in rcombination with <em>clip</em> to resize images.  If you want to normalise your images, set <em>norm=yes</em>. <em>hfun</em> controls the normalisation function. With <em>avg=yes</em> the global average of the inputted stack is calculated. With <em>ctf=flip</em> the contrast inversions due to the CTF are corrected by the infamous (but effective) phase-flipping heuristic. This requires additional input of CTF-related parameters (<em>kv</em>, <em>fraca</em> and <em>cs</em>) in addition to the defocus and astigmatism angle values, communicated either via <em>oritab</em> or via <em>deftab</em>. Even if you do initially phase-flip the images, which you should do for initial model production with PRIME, you can turn on the Wiener restoration later anyway, to accomplish correct weighting of information around the CTF zeroes and maximal noise reduction. <em>ft2img=yes</em> produces images of the square power spectrum of the images in <em>stk</em>. If you define <em>frameavg</em> to some integer number larger than one, averages with chunk sizes of <em>frameavg</em> are produced that may be useful for analysis of dose-fractionated image series. <em>clip</em> can be used to re-window or pad the images to a different box size. When <em>compare=yes</em>, the two inputted stacks are Fourier ring correlated. <em>neg</em> inverts the contrast of the images. <em>ctfsq</em> applies the squared CTF to the inputted images. <em>inner</em> is for applying an inner mask with fall-off width <em>width</em>. Finally, <em>append</em> is for appending stack <em>stk2</em> with stack <em>stk</em>, so that the <em>stk2</em> images occur last in the series and the stk name is preserved.</p>
      </div>
      </div>
      
      
      <div class="AccordionPanel">
        <div class="AccordionPanelTab">simple_volops</div>
        <div class="AccordionPanelContent">
          <p><strong>simple_volops</strong> provides standard single-particle image processing routines that are applied to MRC or SPIDER volumes.</p>
          <p align="left"><span class="h2_manual">Usage:<br>
       </span> &gt;&gt;&gt;<strong>simple_volops </strong>[<em>vol1</em>=&lt;invol.ext&gt;] [<em>vol2</em>=&lt;invol2.ext&gt;] [<em>smpd</em>=&lt;sampling distance(in A)&gt;] [<em>outvol</em>=&lt;outvol.ext&gt;] [<em>nthr</em>=&lt;nr of openMP threads{1}&gt;] [<em>phrand</em>=&lt;yes|no{no}&gt;] [<em>msk</em>=&lt;mask radius(in pixels)&gt;] [<em>lp</em>=&lt;low-pass limit{20}&gt;] [<em>hp</em>=&lt;high-pass limit{100}&gt;] [<em>snr</em>=&lt;signal-to-noise ratio&gt;] [<em>center</em>=&lt;yes|no{no}&gt;] [<em>soften</em>=&lt;yes|no{no}&gt;] [<em>guinier</em>=&lt;yes|no{no}&gt;] [<em>bfac</em>=&lt;bfactor(in A**2){200.}&gt;] [<em>edge</em>=&lt;edge size for softening molecular envelope(in pixels){3}&gt;] [<em>mskfile</em>=&lt;mask.ext&gt;] [<em>countvox</em>=&lt;yes|no{no}&gt;] [<em>newbox</em>=&lt;scaled box&gt;] [<em>scale</em>=&lt;scale factor{1}&gt;] [<em>msktype</em>=&lt;hard|soft{soft}&gt;] [<em>inner</em>=&lt;inner mask radius(in pixels)&gt;] [<em>width</em>=&lt;pixels falloff inner mask{10}&gt;] [<em>cube</em>=&lt;side (in pixels){0}&gt;] [<em>e1</em>=&lt;1st Euler{0}&gt;] [<em>e2</em>=&lt;2nd Euler{0}&gt;] [<em>e3</em>=&lt;3d Euler{0}&gt;] [<em>corner</em>=&lt;corner size{0}&gt;] [<em>neg</em>=&lt;yes|no{no}&gt;] [<em>voltab</em>=&lt;file table&gt;] [<em>voltab2</em>=&lt;file table&gt;] [<em>bin</em>=&lt;yes|no{no}&gt;] [<em>nvox</em>=&lt;nr of voxels{0}&gt;] [<em>xsh</em>=&lt;x shift(pixels){0}&gt;] [<em>ysh</em>=&lt;y shift(pixels){0}&gt;] [<em>zsh</em>=&lt;z shift(pixels){0}&gt;]<br></p>
      <p><span class="h2_manual">Comments:<br>
      </span> If you input two volumes and the sampling distance, the FSC is calculated between the volumes. The FSC plot is written to STDOUT together with resolution estimates at  in Fourier space. <em>voltab</em> and <em>voltab2</em> are used to give text files with the names of volume files that are correlated and the nearest neighbour structure of the comparison is written to STDOUT.</p>
      </div>
      </div>
    
 	</div> 
 <!-- ACCORDION 4 END -->
 
 
 
 <!-- ACCORDION 5 START -->

<!-- Utility programs
    (1) print_fsc
    (2) res
    (3) projvol -->
    
	<h2 class="h2_manual" align="left"> &nbsp; &nbsp;Utility programs</h2>
    
	<div id="Accordion5" class="Accordion" >
  
      <div class="AccordionPanel">
        <div class="AccordionPanelTab">simple_print_fsc</div>
        <div class="AccordionPanelContent">
          <p><strong>simple_print_fsc</strong> is a program for printing the binary FSC files produced by PRIME3D</p>
          <p align="left"><span class="h2_manual">Usage:<br>
       </span> &gt;&gt;&gt;<strong>simple_print_fsc </strong><em>smpd</em>=&lt;sampling distance(in A)&gt; <em>box</em>=&lt;image size(in pixels)&gt; <em>fsc</em>=&lt;fsc_state1.bin&gt;<br></p>
      </div>
      </div>
      
      
      <div class="AccordionPanel">
        <div class="AccordionPanelTab">simple_res</div>
        <div class="AccordionPanelContent">
          <p><strong>simple_res</strong> is a program for checking the low-pass resolution limit for a given Fourier index.</p>
          <p align="left"><span class="h2_manual">Usage:<br>
       </span> &gt;&gt;&gt;<strong>simple_res </strong><em>smpd</em>=&lt;sampling distance(in A)&gt; <em>find</em>=&lt;Fourier index&gt; <em>box</em>=&lt;box size (in pixels)&gt;<br></p>
      </div>
      </div>
      
      
      <div class="AccordionPanel">
        <div class="AccordionPanelTab">simple_projvol</div>
        <div class="AccordionPanelContent">
          <p><strong>simple_projvol</strong> is a program for projecting a volume using interpolation in Fourier space. Input is a SPIDER or MRC volume. Output is a stack of projection images of the same format as the inputted volume.</p>
          <p align="left"><span class="h2_manual">Usage:<br>
       </span> &gt;&gt;&gt;<strong>simple_projvol </strong><em>vol1</em>=&lt;invol.ext&gt; <em>smpd</em>=&lt;sampling distance(in A)&gt; [<em>nspace</em>=&lt;nr of projs{1000}&gt;] [<em>outstk</em>=&lt;ouput stack&gt;] [<em>oritab</em>=&lt;SIMPLE alignment doc&gt;] [<em>nthr</em>=&lt;nr of openMP threads{1}&gt;] [<em>rnd</em>=&lt;yes|no{no}&gt;] [<em>trs</em>=&lt;origin shift(in pixels){0}&gt;]<br>

          <strong>** less commonly used**</strong>  [<em>pgrp</em>=&lt;cn|dn|t|o|i{c1}&gt;] [<em>ctf</em>=&lt;yes|no|flip|mul{no}&gt;] [<em>kv</em>=&lt;acceleration voltage(in kV){300.}&gt;] [<em>fraca</em>=&lt;frac amp contrast{0.07}&gt;] [<em>cs</em>=&lt;spherical aberration constant(in mm){2.7}&gt;] [<em>defocus</em>=&lt;underfocus(in microns){3.}&gt;] [<em>bfac</em>=&lt;bfactor(in A**2){200.}&gt;] [<em>neg</em>=&lt;yes|no{no}&gt;] [<em>mirr</em>=&lt;yes|x|y|no{no}&gt;] [<em>top</em>=&lt;stop at this index&gt;] [<em>xfel</em>=&lt;yes|no{no}&gt;]</p>
      <p><span class="h2_manual">Comments:<br>
      </span> Projections are generated by extraction of central sections from the Fourier volume and back transformation of the 2D FTs. <em>nspace</em> controls the number of projection images generated with quasi-even projection directions. The <em>oritab</em> parameter allows you to input the orientations that you wish to have your volume projected in. If <em>rnd=yes</em>, random rather than quasi-even projections are generated, <em>trs</em> then controls the half-width of the random origin shift. Less commonly used parameters are <em>pgrp</em>, which controls the point-group symmetry <em>c</em> (rotational), <em>d</em> (dihedral), <em>t</em> (tetrahedral), <em>o</em> (octahedral) or <em>i</em> (icosahedral). The point-group symmetry is used to restrict the set of projections to within the asymmetric unit. <em>ctf=yes</em> allows you to apply CTF to the images, using constant defocus and no astigmatism. If you want to do this you need to define the parameters <em>kv</em>, <em>fraca</em>, <em>cs</em>, <em>defocus</em> and <em>bfac</em>. <em>neg</em> inverts the contrast of the projections. <em>mirr=yes</em> mirrors the projection by modifying the Euler angles. If <em>mirr=x</em> or <em>mirr=y</em> the projection is physically mirrored after it has been generated.</p>
      </div>
      </div>

    


 	</div> 
 <!-- ACCORDION 5 END -->
 
 
 
 


  <h2 class="h2_manual" align="center"><a href="#top">top</a></h2>
  <p class="text">
 </p>
</div>

<script type="text/javascript">
var Accordion0 = new Spry.Widget.Accordion("Accordion0", { useFixedPanelHeights: false, defaultPanel: -1 });
</script>
<script type="text/javascript">
var Accordion1 = new Spry.Widget.Accordion("Accordion1", { useFixedPanelHeights: false, defaultPanel: -1 });
</script>
<script type="text/javascript">
var Accordion2 = new Spry.Widget.Accordion("Accordion2", { useFixedPanelHeights: false, defaultPanel: -1 });
</script>
<script type="text/javascript">
var Accordion3 = new Spry.Widget.Accordion("Accordion3", { useFixedPanelHeights: false, defaultPanel: -1 });
</script>
<script type="text/javascript">
var Accordion4 = new Spry.Widget.Accordion("Accordion4", { useFixedPanelHeights: false, defaultPanel: -1 });
</script>
<script type="text/javascript">
var Accordion5 = new Spry.Widget.Accordion("Accordion5", { useFixedPanelHeights: false, defaultPanel: -1 });
</script>

<!-- InstanceEndEditable -->
<h1>&nbsp;</h1>
<script type="text/javascript">
var MenuBar1 = new Spry.Widget.MenuBar("MenuBar1", {imgDown:"SpryAssets/SpryMenuBarDownHover.gif", imgRight:"SpryAssets/SpryMenuBarRightHover.gif"});
</script>
</body>
<!-- InstanceEnd --></html>
